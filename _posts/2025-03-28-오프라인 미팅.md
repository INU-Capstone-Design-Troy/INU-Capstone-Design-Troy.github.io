---
layout: post
title:  "03-28 오프라인&온라인인 미팅"
date:   2025-03-28 12:00:00 +0900
---

- **일시**: 2025년 3월 28일 (금) 15:00 ~ 20:00
- **장소**: 오프라인 7호관 302
- **참석자**: 장경은(온라인), 손승민, 이태우, 최연호
- **회의 주제**: 아이디어 구체화 및 계획일정 설립

---
1. 타겟층 정하기 (완전 초보자) O
2. 단계적 피드백 구체화(원자적으로 할 것인지)
3. 부가 기능 구체화
4. 평가표 작성

- 기존의 기능
1. 단계적 피드백
2. 키워드 강조 기능 😒
3. 기본 개념 하이퍼링크 기능 😒
4. 유사 문제 추천기능 
5. 릴레이 코딩기능   😡
6. *포인터 시각화 기능 😒*
7. 피드백 히스토리 기능 😡
8. 문제 규칙 검사 기능 
9. 반례 제공 기능 😡

---

1. 코드로직맵기능 → 순서도
2. 1단계기능
3. 2단계기능
4. 3단계기능
5. 하이퍼링크
6. 유사문제
7. 포인터시각화
8. 패턴분석

- gpt에게 그냥 피드백 해달라하면 막연하게 되는것이 아니다.
    
    ## **🚀 정형화된 피드백 시스템을 설계하는 방법**
    
    💡 **"GPT에게 그냥 물어보면 되겠지" → ❌**
    
    💡 **"우리가 피드백의 틀을 만들고, GPT는 그 안에서 데이터를 채우도록 한다" → ✅**
    
    교수님이 원하는 건 **일관되고 체계적인 피드백 구조**야.
    
    그럼 아래처럼 **정형화된 피드백 템플릿**을 만들어서, 어떤 코드든 동일한 기준으로 피드백을 제공하도록 하면 돼!
    
    ---
    
    ## **🛠 피드백을 정형화하는 4단계 접근법**
    
    ### **1️⃣ 문제 상황 분석 (틀린 이유 분석) → [오류 유형 분류]**
    
    👉 사용자의 코드가 틀린 경우, **우리가 직접 오류 유형을 정의**하고, 그에 맞게 피드백을 제공
    
    - **예제**:
        - 🚨 **입력/출력 오류** → "scanf에서 개행 문자가 문제일 가능성이 있습니다."
        - 🚨 **메모리 관련 오류** → "포인터를 잘못 참조하고 있습니다."
        - 🚨 **논리 오류** → "for 문에서 탈출 조건이 잘못되었습니다."
    
    ✅ **우리가 해야 할 일:**
    
    - 자주 발생하는 오류 패턴을 정리하여 **정형화된 오류 분류 시스템** 구축
    - GPT는 단순한 도우미 역할, **우리는 직접 오류 유형을 정의해야 함**
    
    ---
    
    ### **2️⃣ 코드 실행 흐름 분석 (디버깅 가이드) → [변수 및 상태 변화 추적]**
    
    👉 피드백이 막연하지 않도록, **코드 실행 흐름을 분석하여 구체적인 힌트를 제공**
    
    - **예제:**
        - 🔍 **변수 값 추적:** `"변수 sum이 계속 0이 유지됩니다. sum 값이 갱신되지 않는 이유를 확인해보세요!"`
        - 🔍 **배열 인덱스 오류:** `"배열의 크기는 5인데, 인덱스 5에 접근하려고 하고 있습니다. 이 부분을 확인해보세요."`
    
    ✅ **우리가 해야 할 일:**
    
    - 변수 값 변화를 기록하고, 특정 조건에서 이상이 감지되면 **자동으로 피드백 생성**
    - GPT에게 "이 코드에서 sum 값이 계속 0이 되는 이유를 설명해줘"라고 묻는 게 아니라,
        - **우리가 sum 값이 0으로 유지되는 상태를 감지하고, 그에 맞는 피드백을 GPT가 채우도록 함**
    
    ---
    
    ### **3️⃣ 대안 코드 제시 (개선 방법 안내) → [최적 코드 추천]**
    
    👉 틀린 코드에 대한 올바른 해결책을 제공할 때도, 막연하게 답을 주는 게 아니라 **구체적인 대안 코드와 비교하도록 한다.**
    
    - **예제:**
        - ❌ **사용자 코드 (잘못된 코드)**
            
            ```c
            c
            복사편집
            for (int i = 1; i <= n; i++) sum += arr[i];
            
            ```
            
        - ✅ **수정 코드 (정답 코드)**
            
            ```c
            c
            복사편집
            for (int i = 0; i < n; i++) sum += arr[i];
            
            ```
            
        - ✍️ **피드백:** `"배열의 인덱스 범위가 [0, n-1]인데, 1부터 시작하여 마지막 값을 건너뛰고 있습니다."`
    
    ✅ **우리가 해야 할 일:**
    
    - GPT가 단순히 코드 수정안을 내는 게 아니라, **우리가 "틀린 코드와 정답 코드 비교" 형식으로 피드백을 정형화**
    - "어떤 부분이 어떻게 개선되는지" 구조적으로 설명하도록 설계
    
    ---
    
    ### **4️⃣ 학습 경로 추천 (개념 보강) → [맞춤형 학습 피드백]**
    
    👉 단순히 "이 부분이 틀렸어요"가 아니라, **"당신이 부족한 개념이 무엇인지"까지 분석해서 학습 경로를 추천**
    
    - **예제:**
        - `"당신은 최근 3문제에서 배열 인덱스 오류를 겪었습니다. 배열 기초 개념을 복습하는 것이 좋겠습니다."`
        - `"반복문 내 조건문을 잘못 작성하는 패턴이 보입니다. '제어문' 관련 문제를 추천해드릴까요?"`
    
    ✅ **우리가 해야 할 일:**
    
    - 단순히 문제 추천이 아니라, **사용자의 패턴을 분석하여 개인 맞춤 학습 플랜을 제공하는 시스템 설계**
    - GPT는 그저 문제를 추천하는 역할, **우리가 사용자의 학습 데이터 분석을 설계해야 함**
- 프롬프트를 너네가 제공하면 끝인거 아니냐?
    
    ## **💡 "좋은 프롬프트 제공" vs. "우리가 만드는 피드백 시스템" 차이**
    
    |  | **GPT에게 직접 질문** 🤔 | **우리가 개발하는 피드백 시스템** 🚀 |
    | --- | --- | --- |
    | **정확성** | 학생이 틀린 이유를 직접 설명해야 함 → 설명이 부족하면 GPT가 틀린 답변을 줄 수도 있음 | OJ의 실제 채점 데이터를 바탕으로 정확한 오류 분석 제공 |
    | **자동화** | 학생이 직접 질문해야 함 (능동적 접근 필요) | 틀린 코드 제출 시 자동으로 단계별 피드백 제공 |
    | **일관성** | 같은 질문을 해도 GPT 답변이 매번 달라질 수 있음 | 정형화된 피드백 구조를 제공하여 일관성 유지 |
    | **코드 실행 가능 여부** | GPT는 코드를 실행하지 못함 → 추측 기반 피드백 | 실제 실행 결과와 테스트 케이스 기반 피드백 제공 |
    | **학습 경로 추천** | 개별 코드에 대한 답변만 제공 | 학생의 학습 패턴 분석 및 맞춤형 추천 기능 |
    | **코드 최적화 & 스타일 분석** | 일반적인 조언만 가능 (구체적이지 않음) | 실행 속도, 메모리 사용량까지 분석하여 개선점 제시 |
    
    ### **프롬프트 제공 방식 (학생이 GPT에게 물어봄)**
    
    - GPT는 **이론적인 피드백**을 제공할 수 있지만, 실제로 **코드를 실행하지 않아서** **실행 결과를 반영한 피드백을 제공하지 못함.**
    - 예를 들어, **"내 코드가 왜 틀렸는지"** 물어봐도 GPT는 **추측 기반으로 답을 주기 때문에, 실제 문제를 해결하는 데 시간이 걸릴 수 있음.**
    
    ### **피드백 시스템 (실제 코드 실행 결과 기반 피드백)**
    
    - 우리가 만드는 시스템은 **실제 코드를 실행하고**, **테스트 케이스와 채점 데이터를 기반으로 피드백을 제공**해.
    - 예를 들어, **학생이 틀린 이유를 구체적으로 분석**하고, **실제 코드 실행 흐름**을 따라가면서 **디버깅을 돕는 시각적 도구**나 **변수 값 추적**을 제공할 수 있어.
    - 이 방법은 **실제 문제 해결을 위한 피드백**이므로, **학습 효과**가 더 크고, **직접 코드와 실행 결과를 분석**하므로 더 정확한 피드백을 제공할 수 있어.

- 부가 기능

### 1. 🗺️ **코드 로직 맵 기능 (Flow Tracker)**

- **설명**: 작성한 코드의 실행 흐름을 자동으로 시각화한 간단한 플로우 차트를 생성
- **효과**: 초보자가 자신의 코드 흐름을 ‘말로 설명’할 수 있도록 도와주며 디버깅에도 유리
- **예시**:
    
    ```
    sql
    
    start → 변수 선언 → 반복문 → 조건문 → 출력 → end
    ```
    

1. **문법적 실수 패턴 분석 (Mistake Pattern Analysis) ← 히스토리기능 보완.**
- 학생이 자주 범하는 **실수의 패턴**을 분석하고, 그 패턴을 기반으로 **개선 경로**를 제공하는 기능입니다.
- **기능**: 학생의 **실수 패턴**을 추적하고, **어떤 개념에서 자주 실수하는지** 분석합니다. 이를 바탕으로 **맞춤형 학습 계획**을 제공하고, **실수 확률을 줄이기 위한 가이드라인**을 제시합니다.
- 예시)
    
    배열범위초과 5문제, 초기화되지 않은 변수 사용 3문제, 기본 자료형 잘못 사용 1문제
    

### 3. 🪄 **내 코드 재작성 유도기 (Blind Rewrite Engine) → 기능 보다는 피드백 형식으로 good**

> LLM이 학습자 코드의 구조만 남기고 식별자 제거
> 
> 
> → 같은 로직을 **스스로 다시 구현하게 함**
> 
- **예시**:
    
    ```markdown
    markdown
    복사편집
    for (int ____ = 0; ____ < ____; ____++) {
        ____ += arr[____];
    }
    
    ```
    

### 4. 자주 사용하는 기법 연습 기능

- 자주 사용하는 기법 소개
- 문제 푸는 패턴을 익힐 수 있음
- 어떻게 풀어야겠다고 머리 속으로 생각하지만 구현할 기법을 모를 때
- 이 방법을 어떤 상황들에 적용할 수 있는지도 알려주면 좋겠다
    - 문제 추천 기능과 결합
        - 이 문제를 이 기법 써서 풀어봐라
- 예시
    - (n^2번 반복)
    - n을 입력받아 n^2을 출력하는 코드를 작성하세요.
    
    ```c
    int count = 0;
    
    for(int i = 0; i < n; i++) {
    	for(int j = 0; j < n; j++) {
    		count++;
    	}
    }
    
    printf("%d", count);
    ```
    
    - 같은 것 비교
    - 주어진 배열(n칸) 내에서 3을 제거하세요.
    
    ```c
    int n = 5;
    
    arr[n] = {1,2,3,4,5}
    
    for(int i = 0; i < 5; i++) {
    	if(arr[n] == 3) {
    		~~~
    	}
    }
    ```
    

### 이외 기능 아이디어

C언어(포인터, 함수) 보드게임
[http://www.c-jump.com/CjumpBoardGameVirtualTour/index2.html](http://www.c-jump.com/CjumpBoardGameVirtualTour/index2.html)

오늘의 미션(오늘의 코드)

주관식 문제(상위권은 문제를 말로 풀어보고, 하위권은 그걸 보고 공부)

빈칸 뚫은 코드 채워넣기

- 빈칸 뚫은 코드 채워넣기
    
    1.[https://school.programmers.co.kr/learn/courses/5/lessons/901](https://school.programmers.co.kr/learn/courses/5/lessons/901)
    
    강의연습문제에서 빈칸 뚫은 코드 채워넣기로 한다.
    
    2.
    
<img width="432" alt="Image" src="https://github.com/user-attachments/assets/5a2a952b-96e2-41dd-8cd0-7227b5ca8cf5" />
    
    정보처리기사 기출문제
    
    국가시험중 하나인 정처기에서 빈칸추론 문제가 나온다.
    

---

## 생각해보아야 할 문제

- 기본 OJ로 제출할 때 피드백을 줄 것인가

### 추가 아이디어

1. LLM에게 실패한 테스트케이스를 같이 넘겨주어 정확도 향상

## 단계별 피드백 overview

![Image](https://github.com/user-attachments/assets/3c5ed5fb-534a-45e7-9269-c2417710e615)

![Image](https://github.com/user-attachments/assets/8d31563d-1242-4766-a50d-35b26b6352d6)

![Image](https://github.com/user-attachments/assets/d2034eb2-7306-4665-a350-bca7df57acdc)

![Image](https://github.com/user-attachments/assets/f9803944-286d-43c2-97e1-cdac7722ff4a)

![Image](https://github.com/user-attachments/assets/b7940fdb-2043-4f38-9a82-a2fea9eb5240)

![Image](https://github.com/user-attachments/assets/7a669135-cbd8-4271-95fa-a8605cd4207b)

### 피드백 overview(JPG)

![Image](https://github.com/user-attachments/assets/2fd68e03-bb2b-4695-bec4-cf65195c9e62)

![Image](https://github.com/user-attachments/assets/6240f45f-3e6c-499f-92b8-080f74ea79a9)

![Image](https://github.com/user-attachments/assets/1f9ba1c1-0473-493a-86c8-ede7d65efcf7)

![Image](https://github.com/user-attachments/assets/80a35e73-df05-4d41-93d2-29f00c8ffdd2)

![Image](https://github.com/user-attachments/assets/b2b04727-2337-4e23-8634-2701b4e137e3)

### sLLM 테스트

- 사용 모델
    - llama-3.2-Korean-Bllossom-3B-gguf-Q4_K_M
        - gemma 모델을 찾아서 진행해보려 했지만 한국어 + 양자화 모델을 찾지 못하여 시간관계상 기존 모델로 진행

- 문제풀이 능력
    - 프롬프트
    
    ```c
    instruction = """주어진 문제를 해결하는 C언어 코드를 작성하세요.\n
    
            문제 : 양의 정수 n이 입력되면, n! (n factorial)을 계산하고, 그 결과보다 작은 소수의 개수를 출력하시오.
            
            """
    ```
    
    - 출력 결과
        
        ```c
        여기에는 C언어에서 n! (n의 가변)을 계산하고, 그 결과보다 작은 소수의
         개수를 출력하는 코드가 있습니다.
        
        ```c
        #include <stdio.h>
        
        // 소수 함수
        int is_prime(int num) {
            if (num < 2) return 0;
            for (int i = 2; i * i <= num; i++) {
                if (num % i == 0) return 0;
            }
            return 1;
        }
        
        // n!을 계산하는 함수
        long long factorial(int n) {
            long long result = 1;
            for (int i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }
        
        int main() {
            int n;
            printf("양의 정수 n을 입력하세요: ");
            scanf("%d", &n);
        
            if (n < 0) {
                printf("입력된 수는 정수에서만 계산할 수 없습니다.\n");     
                return 1;
            }
        
            long long n_factorial = factorial(n);
            int count = 0;
        
            for (int i = 1; i < n; i++) { ///// for문 오류 /////
                if (is_prime(i)) count++;
            }
        
            printf("n! (n=%d)의 소수의 개수는 %d입니다.\n", n, count);      
        
            return 0;
        }
        ```
        
        이 코드는 다음과 같은 작업을 수행합니다:
        1. `is_prime` 함수는 주어진 수가 소수인지 확인합니다.
        2. `factorial` 함수는 n!을 계산합니다.
        3. `main` 함수는 사용자로부터 n을 입력받습니다.
        4. n!을 계산하고, n!보다 작은 소수를 찾고 카운트합니다.
        5. 결과를 출력합니다.
        ```
        
        - 일단 코드부터 틀린 것을 확인
    
    - 소요시간
        - 약 25초

- 단계적 문제 제작 테스트
    - 프롬프트
    
    ```c
    주어진 문제를 해결하는 C언어 코드를 작성하고, 코드의 각 줄에 대한 설명을 주석 형태로 제공하세요.\n
    단, 코드를 출력하지 말고, 오직 주석 내용만 출력하세요.\n
    "다음은 각 코드 줄에 대한 설명입니다."라고 시작하고, 한 줄씩 설명을 제공하세요.\n
    함수는 사용하지 않고, stdio.h만 사용하세요.\n
    예를들어 변수를 입력받는 int n; 이라는 코드가 있다면 "// 입력값을 저장하는 변수 n 선언" 이런식으로 출력하세요.\n
    
            문제 : 양의 정수 n이 입력되면, n! (n factorial)을 계산하고, 그 결과보다 작은 소수의 개수를 출력하시오.
    ```
    
    - 출력  결과
        
        ```c
        4. int main() {
        5.     int n, i;
        6.     printf("양의 정수 n을 입력해 주세요: ");
        7.     scanf("%d", &n);
        8.     if (n < 0) {
        9.         printf("n은 0이상이어야 합니다.");
        10.         exit(1);
        11.     }
        12.     if (n < 2) {
        13.         printf("n!의 소수 개수는 1입니다.");
        14.         return 0;
        15.     }
        
        16.     long long result = 1;
        17.     for (i = 2; i <= n; i++) {
        18.         if (isPrime(i)) {
        19.             result++;
        20.         }
        21.     }
        
        22.     printf("n!의 소수 개수는 %lld입니다.\n", result);
        23.     return 0;
        24. }
        
        25. bool isPrime(int num) {
        26.     if (num == 1 || num == 0) {
        27.         return false;
        28.     }
        29.     for (int i = 2; i * i <= num; i++) {
        30.         if (num % i == 0) {
        31.             return false;
        32.         }
        33.     }
        34.     return true;
        ```
        
        - 사용하기 힘들어 보인다.

## gemma3 파인튜닝

- 사용 모델
    - unsloth/gemma-3-4b-it

- 한국어를 가르쳐 보자
    - [https://huggingface.co/datasets/OnomaAIResearch/s1k_Korean](https://huggingface.co/datasets/OnomaAIResearch/s1k_Korean)
        - 위 데이터셋을 사용

- Colab 예시를 상황에 맞게 변경
    - https://colab.research.google.com/github/unslothai/notebooks/blob/main/nb/Gemma3_(4B).ipynb#scrollTo=f-Aa51Y0ncQQ
    - 모델 설정 OK
    - 4bit 양자화 OK?
        
        ![Image](https://github.com/user-attachments/assets/361d1f9a-bac3-4e95-97e5-feb513a9ed12)
        
        - 여기서 4bit 양자화는 켠 거 같은데..
        
        ![Image](https://github.com/user-attachments/assets/788417fa-af71-4e6c-ae35-76b3978dee23)
        
        - 다운로드 설정에서 양자화 타입은 8bit, 16bit만 지원한다?
        - 일단 3B 8bit 양자화 모델은 3060 laptop에서 돌릴 수 있으니 Q8_0으로 그대로 두고 진행
    - 학습시킬 데이터셋 변경 OK
        
        ![Image](https://github.com/user-attachments/assets/fa5b88bb-58e4-4be5-aacf-5d0ae972a9cf)

- 실패
    - 데이터셋 잘못 가져옴