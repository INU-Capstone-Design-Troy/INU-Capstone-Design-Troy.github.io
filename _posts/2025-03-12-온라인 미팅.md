---
layout: post
title:  "03-11 온라인 미팅"
date:   2025-03-11
---

- **일시**: 2025년 3월 12일 (수) 20:00 ~ 23:00
- **장소**: 온라인(discord)
- **참석자**: 장경은, 손승민, 이태우, 최연호
- **회의 주제**: 아이디어 회의

---

### 오늘의 할일

- [x]  승민 → 디자인 설계 결과 확인
- [x]  기술 구현 방식 구체화
- [x]  조교님께 피드백 요청 드리기

### 1) 디자인 설계 결과 확인 O

### 2) 기술 구현 방식 구체화

![Image](https://github.com/user-attachments/assets/cd2af40a-c957-4838-b507-0338a2cbdc28)

### 3) 조교님께 피드백 요청 드리기 O

---

---

## 문제 프롬프트 생성 및 스트리밍 방식 구현

- 문제
    - https://www.acmicpc.net/problem/1100
    - 문제
        - 체스판은 8×8크기이고, 검정 칸과 하얀 칸이 번갈아가면서 색칠되어 있다. 가장 왼쪽 위칸 (0,0)은 하얀색이다. 체스판의 상태가 주어졌을 때, 하얀 칸 위에 말이 몇 개 있는지 출력하는 프로그램을 작성하시오.

승민

[GPT4.0을 통한 프롬프트 출력 정리](https://www.notion.so/GPT4-0-1b44378af66f8026b7c0f5544dcd9c59?pvs=21)

태우

- 문제 프롬프트

```
"""제공된 문제에 대해 학생이 제출한 코드에 대한 피드백을 작성하시오. 단, 절대로 답(코드)을 알려줘서는 안되며 최대한 간접적으로 힌트를 주어야 합니다. C언어를 처음 접하는 학생 수준임을 감안하세요.\n
        문제 : 체스판은 8×8크기이고, 검정 칸과 하얀 칸이 번갈아가면서 색칠되어 있다. 가장 왼쪽 위칸 (0,0)은 하얀색이다. 체스판의 상태가 주어졌을 때, 하얀 칸 위에 말이 몇 개 있는지 출력하는 프로그램을 작성하시오.
        입력의 첫째 첫째 줄부터 8개의 줄에 체스판의 상태가 주어진다. ‘.’은 빈 칸이고, ‘F’는 위에 말이 있는 칸이다.

```

- 프롬프트수정
    
    ```jsx
    """제공된 문제에 대해 학생이 제출한 코드에 대한 피드백을 작성하시오. 
    단, 절대로 답(코드)을 알려줘서는 안되며 최대한 간접적으로 힌트를 주어야 합니다.
    한줄한줄의 코드도 알려줘서는 안됩니다. 학생의 수준은 c언어를 처음접하는 학생입니다.\n
    ```
    
    학생의 코드에 대해 몇 가지 피드백을 드리겠습니다.
    
    1. **입력 처리 방법**:
    `scanf_s` 함수는 C언어에서 안전한 입력을 위해 사용되지만, 이 문제에서는 `scanf`로도 충분히 처리할 수 있습니다. `scanf_s`와 `scanf`의 차이를 생각해보세요. 입력 방식에 대해 다시 한번 검토해보는 것이 좋습니다.
    2. **배열 인덱스**:
    `board` 배열의 크기는 정확하게 지정되었습니다. 그러나 배열에 값을 입력받을 때, 각 줄을 처리할 때 `\n` 문자를 처리하는 부분에서 주의가 필요합니다. 이 부분을 잘 생각해보세요. 실제로 입력받은 값 뒤에 `\n`이 있을 수 있기 때문에 이를 어떻게 처리할지 고민해 보세요.
    3. **체스판 색깔에 대한 조건**:
    `i % 2 == 1 && j % 2 == 1` 조건은 정확히 짝수, 홀수 칸에 대해서만 동작합니다. 하지만 문제에서 요구하는 것은 '하얀 칸'에 대해서만 말이 있는지를 체크하는 것입니다. 체스판에서 하얀 칸이 어떤 규칙으로 배치되어 있는지 다시 한번 떠올려보세요. 그에 맞는 조건을 고민해보세요.
    4. **배열을 순회하는 방식**:
    배열을 순회할 때, 이차원 배열을 다룰 때 행(row)과 열(column)을 어떻게 구분하는지 신경 써야 합니다. 이 부분에서 올바르게 순회할 수 있도록 생각해보세요. 배열을 한 번 순회하는 것 외에도, 조건에 맞는 칸을 찾기 위한 논리를 조금 더 신중하게 고려해보세요.
    5. **출력 형식**:
    `printf`로 출력하는 부분은 잘 처리되었습니다. 단, 문제에서 요구하는 정확한 출력 형태에 맞게 출력할 수 있도록 해주세요. 출력 형식은 미리 확인하고, 원하는 대로 출력되는지 점검하세요.
    
    학생이 잘못한 부분을 스스로 이해하고 수정할 수 있도록 힌트를 주려고 노력했습니다. 조금 더 구체적인 구현 방법에 대해 고민해보세요.
    
    ### 숙련자
    
    학생이 제출한 코드에 대한 피드백을 드리겠습니다.
    
    1. **입력 처리**:
    입력을 처리할 때 `scanf_s`를 사용하고 있습니다. `scanf_s`는 안전한 입력을 위해 사용되지만, C에서 기본적으로 제공되는 `scanf`도 문제 없이 사용할 수 있습니다. 다른 함수와의 차이를 정확히 이해하고 사용하는 것이 중요합니다. 특히 `\n` 문자 처리에서 주의가 필요할 수 있습니다. 입력을 받을 때 공백이나 줄바꿈 문자가 입력에 영향을 미칠 수 있으므로 이 부분을 신경 써보세요.
    2. **체스판 색깔을 구분하는 조건**:
    체스판의 칸이 흰색과 검은색으로 번갈아 배치됩니다. 문제에서 요구하는 것은 '하얀 칸'에 말을 올려놓았는지 확인하는 것인데, 현재 조건은 홀수 인덱스에서만 동작합니다. 체스판에서 하얀 칸은 어떻게 배치되어 있는지 잘 생각해보세요. 그에 맞게 조건을 수정할 필요가 있을 것입니다.
    3. **배열 순회**:
    배열을 순회하는 방식이 잘 작성되었습니다. 하지만 배열을 8x8 크기로 정확하게 처리하고, 원하는 칸에 대해서만 조건을 적용하려면 좀 더 세밀한 주의가 필요합니다. 배열의 각 칸을 순회할 때, 체스판의 색깔을 잘 구분해야 하는데, 이 부분에서 조건을 다시 한 번 점검해보세요.
    4. **출력 부분**:
    출력은 잘 작성되었지만, 문제에서 요구하는 출력 형식에 맞는지 한 번 더 확인하세요. 예를 들어, 줄바꿈이나 형식이 맞는지 점검하는 것이 중요합니다.
    5. **로직 검토**:
    전체적으로 로직은 올바르게 진행되고 있지만, 체스판에서 하얀 칸에 대해 정확히 조건을 설정해야 하므로, 이를 명확하게 이해하고 구현하는 것이 중요합니다. 현재 코드에서 `i % 2 == 1 && j % 2 == 1`이 하얀 칸을 표현하는지 다시 한 번 고민해보세요.
    
    학생이 자신이 놓친 부분을 찾고, 논리적으로 문제를 해결할 수 있도록 힌트를 드렸습니다. 조금 더 고민해보면서 코드를 개선해보세요!
    
- 손도 못댄 케이스
    - instruction
        
        ```python
        instruction = """학생의 코드 : 
                #include <stdio.h>
        
        void main()
        {
        	char board[8][8];
        
        	for (int i = 0; i < 8; i++) {
        		for (int j = 0; j < 8; j++) {
        			scanf_s("%c", board[i][j]);
        		}
        	}
        
        }"""
        ```
        
    
    - 답변
        
        ### 피드백
        
        코드는 체스판의 상태를 입력받는 부분만을 다루고 있어, 하얀 칸 위에 말이 있는지 확인하는 로직이 완전히 빠져 있습니다. 
        
        이를 해결하기 위해 하얀 칸과 검정 칸을 구분하고, 각 칸에 말이 있는지 확인하는 로직을 추가해야 합니다. 
        
        또한, 말이 있는 칸을 세는 변수를 사용하여 최종적으로 하얀 칸 위에 말이 몇 개 있는지를 출력하는 부분을 구현해야 합니다. 다음은 이러한 개선된 코드를 작성하는 방향으로 힌트를 제공합니다.
        
        1. 체스판의 상태를 저장하는 배열과 하얀 칸 위에 말이 있는 개수를 저장하는 변수를 선언합니다.
        2. 체스판 상태를 입력받아 배열에 저장합니다.
        3. 각 하얀 칸을 찾아서 'F'가 있는지 확인하고, 있으면 해당 변수를 증가시킵니다.
        4. 최종적으로 변수를 출력하여 하얀 칸 위에 말이 몇 개 있는지 출력합니다.
        
        위의 코드는 체스판 상태를 입력받고, 하얀 칸 위에 말이 있는지 확인하는 부분만을다루고 있습니다. 하얀 칸을 구분하고, 하얀 칸 위에 말이 있는지 확인하는 로직을 추가하여 문제를 해결할 수 있습니다. 이를 통해 하얀 칸 위에 말이 있는 개수를 계산하고 출력하는 로직을 완성할 수 있습니다.
        
    
    - LLM 총 소요시간
        - 50초
    
    - 토큰 사용량
        - 613 토큰
    
- 손은 댔으나 수정이 필요한 케이스
    - instruction
    
    ```python
    instruction = """학생의 코드 : 
    #include <stdio.h>
    
    void main()
    {
    	char board[8][8];
    
        int count = 0;
    
    	for (int i = 0; i < 8; i++) {
    		for (int j = 0; j < 8; j++) {
    			scanf_s("%c", &board[i][j]);
    		}
    	}
    
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                if (i % 2 == 1 && j % 2 == 1 && board[i][j] == 'F') {
                    count++;
                }
            }
        }
    
        printf("%d\n", count);
    
        return 0;
    
    }"""
    ```
    
    - 답변
    
    피드백을 주어보겠습니다.
    
    1. `void main()` 대신 `int main()`를 사용해야 합니다. `void main()`은 C 표준에서 정의하지 않은 함수입니다. `int main()`을 사용하는 것이 좋습니다.
    2. `char board[8][8];`를 초기화하지 않았습니다. `scanf_s` 함수는 입력을 받을 변수를 초기화하지 않으면 undefined behavior를 일으킬 수 있습니다. 따라서, 모든 칸을 '.'으로 초기화합니다.
    3. `char board[8][8];`의 초기화 방법이 잘못되었습니다. `board[8][8]`는 2차원 배열이므로, 초기화 방법이 다릅니다. `board[8][8] = {{ '.' }};`와 같이 초기화해야 합니다.
    4. `scanf_s` 함수를 사용할 때는 매개변수에 충분한 크기의 버퍼를 사용해야 합니다. 여기서는 각 칸을 읽을 때 `scanf_s`의 두 번째 매개변수를 `&board[i][j]` 대신 `&board[i][j] + 1`로 수정하여 충분한 공간을 확보할 수 있습니다.
    5. `count` 변수를 초기화하지 않았습니다. `int count = 0;`을 통해 초기화해야 합니다.
    6. `return 0;`은 `main` 함수의 마지막에 있어야 합니다.
    7. 마지막 `printf` 함수의 `(`와 `)`가 맞게 작성되어야 합니다.
    8. `i % 2 == 1 && j % 2 == 1` 조건이 잘못되어 있습니다. 체스판은 검정 칸과 하얀 칸이 번갈아가며 색칠되어 있으므로, `i % 2 == 0 && j % 2 == 0`이 올바른 조건입니다.
    9. `board[i][j] == 'F'` 조건이 올바르게 작동하지 않았습니다. 각 칸의 상태를 저장하는 것이 아니라, 초기화된 상태에서만 확인해야 합니다.
    
    위의 문제점들을 수정하여 코드를 다시 작성하면 됩니다. 추가로, 주어진 조건에 따라 코드를 수정하는 방법을 생각해 보세요.
    
    - LLM 총 소요시간
        - 73초
    
    - 토큰 사용량
        - 866 토큰

참고하면 좋은 사이트(유로임)

[Clean Code definition | SonarQube Server Documentation](https://docs.sonarsource.com/sonarqube-server/latest/core-concepts/clean-code/definition/)

연호, 경은

[LLM 출력 방식을 일괄 처리→ 스트리밍 방식으로 변경(실패)](https://www.notion.so/LLM-1b44378af66f80729ecdfc0d0c51a7a9?pvs=21)