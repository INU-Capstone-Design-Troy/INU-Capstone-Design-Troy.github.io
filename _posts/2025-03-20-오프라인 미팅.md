---
layout: post
title:  "03-20 오프라인 미팅"
date:   2025-03-20 13:00:00 +0900
---

- **일시**: 2025년 3월 20일 (목) 13:00 ~ 23:00
- **장소**: 오프라인 7호관 302
- **참석자**: 장경은(온라인), 손승민, 이태우, 최연호
- **회의 주제**: 시나리오 제작 및 평가표 수정

---

피드백 내용 정리

1. 시나리오를 앞으로 빼라
2. 많은 경우가 있겠지만 그 경우에 어떻게 대응할 것인지 당연히 생각해놔야 한다
3. 타겟이 학생이라면 시나리오에서 “학생”을 위한 내용들이 주로, 앞으로 나와야 한다

- 가능한 시나리오
    - 배열
        - 배열 선언 개념 부족
            
            **피드백 방향:**
            
            - 배열의 선언과 초기화 방법을 명확히 설명합니다.
            - 배열의 크기와 자료형을 명확히 이해하지 못했을 가능성이 큽니다.
            - 배열의 유효 범위와 메모리 할당에 대한 기본 개념도 함께 점검합니다.
            
            **구체적 피드백:**
            
            - "배열을 선언할 때는 자료형과 크기를 명시해야 합니다. 예를 들어, `int arr[5];`와 같이 선언합니다. 배열의 크기는 상수로 지정해야 하며, 선언 후에는 크기를 변경할 수 없습니다."
            - "초기화를 할 때는 중괄호 `{}` 안에 값을 넣어야 하며, 미초기화된 배열 요소에는 쓰레기 값이 들어갈 수 있으므로 초기화를 권장합니다."
            - "배열은 연속된 메모리 공간에 저장되므로, 배열의 크기를 초과하여 접근하면 메모리 접근 오류가 발생합니다."
        - 주소 전달 개념 부족
            
            **피드백 방향:**
            
            - 배열 이름이 곧 주소라는 개념을 강조합니다.
            - 배열을 함수로 전달할 때 포인터를 사용해야 함을 설명합니다.
            
            **구체적 피드백:**
            
            - "배열 이름은 배열의 첫 번째 요소의 주소를 의미합니다. 예를 들어, `arr`는 `&arr[0]`과 같습니다."
            - "배열을 함수로 전달할 때는 배열 이름을 인수로 사용하여 주소를 넘겨야 합니다. 예: `func(arr);`"
            - "배열을 함수 인자로 받을 때는 포인터로 선언하여 메모리 주소를 받도록 해야 합니다. 예: `void func(int *arr)`"
        - 미초기화 변수 접근
            
            **피드백 방향:**
            
            - 배열 선언 후 초기화를 반드시 수행하도록 강조합니다.
            - 미초기화로 인한 오류를 직접 시연하여 위험성을 체감하도록 합니다.
            
            **구체적 피드백:**
            
            - "배열 선언 후 초기화하지 않으면 쓰레기 값이 들어 있습니다. 명시적으로 `int arr[5] = {0};`와 같이 초기화합시다."
            - "특히 지역 변수로 선언된 배열은 예측할 수 없는 값으로 채워져 있으므로 항상 초기화하는 습관을 들이세요."
    - 반복문
        - 조건식 개념 부족
            
            **피드백 방향:**
            
            - 조건식의 평가 방식과 불리언 연산의 기본을 점검합니다.
            - 조건식에서 발생할 수 있는 논리적 오류를 직접 예제로 설명합니다.
            
            **구체적 피드백:**
            
            - "조건식은 참(true)과 거짓(false)을 반환합니다. 조건이 참일 때만 반복문이 실행된다는 점을 명확히 이해해야 합니다."
            - "예: `while (i < 10)`과 같이 범위를 명확히 지정하고, 경계 조건을 신중하게 설정하세요."
        - 변수 범위 및 초기화 실수
            
            **피드백 방향:**
            
            - 반복문 내부 변수와 외부 변수의 범위 차이를 강조합니다.
            - 초기화 누락으로 인한 무한 루프와 잘못된 값 문제를 예로 듭니다.
            
            **구체적 피드백:**
            
            - "반복문 내부에서 사용하는 변수를 외부에서 선언하면 반복 간에 값이 유지됩니다. 이를 이용해 누적합 등을 계산할 수 있습니다."
            - "초기화되지 않은 변수로 인해 예기치 않은 결과가 발생할 수 있으므로, 항상 초기화 상태를 점검하세요."
        - 반복문 선택 편향
            
            **피드백 방향:**
            
            - `for`, `while`, `do-while` 반복문 각각의 용도를 명확히 구분합니다.
            - 상황에 맞는 반복문 선택 방법을 제안합니다.
            
            **구체적 피드백:**
            
            - "데이터의 개수를 명확히 알 때는 `for`문을, 조건에 따라 반복할 때는 `while`문을 사용하세요."
            - 
        - 비효율적 코드 작성
            
            **피드백 방향:**
            
            - 중첩 반복문과 복잡도 증가의 문제를 언급합니다.
            - 불필요한 반복을 최소화할 수 있는 개선점을 제시합니다.
            
            **구체적 피드백:**
            
            - "불필요한 중첩을 줄이고 반복 횟수를 줄이는 최적화가 필요합니다. 알고리즘의 시간 복잡도에도 신경 써야 합니다."
            - "예를 들어, 이중 반복문 대신 특정 자료 구조를 사용해 효율성을 높일 수 있습니다."
    - 조건문
        - 논리 연산자 개념 부족
            
            **피드백 방향:**
            
            - 논리 연산자의 우선순위와 역할을 명확히 설명합니다.
            - `&&`, `||`, `!` 등 연산자의 의미와 사용 방법을 반복 학습합니다.
            
            **구체적 피드백:**
            
            - "논리 연산자 `&&`는 모두 참이어야 하고, `||`는 하나라도 참이면 됩니다. 우선순위를 헷갈리지 않도록 괄호를 적극 활용하세요."
        - 조건 설정 오류
            
            **피드백 방향:**
            
            - 경계 값이나 조건 설정의 실수를 점검합니다.
            - 조건이 항상 참 또는 거짓이 되는 경우를 강조합니다.
            
            **구체적 피드백:**
            
            - "조건이 항상 참이면 무한 루프가 발생하고, 항상 거짓이면 실행되지 않습니다. 조건을 꼼꼼히 검토하세요."
            - "특히 경계 조건이 정확하지 않으면 예상치 못한 오류가 발생할 수 있습니다."
        - 연산자 혼동
            
            **피드백 방향:**
            
            - 대입 연산자(`=`)와 비교 연산자(`==`)의 차이를 명확히 이해하도록 유도합니다.
            - 조건문에서 `=`를 사용하여 논리 오류가 발생하는 경우를 구체적으로 설명합니다.
            
            **구체적 피드백:**
            
            - "`if (a = 5)`와 같이 대입 연산자를 사용하면, 변수 `a`에 5를 할당하고 항상 참으로 평가됩니다. 비교를 위해서는 `if (a == 5)`처럼 `==`를 사용해야 합니다."
            - "컴파일러 경고를 무시하지 말고, 이러한 실수를 줄이기 위해 조건문에 상수를 먼저 배치하는 것도 좋은 습관입니다. 예: `if (5 == a)`"
            - "연산자 우선순위를 고려하여 괄호를 명확히 사용하면 가독성과 안전성이 높아집니다."
    - 포인터
        - 포인터 개념 부족
            
            **피드백 방향:**
            
            - 포인터의 기본 개념부터 차근차근 이해하도록 설명합니다.
            - 메모리 주소와 값 간의 관계를 그림이나 예시로 명확히 합니다.
            
            **구체적 피드백:**
            
            - "포인터는 변수의 메모리 주소를 저장하는 변수입니다. `int *ptr`은 `ptr`이 정수형 주소를 저장함을 의미합니다."
            - "포인터를 통해 메모리에 직접 접근할 수 있으므로 잘못 사용하면 프로그램이 비정상 종료될 수 있습니다."
            - "값을 참조할 때는 `ptr`로 접근하고, 주소를 담을 때는 `&`를 사용합니다. 두 연산자의 역할을 명확히 구분하세요."
        - 연산자 혼동
            
            **피드백 방향:**
            
            - 와 `&` 연산자의 역할을 명확히 구분하고 반복 학습합니다.
            - 포인터 연산자 혼동으로 인한 오류 사례를 제시합니다.
            
            **구체적 피드백:**
            
            - "는 포인터 변수가 가리키는 메모리 주소의 값을 가져오는 데 사용되고, `&`는 변수의 메모리 주소를 얻는 데 사용됩니다."
            - "예:
            
            위 코드에서 `p`는 `a`의 값을 가리킵니다."
                
                ```c
                
                int a = 10;
                int *p = &a;
                printf("%d", *p); // 출력: 10
                
                ```
                
            - "연산자가 혼동되면 포인터가 올바르게 사용되지 않으므로, 개념을 확실히 이해하고 문제를 풀어보세요."
        - Call by Reference 개념 부족
            
            **피드백 방향:**
            
            - 함수 호출 시 값 전달과 주소 전달의 차이를 명확히 이해시키는 데 중점을 둡니다.
            - 주소를 전달하여 함수 내에서 값을 변경할 수 있음을 강조합니다.
            
            **구체적 피드백:**
            
            - "Call by Value는 값 자체를 복사하여 전달하기 때문에 함수 내부에서 값을 변경해도 원본이 변하지 않습니다."
            - "Call by Reference는 변수의 주소를 전달하여 함수 내부에서 값을 변경할 수 있습니다."
            - "예:
                
                ```c
                void swap(int *a, int *b) {
                    int temp = *a;
                    *a = *b;
                    *b = temp;
                }
                
                ```
                
                위 코드에서 포인터를 사용하여 두 변수를 교환할 수 있습니다."
                
    - 알고리즘(문제 해결 전략)
        - 알고리즘적인 사고방식을 익히기 어려워하는 경우
            
            **피드백 방향:**
            
            - 문제를 해결하는 절차를 단계별로 나눠 생각하도록 유도합니다.
            - 간단한 문제부터 시작하여 점진적으로 복잡도를 늘려갑니다.
            
            **구체적 피드백:**
            
            - "문제를 해결할 때는 먼저 입출력을 명확히 정의하고, 그다음 해결 방법을 단계별로 구상하세요."
            - "예를 들어, 정렬 알고리즘을 구현할 때는 다음과 같은 순서로 진행할 수 있습니다:
                1. 배열 입력 받기
                2. 정렬 알고리즘 선택하기
                3. 정렬 구현하기
                4. 정렬된 배열 출력하기"
        - 반복문과 배열 등 여러 개념을 동시에 적용해야 하는 문제를 어려워하는 경우
            
            **피드백 방향:**
            
            - 반복문, 배열, 포인터 등을 함께 사용하는 문제를 단계별로 접근하도록 연습합니다.
            - 하나의 개념에 익숙해지면 점진적으로 복합 문제를 도전하도록 유도합니다.
            
            **구체적 피드백:**
            
            - "단순 반복문 문제를 먼저 해결하고, 이후 배열을 추가하여 문제를 확장해 봅시다."
            - "예: 배열 요소의 합을 구할 때, 먼저 반복문으로 값을 더하는 연습을 하고, 이후 포인터를 활용하여 접근하는 방식으로 확장할 수 있습니다."
        - 자신의 논리를 놓치거나, 작성 중이던 코드를 이해하지 못하는 경우
            
            **피드백 방향:**
            
            - 작성한 코드의 흐름을 스스로 설명하게 유도하여 논리 오류를 직접 파악하도록 합니다.
            - 코드 주석을 작성하는 습관을 길러 논리를 명확히 전달할 수 있도록 합니다.
            
            **구체적 피드백:**
            
            - "코드를 작성한 후, 한 줄씩 설명해보세요. 논리적으로 맞지 않는 부분이 있다면 그 부분이 오류일 가능성이 큽니다."
            - "코드의 흐름을 정리한 후 디버깅 도구를 활용하여 변수 값이 어떻게 변하는지 추적해보세요."
            - "특히, 복잡한 알고리즘에서는 중간중간 주석을 달아 논리의 흐름을 명확히 표시하는 것이 중요합니다."
    - 문제 접근 자체가 어려운 상황
        - 문제를 손도 못 대는 경우
            
            **기능 제안:**
            
            - **문제 해설 보기 기능:** 기본 개념과 해결 방법을 단계별로 제시하는 해설을 제공합니다.
            - **힌트 단계별 제공 기능:** 문제 풀이 접근법을 단계별로 제안하며, 필요할 때마다 힌트를 하나씩 볼 수 있습니다.
        - 문제를 이해하지 못해서 시작하지 못하는 경우
            
            **기능 제안:**
            
            - **요약 보기 기능:** 문제 설명을 한 줄 요약으로 제시하여 핵심을 파악할 수 있도록 합니다.
            - **의문점 질문 게시판:** 다른 사용자들과 문제에 대한 이해를 논의할 수 있는 공간을 마련합니다.
            - **시각화 기능:** 문제 상황을 그래프나 그림으로 시각화하여 직관적으로 이해할 수 있도록 돕습니다.
        - 문제의 요구사항을 파악하지 못하는 경우
            
            **기능 제안:**
            
            - **요구사항 체크리스트:** 문제의 주요 요구사항을 체크박스로 정리하여 빠짐없이 확인할 수 있도록 합니다.
            - **출력 형식 자동 검사 기능:** 출력 형식이 요구사항과 일치하는지 자동으로 검사하여 피드백을 줍니다.
        - 문제 접근 방식을 완전히 잘못 잡은 경우
            
            **기능 제안:**
            
            - **접근 방법 제안 기능:** 문제 유형(예: 정렬, 탐색 등)을 분석하여 적절한 알고리즘 힌트를 제공합니다.
            - **유사 문제 추천 기능:** 비슷한 유형의 문제를 추천하여 다른 풀이 방식을 배울 수 있도록 돕습니다.
            - **접근법 비교 도구:** 여러 가지 접근 방식을 시각적으로 비교하여 가장 효율적인 방법을 찾을 수 있게 합니다.
    - 논리 구성과 설계에서 어려움을 겪는 경우
        - 논리는 맞지만 구현을 못 하는 경우
            
            **구현 가이드 제공:** 알고리즘 단계별로 필요한 문법이나 자료구조를 제시하여 논리를 코드로 옮기는 것을 돕습니다.
            
        - 문제를 푸는 과정에서 코드가 꼬이는 경우
            
            
        - 큰 문제를 작은 단위로 쪼개는 데 어려움을 느끼는 경우
            
            **기능 제안:**
            
            - **문제 분해 가이드:** 큰 문제를 단계별로 나누는 방법을 제안하고 각 단계의 목표를 명시합니다.
            - **단계별 테스트 기능:** 각 함수별로 독립적인 테스트를 진행할 수 있는 환경을 제공합니다.
        - 코드 작성 중간에 다른 방식으로 변경하다 꼬이는 경우
            
            
    - 문제를 풀었다고 생각하지만 제출하면 틀린 경우
        - 반례를 생각하지 못한 경우
            
            

- 기능 세부 정의
    
    **[1] 기본개념 하이퍼링크 기능**
    
    - 작성된 피드백에서 개념, 문법적인 오류에 대한 피드백이 있다면 해당 내용과 가장 유사한 **개념서 사이트**로 이동할 수 있는 기능을 제공합니다.
        - C 언어 개념서 링크 제공
            - C 언어의 주요 개념(변수, 포인터, 구조체, 배열, 문자열)을 학습할 수 있는 개념서 링크를 제공합니다.
    - 평가 방법
        - 문법 오류를 포함한 샘플 코드 20개를 제작하고 라벨링
        - 라벨링된 개념과 해당 기능을 사용하여 연결된 개념이 일치하는 성공률이 80% 이상 성공
    
    **[2] 마크업 기능**
    
    - 문제 속 개념을 토글 형태로 설명하고 중요한 키워드에 강조 표시
        - 문제 풀이 중 관련 개념을 확인할 수 있도록 키워드를 찾아 강조합니다.
        - 문제 설명 내에 핵심 키워드에 밑줄 표시 및 볼드체 처리를 해줍니다.
    - 평가방법
        - 핵심 개념을 라벨링한 알고리즘성 문제 20개 수집하여 데이터셋 구축 후, 마크업 기능이 각 문제 속 핵심 개념을 알맞게 골라 힌트를 제공한 성공률이 80% 이상
    
    **[3] 단계별 피드백 기능**
    
    - 제출된 코드의 구현율을 기반으로 다른 정도의 피드백을 제공합니다.
        - 30% 미만 구현율의 [1단계]
            - 핵심 개념을 전체적으로 제공하면서, 기초적인 문법에 대한 설명도 제공합니다.
        - 31%~80% 구현율의 [2단계]
        - 부족한 개념을 일부분 제공하면서, 스스로 해결을 위해 질문의 형태로 피드백을 제공합니다.
        - 81% 이상 구현율의 [3단계]
        - 코드 오류의 원인을 스스로 해결할 수 있도록 질문 형태로 피드백을 제공합니다.
    - 입력파트, 문제풀이파트(1~N), 출력파트로 단계를 나누어 피드백을 제공합니다.
        - 입력파트
            - 주로 초심자 학생들을 위한 파트로, 변수명부터 입력받는 방법등에 대해 자세한 피드백을 제공합니다.
        - 문제풀이파트(1~N)
        - 문제풀이를 단계적으로 나누어 학생이 코드의 흐름을 명확히 파악할 수 있게 피드백을 제공합니다.
        - 출력파트
            - 문제에서 요구하는 공백 처리, 줄바꿈에 대한 피드백을 제공합니다.
    - 평가방법
        - 오류 원인이 라벨링되어있는 샘플 코드 데이터셋 20개를 제작하여 단계적 피드백 기능 사용 시, 라벨링된 오류에 피드백이 주어지는지 확인.
            - Macro-average Recall > 80%
    
    **[4] 유사 문제 추천 기능**
    
    - 학생이 제출해서 푼 문제에 대해 유사문제를 제공합니다.
    - 학생은 문제를 풀고 정답을 확인합니다.
    - 학생이 제출한 코드가 정답일 경우에만 피드백 버튼 대신 유사문제 추천버튼을 눌러 새로운 문제로 이동할 수 있습니다.
    - 방금 해결한 문제와 구조가 유사한 문제로 이동합니다.
    - 평가방법
        - 자체 제작된 C언어 기초 문제 데이터셋 50개를 대상으로 선정된 유사문제가, 기존 OJ 문제와의 카테고리가 일치하는지 여부를 판단함. 성공률 90% 이상