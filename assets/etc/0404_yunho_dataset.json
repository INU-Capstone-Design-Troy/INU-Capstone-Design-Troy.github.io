[
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint A[50][50];\nint B[50][50];\n\nvoid flip(int x, int y) {\n    int i, j;\n    for (i = x; i < x + 3; i++) {\n        for (j = y; j < y + 3; j++) {\n            A[i][j] = 1 - A[i][j];\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    int i, j;\n    int count = 0;\n\n    scanf(\"%d %d\", &N, &M);\n\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < M; j++) {\n            scanf(\"%1d\", &A[i][j]);\n        }\n    }\n\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < M; j++) {\n            scanf(\"%1d\", &B[i][j]);\n        }\n    }\n\n    for (i = 0; i <= N - 3; i++) {\n        for (j = 0; j <= M - 3; j++) {\n            if (A[i][j] != B[i][j]) {\n                flip(i, j);\n                count++;\n            }\n        }\n    }\n\n    for (i = 0; i < N; i++) {\n        for (j = 0; j < M; j++) {\n            if (A[i][j] != B[i][j]) {\n                printf(\"-1\n\");\n                return 0;\n            }\n        }\n    }\n\n    printf(\"%d\n\", count);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] void 반환형 flip 함수를 정의하세요. (매개변수: int x, int y)\n2. int형 변수 i와 j를 선언하세요.\n3. [rep_start(1)] i를 선언해 x부터 x+2까지 반복하는 for 루프를 작성하세요.\n4. [rep_start(2)] j를 선언해 y부터 y+2까지 반복하는 for 루프를 작성하세요.\n5. A[i][j]의 값을 1에서 0으로 또는 0에서 1로 반전하세요.\n6. [rep_end(2)]\n7. [rep_end(1)]\n8. [func_def_end(1)]\n9. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n10. 정수형 변수 N과 M을 선언하세요.\n11. 정수형 변수 i와 j를 선언하세요.\n12. 변환 횟수를 저장할 int형 변수 count를 0으로 초기화하세요.\n13. N과 M에 입력을 받으세요.\n14. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n15. [rep_start(2)] j를 선언해 0부터 M-1까지 반복하는 for 루프를 작성하세요.\n16. 1자리 숫자를 읽어 A[i][j]에 저장하세요.\n17. [rep_end(2)]\n18. [rep_end(1)]\n19. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n20. [rep_start(2)] j를 선언해 0부터 M-1까지 반복하는 for 루프를 작성하세요.\n21. 1자리 숫자를 읽어 B[i][j]에 저장하세요.\n22. [rep_end(2)]\n23. [rep_end(1)]\n24. [rep_start(1)] i를 선언해 0부터 N-3까지 반복하는 for 루프를 작성하세요.\n25. [rep_start(2)] j를 선언해 0부터 M-3까지 반복하는 for 루프를 작성하세요.\n26. A[i][j]와 B[i][j]가 다른 경우를 확인하세요.\n27. A[i][j]와 B[i][j]가 다르면 flip 함수를 호출하세요.\n28. 변환 횟수를 1 증가시키세요.\n29. [rep_end(2)]\n30. [rep_end(1)]\n31. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n32. [rep_start(2)] j를 선언해 0부터 M-1까지 반복하는 for 루프를 작성하세요.\n33. A[i][j]와 B[i][j]가 다른 경우를 확인하세요.\n34. A[i][j]와 B[i][j]가 다르면 \"-1\"을 출력하고 프로그램을 종료하세요.\n35. [rep_end(2)]\n36. [rep_end(1)]\n37. count를 출력하세요.\n38. return 0;으로 프로그램을 종료하세요.\n39. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint count8(int n) {\n    int count = 0;\n    while (n > 0) {\n        if (n % 10 == 8) {\n            count++;\n        }\n        n /= 10;\n    }\n    return count;\n}\n\nint main() {\n    int L, R;\n    int i, min = 100, c;\n\n    scanf(\"%d %d\", &L, &R);\n\n    for (i = L; i <= R; i++) {\n        c = count8(i);\n        if (c < min) {\n            min = c;\n            if (min == 0) break;\n        }\n    }\n\n    printf(\"%d\n\", min);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 count8을 정의하세요. (매개변수: int n)\n2. int형 변수 count를 0으로 초기화하여 8의 개수를 세는 변수를 선언하세요.\n3. [rep_start(1)] n이 0보다 클 동안 반복하는 while 루프를 시작하세요.\n4. [cond_start(2)] n의 마지막 자리가 8인지 확인하는 조건문을 작성하세요.\n5. n의 마지막 자리가 8이라면 count를 1 증가시키세요.\n6. [cond_end(2)]\n7. n의 마지막 자리를 제거하기 위해 n을 10으로 나누세요.\n8. [rep_end(1)]\n9. count 변수에 저장된 8의 개수를 반환하세요.\n10. [func_def_end(1)]\n11. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n12. 정수형 변수 L과 R을 선언하세요.\n13. 정수형 변수 i, min을 100으로 초기화하고, c를 선언하세요.\n14. L과 R에 입력을 받으세요.\n15. [rep_start(1)] i를 L부터 R까지 반복하는 for 루프를 작성하세요.\n16. count8 함수를 호출하여 i에 있는 8의 개수를 c에 저장하세요.\n17. [cond_start(2)] c가 min보다 작은지 확인하는 조건문을 작성하세요.\n18. c가 min보다 작다면, min을 c로 업데이트하세요.\n19. [cond_start(3)] min이 0인지 확인하는 조건문을 작성하세요.\n20. min이 0이라면 반복문을 종료하세요.\n21. [cond_end(3)]\n22. [cond_end(2)]\n23. [rep_end(1)]\n24. min의 값을 출력하세요.\n25. return 0으로 프로그램을 종료하세요.\n26. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint is_prime(int n) {\n    if (n < 2) return 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return 0;\n    }\n    return 1;\n}\n\nint count_factors(int n) {\n    int count = 0;\n    int d = 2;\n    while (n > 1) {\n        if (n % d == 0) {\n            n /= d;\n            count++;\n        } else {\n            d++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    int A, B;\n    int count = 0;\n\n    scanf(\"%d %d\", &A, &B);\n\n    for (int i = A; i <= B; i++) {\n        int f = count_factors(i);\n        if (is_prime(f)) {\n            count++;\n        }\n    }\n\n    printf(\"%d\n\", count);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 is_prime을 정의하세요. (매개변수: int n)\n2. [cond_start(1)] n이 2보다 작은지 확인하는 조건문을 작성하세요.\n3. n이 2보다 작으면 0을 반환하세요.\n4. [cond_end(1)]\n5. [rep_start(1)] i를 선언해 2부터 n의 제곱근까지 반복하는 for 루프를 작성하세요.\n6. [cond_start(2)] n이 i로 나누어지는지 확인하는 조건문을 작성하세요.\n7. n이 i로 나누어지면 0을 반환하세요.\n8. [cond_end(2)]\n9. [rep_end(1)]\n10. 위의 과정을 통과한 n은 소수이므로 1을 반환하세요.\n11. [func_def_end(1)]\n12. [func_def_start(1)] int 반환형 함수 count_factors을 정의하세요. (매개변수: int n)\n13. 소인수의 개수를 세기 위한 int형 변수 count를 0으로 초기화하세요.\n14. 소인수를 찾기 위한 int형 변수 d를 2로 초기화하세요.\n15. [rep_start(1)] n이 1보다 큰 동안 반복하는 while 루프를 작성하세요.\n16. [cond_start(2)] n이 d로 나누어지는지 확인하는 조건문을 작성하세요.\n17. n이 d로 나누어지면 n을 d로 나누고 count를 1 증가시키세요.\n18. [cond_end(2)]\n19. d를 1 증가시키세요.\n20. [rep_end(1)]\n21. 소인수의 개수를 반환하세요.\n22. [func_def_end(1)]\n23. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n24. 정수형 변수 A와 B를 선언하세요.\n25. 소인수의 개수를 세기 위한 int형 변수 count를 0으로 초기화하세요.\n26. A와 B를 입력받으세요.\n27. [rep_start(1)] i를 선언해 A부터 B까지 반복하는 for 루프를 작성하세요.\n28. i에 대한 소인수의 개수를 count_factors 함수로 구한 후, 결과를 int형 변수 f에 저장하세요.\n29. [cond_start(2)] f가 소수인지 is_prime 함수를 이용하여 확인하는 조건문을 작성하세요.\n30. f가 소수라면 count를 1 증가시키세요.\n31. [cond_end(2)]\n32. [rep_end(1)]\n33. count를 출력하세요.\n34. return 0;으로 프로그램을 종료하세요.\n35. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint cost[1000][3];\nint dp[1000][3];\n\nint min(int a, int b) {\n    if (a < b) {\n        return a;\n    }\n    return b;\n}\n\nint main() {\n    int N;\n    int i;\n\n    scanf(\"%d\", &N);\n\n    for (i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &cost[i][0], &cost[i][1], &cost[i][2]);\n    }\n\n    dp[0][0] = cost[0][0];\n    dp[0][1] = cost[0][1];\n    dp[0][2] = cost[0][2];\n\n    for (i = 1; i < N; i++) {\n        dp[i][0] = cost[i][0] + min(dp[i - 1][1], dp[i - 1][2]);\n        dp[i][1] = cost[i][1] + min(dp[i - 1][0], dp[i - 1][2]);\n        dp[i][2] = cost[i][2] + min(dp[i - 1][0], dp[i - 1][1]);\n    }\n\n    int result = dp[N - 1][0];\n    if (dp[N - 1][1] < result) {\n        result = dp[N - 1][1];\n    }\n    if (dp[N - 1][2] < result) {\n        result = dp[N - 1][2];\n    }\n\n    printf(\"%d\n\", result);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 min을 정의하세요. (매개변수: int a, int b)\n2. [cond_start(1)] a가 b보다 작은지를 확인하는 조건문을 작성하세요.\n3. a가 b보다 작으면 a를 반환하세요.\n4. [cond_end(1)]\n5. b를 반환하세요.\n6. [func_def_end(1)]\n7. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n8. 정수형 변수 N을 선언하세요.\n9. 정수형 변수 i를 선언하세요.\n10. N의 값을 입력받으세요.\n11. [rep_start(1)] i를 0부터 N-1까지 반복하는 for 루프를 시작하세요.\n12. 세 개의 정수형 값을 cost[i][0], cost[i][1], cost[i][2]에 입력받으세요.\n13. [rep_end(1)]\n14. dp 배열의 첫 번째 행에 cost 배열의 첫 번째 행의 값을 할당하세요.\n15. [rep_start(1)] i를 1부터 N-1까지 반복하는 for 루프를 시작하세요.\n16. dp[i][0]에 cost[i][0]과 dp[i - 1][1], dp[i - 1][2]의 최소값을 더한 값을 할당하세요.\n17. dp[i][1]에 cost[i][1]과 dp[i - 1][0], dp[i - 1][2]의 최소값을 더한 값을 할당하세요.\n18. dp[i][2]에 cost[i][2]과 dp[i - 1][0], dp[i - 1][1]의 최소값을 더한 값을 할당하세요.\n19. [rep_end(1)]\n20. int형 변수 result를 선언하고, dp[N - 1][0]으로 초기화하세요.\n21. [cond_start(1)] dp[N - 1][1]이 result보다 작은지를 확인하는 조건문을 작성하세요.\n22. 조건이 참이라면 result에 dp[N - 1][1]을 할당하세요.\n23. [cond_end(1)]\n24. [cond_start(1)] dp[N - 1][2]가 result보다 작은지를 확인하는 조건문을 작성하세요.\n25. 조건이 참이라면 result에 dp[N - 1][2]를 할당하세요.\n26. [cond_end(1)]\n27. result의 값을 출력하세요.\n28. return 0;으로 프로그램을 종료하세요.\n29. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nchar used[26];\n\nint str_len(char *s) {\n    int len = 0;\n    while (s[len] != '\u0000') {\n        len++;\n    }\n    return len;\n}\n\nint to_lower(int c) {\n    if (c >= 'A' && c <= 'Z') {\n        return c - 'A' + 'a';\n    }\n    return c;\n}\n\nint is_space(int c) {\n    if (c == ' ') {\n        return 1;\n    }\n    return 0;\n}\n\nvoid mark_used(int c) {\n    int idx = to_lower(c) - 'a';\n    if (idx >= 0 && idx < 26) {\n        used[idx] = 1;\n    }\n}\n\nint is_used(int c) {\n    int idx = to_lower(c) - 'a';\n    if (idx >= 0 && idx < 26) {\n        return used[idx];\n    }\n    return 1;\n}\n\nint main() {\n    int N;\n    char line[101];\n    int i, j;\n\n    scanf(\"%d\", &N);\n    getchar();\n\n    for (i = 0; i < N; i++) {\n        int first_letter_done = 0;\n        int pos = 0;\n        int len;\n        char result[201];\n        int result_pos = 0;\n\n        for (j = 0; j < 101; j++) {\n            line[j] = '\u0000';\n        }\n\n        fgets(line, 101, stdin);\n        len = str_len(line);\n        if (line[len - 1] == '\n') {\n            line[len - 1] = '\u0000';\n            len--;\n        }\n\n        while (line[pos] != '\u0000') {\n            if ((pos == 0 || is_space(line[pos - 1])) && is_used(line[pos]) == 0 && first_letter_done == 0) {\n                mark_used(line[pos]);\n                result[result_pos++] = '[';\n                result[result_pos++] = line[pos];\n                result[result_pos++] = ']';\n                first_letter_done = 1;\n                pos++;\n            } else {\n                result[result_pos++] = line[pos++];\n            }\n        }\n\n        if (first_letter_done == 0) {\n            pos = 0;\n            result_pos = 0;\n            first_letter_done = 0;\n            while (line[pos] != '\u0000') {\n                if (is_used(line[pos]) == 0 && first_letter_done == 0 && line[pos] != ' ') {\n                    mark_used(line[pos]);\n                    result[result_pos++] = '[';\n                    result[result_pos++] = line[pos];\n                    result[result_pos++] = ']';\n                    first_letter_done = 1;\n                } else {\n                    result[result_pos++] = line[pos];\n                }\n                pos++;\n            }\n        }\n\n        result[result_pos] = '\u0000';\n        printf(\"%s\n\", result);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] char 반환형 str_len 함수를 정의하세요. (매개변수: char *s)\n2. int형 변수 len을 0으로 초기화하세요.\n3. [rep_start(1)] s의 문자가 널 문자('\\0')가 아닐 때까지 반복하세요.\n4. len을 1 증가시키세요.\n5. [rep_end(1)]\n6. 문자열 s의 길이를 len으로 반환하세요.\n7. [func_def_end(1)]\n\n8. [func_def_start(1)] int 반환형 to_lower 함수를 정의하세요. (매개변수: int c)\n9. [cond_start(1)] c가 대문자인지 확인하는 조건문을 작성하세요.\n10. c가 대문자라면 소문자로 변환하여 반환하세요.\n11. [cond_end(1)]\n12. c를 그대로 반환하세요.\n13. [func_def_end(1)]\n\n14. [func_def_start(1)] int 반환형 is_space 함수를 정의하세요. (매개변수: int c)\n15. [cond_start(1)] c가 공백인지 확인하는 조건문을 작성하세요.\n16. c가 공백이라면 1을 반환하세요.\n17. [cond_end(1)]\n18. 0을 반환하세요.\n19. [func_def_end(1)]\n\n20. [func_def_start(1)] void 반환형 mark_used 함수를 정의하세요. (매개변수: int c)\n21. int형 변수 idx를 소문자 변환한 c의 인덱스로 설정하세요.\n22. [cond_start(1)] idx가 0 이상 26 미만인지 확인하는 조건문을 작성하세요.\n23. 조건이 참이라면 used 배열의 해당 인덱스를 1로 설정하세요.\n24. [cond_end(1)]\n25. [func_def_end(1)]\n\n26. [func_def_start(1)] int 반환형 is_used 함수를 정의하세요. (매개변수: int c)\n27. int형 변수 idx를 소문자 변환한 c의 인덱스로 설정하세요.\n28. [cond_start(1)] idx가 0 이상 26 미만인지 확인하는 조건문을 작성하세요.\n29. 조건이 참이라면 used[idx]의 값을 반환하세요.\n30. [cond_end(1)]\n31. 1을 반환하세요.\n32. [func_def_end(1)]\n\n33. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n34. 정수형 변수 N을 선언하세요.\n35. char형 배열 line을 101 크기로 선언하세요.\n36. 정수형 변수 i, j를 선언하세요.\n37. N의 값을 입력받으세요.\n38. getchar() 함수를 호출하여 개행 문자를 제거하세요.\n\n39. [rep_start(1)] i를 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n40. int형 변수 first_letter_done을 0으로 초기화하세요.\n41. pos를 0으로 초기화하세요.\n42. int형 변수 len을 선언하세요.\n43. char형 배열 result를 201 크기로 선언하세요.\n44. int형 변수 result_pos를 0으로 초기화하세요.\n\n45. [rep_start(2)] j를 0부터 100까지 반복하며 line을 널 문자로 초기화하세요.\n46. [rep_end(2)]\n\n47. fgets 함수를 사용하여 line에 문자열을 입력받으세요.\n48. len에 str_len 함수를 호출하여 line의 길이를 저장하세요.\n49. [cond_start(1)] line의 마지막 문자가 개행이면 이를 널 문자로 변환하세요.\n50. line의 길이를 1 줄이세요.\n51. [cond_end(1)]\n\n52. [rep_start(1)] pos가 널 문자가 아닐 때까지 반복하세요.\n53. [cond_start(2)] pos가 0이거나 이전 문자가 공백이며, 해당 문자가 사용되지 않았고 첫 글자가 처리되지 않았는지 확인하는 조건문을 작성하세요.\n54. 조건이 참이라면 mark_used를 호출하여 해당 문자를 표시합니다.\n55. result에 대괄호 형태로 해당 문자를 추가하고, first_letter_done을 1로 설정하세요.\n56. pos를 1 증가시키세요.\n57. [cond_end(2)]\n58. [rep_end(1)]\n\n59. [cond_start(1)] first_letter_done이 0인지 확인하는 조건문을 작성하세요.\n60. pos를 0으로 재설정하고 result_pos를 0으로 초기화하세요.\n61. while문에서 line[pos]가 널 문자가 아닐 경우 반복하세요.\n62. [cond_start(2)] 해당 문자가 사용되지 않았고 첫 글자가 처리되지 않았으며 공백이 아닐 경우를 확인하세요.\n63. mark_used 함수를 호출하여 문자를 표시하고, result에 대괄호로 추가하세요.\n64. [cond_end(2)]\n65. pos를 1 증가시키세요.\n66. [rep_end(1)]\n\n67. line의 result_pos에 널 문자를 추가하세요.\n68. result를 출력하세요.\n69. [rep_end(1)]\n\n70. return 0;으로 프로그램을 종료하세요.\n71. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nchar map[100][101];\nint visited[100][100];\nint dx[4] = {1, -1, 0, 0};\nint dy[4] = {0, 0, 1, -1};\nint N, M;\n\nint queue_x[10000];\nint queue_y[10000];\n\nint bfs(int x, int y, char team) {\n    int front = 0;\n    int rear = 0;\n    int count = 1;\n\n    queue_x[rear] = x;\n    queue_y[rear] = y;\n    rear++;\n    visited[y][x] = 1;\n\n    while (front < rear) {\n        int cx = queue_x[front];\n        int cy = queue_y[front];\n        front++;\n\n        int i;\n        for (i = 0; i < 4; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n\n            if ((nx >= 0) && (nx < N) && (ny >= 0) && (ny < M)) {\n                if ((visited[ny][nx] == 0) && (map[ny][nx] == team)) {\n                    queue_x[rear] = nx;\n                    queue_y[rear] = ny;\n                    rear++;\n                    visited[ny][nx] = 1;\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count * count;\n}\n\nint main() {\n    int i, j;\n    int white_power = 0;\n    int blue_power = 0;\n\n    scanf(\"%d %d\", &N, &M);\n\n    for (i = 0; i < M; i++) {\n        scanf(\"%s\", map[i]);\n    }\n\n    for (i = 0; i < M; i++) {\n        for (j = 0; j < N; j++) {\n            if (visited[i][j] == 0) {\n                if (map[i][j] == 'W') {\n                    white_power += bfs(j, i, 'W');\n                }\n\n                else if (map[i][j] == 'B') {\n                    blue_power += bfs(j, i, 'B');\n                }\n            }\n        }\n    }\n\n    printf(\"%d %d\n\", white_power, blue_power);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 BFS 함수를 정의합니다. (매개변수: 두 개의 int x, y 및 char team)\n2. front와 rear를 0으로 초기화하여 큐의 앞과 뒤를 나타내는 변수를 설정합니다.\n3. count를 1로 초기화하여 현재 그룹의 크기를 추적합니다.\n4. 현재 (x, y) 위치를 큐에 추가하고 rear를 증가시킵니다.\n5. (x, y) 위치를 방문한 것으로 표시합니다.\n6. [rep_start(1)] front가 rear보다 작은 동안 반복합니다.\n7. 큐의 앞에서 현재 x와 y 좌표를 가져옵니다.\n8. front를 증가시켜 다음 요소를 가져올 수 있도록 합니다.\n9. [rep_start(2)] 4 방향을 위해 i를 0부터 3까지 반복합니다.\n10. nx와 ny를 계산하여 현재 위치에서 방향으로 이동한 좌표를 구합니다.\n11. [cond_start(3)] nx와 ny가 유효한 범위인지 확인합니다.\n12. [cond_start(4)] 방문하지 않았고, team과 같은지 확인합니다.\n13. 유효한 좌표를 큐에 추가하고 rear를 증가시킵니다.\n14. 해당 좌표를 방문한 것으로 표시합니다.\n15. count를 증가시켜 현재 그룹의 크기를 업데이트합니다.\n16. [cond_end(4)]\n17. [cond_end(3)]\n18. [rep_end(2)]\n19. [rep_end(1)]\n20. 현재 그룹의 크기를 제곱하여 반환합니다.\n21. [func_def_end(1)]\n22. [func_def_start(1)] int 반환형 main 함수를 정의합니다. (매개변수 없음)\n23. i와 j를 선언하여 반복에 사용할 변수로 초기화합니다.\n24. white_power 및 blue_power 변수를 0으로 초기화합니다.\n25. N과 M 값을 입력받습니다.\n26. [rep_start(1)] M만큼 반복하여 각 행에 대한 입력을 읽습니다.\n27. 현재 행을 map 배열에 저장합니다.\n28. [rep_end(1)]\n29. [rep_start(1)] M만큼 반복하여 행에 대해 i를 설정합니다.\n30. [rep_start(2)] N만큼 반복하여 열에 대해 j를 설정합니다.\n31. [cond_start(1)] 해당 위치가 방문되지 않았는지 확인합니다.\n32. [cond_start(2)] 현재 위치의 팀이 'W'인지 확인합니다.\n33. white_power에 bfs 함수를 호출하여 반환된 값의 크기를 더합니다.\n34. [cond_end(2)]\n35. [cond_start(3)] 현재 위치의 팀이 'B'인지 확인합니다.\n36. blue_power에 bfs 함수를 호출하여 반환된 값의 크기를 더합니다.\n37. [cond_end(3)]\n38. [cond_end(1)]\n39. [rep_end(2)]\n40. 화이트 팀과 블루 팀의 힘을 출력합니다.\n41. return 0;으로 프로그램을 종료합니다.\n42. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N;\n    int i;\n    scanf(\"%d\", &N);\n\n    int dp[100001][3];\n    dp[1][0] = 1;\n    dp[1][1] = 1;\n    dp[1][2] = 1;\n\n    for (i = 2; i <= N; i++) {\n        dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % 9901;\n        dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 9901;\n        dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % 9901;\n    }\n\n    int result = (dp[N][0] + dp[N][1] + dp[N][2]) % 9901;\n    printf(\"%d\n\", result);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 N을 선언하세요.  \n3. 정수형 변수 i를 선언하세요.  \n4. N에 대한 입력을 받으세요.  \n5. 이차원 정수형 배열 dp를 선언하고 크기를 100001 x 3으로 설정하세요.  \n6. dp[1][0]에 1을 할당하여 첫 번째 경우의 수를 초기화하세요.  \n7. dp[1][1]에 1을 할당하여 첫 번째 경우의 수를 초기화하세요.  \n8. dp[1][2]에 1을 할당하여 첫 번째 경우의 수를 초기화하세요.  \n9. [rep_start(1)] i를 2부터 N까지 반복하는 for 루프를 작성하세요.  \n10. dp[i][0]에 이전 단계의 경우의 수를 기반으로 값을 계산하여 저장하세요: (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % 9901.  \n11. dp[i][1]에 이전 단계의 경우의 수를 기반으로 값을 계산하여 저장하세요: (dp[i - 1][0] + dp[i - 1][2]) % 9901.  \n12. dp[i][2]에 이전 단계의 경우의 수를 기반으로 값을 계산하여 저장하세요: (dp[i - 1][0] + dp[i - 1][1]) % 9901.  \n13. [rep_end(1)]  \n14. 결과값 result를 dp[N][0], dp[N][1], dp[N][2]의 합으로 설정하고 9901로 나눈 나머지를 저장하세요.  \n15. result를 출력하세요.  \n16. return 0;으로 프로그램을 종료하세요.  \n17. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nchar s[11];\nchar perm[11];\nint used[11];\nint len;\nint count;\n\nint is_lucky() {\n    int i;\n    for (i = 1; i < len; i++) {\n        if (perm[i] == perm[i - 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint same(char *a, char *b) {\n    int i;\n    for (i = 0; i < len; i++) {\n        if (a[i] != b[i]) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid sort(char *arr, int l) {\n    int i, j;\n    char temp;\n    for (i = 0; i < l - 1; i++) {\n        for (j = i + 1; j < l; j++) {\n            if (arr[i] > arr[j]) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}\n\nvoid dfs(int depth) {\n    int i;\n    if (depth == len) {\n        if (is_lucky()) {\n            count++;\n        }\n        return;\n    }\n\n    char last = 0;\n    for (i = 0; i < len; i++) {\n        if ((used[i] == 0) && (s[i] != last)) {\n            used[i] = 1;\n            perm[depth] = s[i];\n            last = s[i];\n            dfs(depth + 1);\n            used[i] = 0;\n        }\n    }\n}\n\nint main() {\n    int i;\n    scanf(\"%s\", s);\n\n    for (i = 0; s[i] != 0; i++) {\n    }\n\n    len = i;\n    sort(s, len);\n    dfs(0);\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] char 배열 s, perm, 사용 여부를 나타내는 배열 used, 전체 문자 길이를 저장할 변수 len, 카운트를 위한 변수 count를 글로벌 변수로 선언합니다.\n2. [func_def_start(1)] int 반환형 함수 is_lucky 정의합니다.\n3. int형 변수 i를 선언합니다.\n4. [rep_start(1)] 반복문을 통해 i를 1부터 len-1까지 증가시키며 반복합니다.\n5. [cond_start(2)] perm 배열의 현재 인덱스와 이전 인덱스의 값이 같은지 비교합니다.\n6. 같은 경우 0을 반환하여 비행운을 나타냅니다.\n7. [cond_end(2)]\n8. [rep_end(1)]\n9. 모든 문자가 다르면 1을 반환하여 행운을 나타냅니다.\n10. [func_def_end(1)]\n11. [func_def_start(1)] int 반환형 함수 same을 정의합니다. (매개변수: char *a, char *b)\n12. int형 변수 i를 선언합니다.\n13. [rep_start(1)] 반복문을 통해 i를 0부터 len-1까지 증가시키며 반복합니다.\n14. [cond_start(2)] a 배열과 b 배열의 현재 인덱스 값을 비교합니다.\n15. 다르다면 0을 반환합니다.\n16. [cond_end(2)]\n17. [rep_end(1)]\n18. a 배열과 b 배열이 같다면 1을 반환합니다.\n19. [func_def_end(1)]\n20. [func_def_start(1)] void 반환형 함수 sort를 정의합니다. (매개변수: char *arr, int l)\n21. int형 변수 i, j와 char형 temp 변수를 선언합니다.\n22. [rep_start(1)] i를 0부터 l-2까지 반복합니다.\n23. [rep_start(2)] j를 i+1부터 l-1까지 반복합니다.\n24. [cond_start(3)] arr 배열의 i번째 값이 j번째 값보다 큰지 비교합니다.\n25. 큰 경우, i번째와 j번째 값의 위치를 바꿉니다.\n26. [cond_end(3)]\n27. [rep_end(2)]\n28. [rep_end(1)]\n29. [func_def_end(1)]\n30. [func_def_start(1)] void 반환형 함수 dfs를 정의합니다. (매개변수: int depth)\n31. int형 변수 i를 선언합니다.\n32. [cond_start(1)] depth가 len과 같은지 확인합니다.\n33. 같다면, is_lucky 함수를 호출하여 행운을 체크합니다.\n34. count를 증가시킵니다.\n35. return으로 함수를 종료합니다.\n36. [cond_end(1)]\n37. char형 last 변수를 0으로 초기화합니다.\n38. [rep_start(1)] i를 0부터 len-1까지 반복합니다.\n39. [cond_start(2)] 사용 여부 배열이 0이고 s[i]가 last와 같지 않은지 확인합니다.\n40. 조건을 만족하면 used[i]를 1로 바꿉니다.\n41. perm의 depth 위치에 s[i] 값을 저장합니다.\n42. last에 s[i] 값을 저장합니다.\n43. dfs(depth + 1) 함수를 호출하여 다음 깊이로 이동합니다.\n44. used[i]를 0으로 되돌립니다.\n45. [cond_end(2)]\n46. [rep_end(1)]\n47. [func_def_end(1)]\n48. [func_def_start(1)] int 반환형 main 함수 정의합니다.\n49. int형 변수 i를 선언합니다.\n50. scanf 함수를 통해 문자열 s에 입력을 받습니다.\n51. [rep_start(1)] s[i]가 0이 아닐 때까지 반복하며 i를 증가시킵니다.\n52. len을 i의 값으로 설정합니다.\n53. sort 함수를 호출하여 s를 정렬합니다.\n54. dfs 함수를 호출하여 깊이 우선 탐색을 시작합니다.\n55. count 값을 출력합니다.\n56. return 0으로 프로그램을 종료합니다.\n57. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\n#define MAX 101\n\nint graph[MAX][MAX];\nint visited[MAX];\nint queue[MAX];\nint front, rear;\nint dist[MAX];\n\nint bfs(int start, int n) {\n    int i;\n    for (i = 1; i <= n; i++) {\n        visited[i] = 0;\n        dist[i] = 0;\n    }\n\n    front = 0;\n    rear = 0;\n    queue[rear++] = start;\n    visited[start] = 1;\n\n    while (front < rear) {\n        int cur = queue[front];\n        front++;\n\n        for (i = 1; i <= n; i++) {\n            if ((graph[cur][i] == 1) && (visited[i] == 0)) {\n                queue[rear++] = i;\n                visited[i] = 1;\n                dist[i] = dist[cur] + 1;\n            }\n        }\n    }\n\n    int sum = 0;\n    for (i = 1; i <= n; i++) {\n        sum = sum + dist[i];\n    }\n\n    return sum;\n}\n\nint main() {\n    int n, m;\n    int i;\n    scanf(\"%d %d\", &n, &m);\n\n    for (i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        graph[a][b] = 1;\n        graph[b][a] = 1;\n    }\n\n    int min = 1000000;\n    int person = 0;\n\n    for (i = 1; i <= n; i++) {\n        int total = bfs(i, n);\n        if (total < min) {\n            min = total;\n            person = i;\n        }\n    }\n\n    printf(\"%d\n\", person);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 bfs 함수를 정의하세요. (매개변수: int start, int n)\n2. 정수형 변수 i를 선언하세요.\n3. [rep_start(1)] n까지의 숫자에 대해 반복하는 for 루프를 작성하세요.\n4. visited 배열의 i번째 인덱스를 0으로 초기화하여 방문하지 않은 것임을 설정하세요.\n5. dist 배열의 i번째 인덱스를 0으로 초기화하여 거리를 0으로 설정하세요.\n6. [rep_end(1)]\n7. front 변수를 0으로 초기화하세요.\n8. rear 변수를 0으로 초기화하세요.\n9. start를 queue 배열의 rear에 추가한 후, rear를 1 증가시키세요.\n10. visited 배열의 start 인덱스를 1로 설정하여 방문했음을 표시하세요.\n11. [rep_start(1)] front가 rear보다 작을 때까지 반복하는 while 루프를 작성하세요.\n12. 현재 노드를 cur에 저장하세요. (queue의 front 위치)\n13. front 변수를 1 증가시켜 다음 요소를 가리키게 하세요.\n14. [rep_start(2)] n까지의 숫자에 대해 반복하는 for 루프를 작성하세요.\n15. [cond_start(3)] cur과 i가 연결되어 있고(값이 1) i가 방문하지 않았는지 확인하는 조건문을 작성하세요.\n16. queue의 rear에 i를 추가하고 rear를 1 증가시키세요.\n17. visited 배열의 i 인덱스를 1로 설정하여 방문했음을 표시하세요.\n18. dist 배열의 i 인덱스에 cur의 거리 + 1을 저장하세요.\n19. [cond_end(3)]\n20. [rep_end(2)]\n21. [rep_end(1)]\n22. sum 변수를 0으로 초기화하세요.\n23. [rep_start(1)] n까지의 숫자에 대해 반복하는 for 루프를 작성하세요.\n24. sum에 dist 배열의 i번째 값을 더하세요.\n25. [rep_end(1)]\n26. sum을 반환하세요.\n27. [func_def_end(1)]\n28. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n29. 정수형 변수 n과 m을 선언하세요.\n30. 정수형 변수 i를 선언하세요.\n31. n과 m을 입력받으세요.\n32. [rep_start(1)] m까지의 숫자에 대해 반복하는 for 루프를 작성하세요.\n33. 정수형 변수 a와 b를 선언하세요.\n34. a와 b의 값을 입력받으세요.\n35. graph[a][b]를 1로 설정하여 a와 b의 연결을 표시하세요.\n36. graph[b][a]를 1로 설정하여 b와 a의 연결을 표시하세요.\n37. [rep_end(1)]\n38. min 변수를 1000000으로 초기화하세요.\n39. person 변수를 0으로 초기화하세요.\n40. [rep_start(1)] n까지의 숫자에 대해 반복하는 for 루프를 작성하세요.\n41. total에 bfs 함수를 호출하여 i의 총 거리를 저장하세요.\n42. [cond_start(2)] 총 거리가 min보다 작은지 확인하는 조건문을 작성하세요.\n43. min을 total로 업데이트하세요.\n44. person을 i로 업데이트하세요.\n45. [cond_end(2)]\n46. [rep_end(1)]\n47. person을 출력하세요.\n48. return 0;으로 프로그램을 종료하세요.\n49. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\n#define MAX 10001\n\ntypedef struct {\n    int start;\n    int end;\n    int cost;\n} Shortcut;\n\nShortcut shortcuts[12];\nint dist[MAX];\n\nint min(int a, int b) {\n    if (a < b)\n        return a;\n    else\n        return b;\n}\n\nint main() {\n    int N, D;\n    scanf(\"%d %d\", &N, &D);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &shortcuts[i].start, &shortcuts[i].end, &shortcuts[i].cost);\n    }\n\n    for (int i = 0; i <= D; i++) {\n        dist[i] = i;\n    }\n\n    for (int i = 0; i <= D; i++) {\n        if (i > 0) {\n            if (dist[i] > dist[i - 1] + 1) {\n                dist[i] = dist[i - 1] + 1;\n            }\n        }\n\n        for (int j = 0; j < N; j++) {\n            int s = shortcuts[j].start;\n            int e = shortcuts[j].end;\n            int c = shortcuts[j].cost;\n\n            if (s == i && e <= D) {\n                if (dist[e] > dist[s] + c) {\n                    dist[e] = dist[s] + c;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\n\", dist[D]);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 min을 정의하세요. (매개변수: int a, int b)\n2. [cond_start(1)] a가 b보다 작은지 확인하는 조건문을 작성하세요.\n3. a가 b보다 작다면 a를 반환하세요.\n4. [cond_end(1)]\n5. b를 반환하세요.\n6. [func_def_end(1)]\n7. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n8. 정수형 변수 N과 D를 선언하세요.\n9. N과 D에 입력을 받으세요.\n10. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n11. shortcuts 배열의 각 요소에 대해 start, end, cost를 입력받으세요.\n12. [rep_end(1)]\n13. [rep_start(1)] i를 선언해 0부터 D까지 반복하는 for 루프를 작성하세요.\n14. dist 배열의 i번째 요소를 i로 초기화하세요.\n15. [rep_end(1)]\n16. [rep_start(1)] i를 선언해 0부터 D까지 반복하는 for 루프를 작성하세요.\n17. [cond_start(2)] i가 0보다 큰지 확인하는 조건문을 작성하세요.\n18. dist[i]가 dist[i - 1] + 1보다 큰지 확인하는 조건문을 작성하세요.\n19. dist[i]를 dist[i - 1] + 1로 업데이트하세요.\n20. [cond_end(2)]\n21. [rep_start(2)] j를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n22. shortcuts 배열에서 start, end, cost를 각각 s, e, c로 가져오세요.\n23. [cond_start(3)] s가 i와 같고 e가 D 이하인지 확인하는 조건문을 작성하세요.\n24. dist[e]가 dist[s] + c보다 큰지 확인하는 조건문을 작성하세요.\n25. dist[e]를 dist[s] + c로 업데이트하세요.\n26. [cond_end(3)]\n27. [rep_end(2)]\n28. [rep_end(1)]\n29. dist[D]를 출력하세요.\n30. return 0;으로 프로그램을 종료하세요.\n31. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\n#define MAX 50\n\nint field[MAX][MAX];\nint visited[MAX][MAX];\nint M, N;\n\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\n\nvoid dfs(int x, int y) {\n    visited[y][x] = 1;\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n\n        if (nx >= 0 && ny >= 0 && nx < M && ny < N) {\n            if (field[ny][nx] == 1 && visited[ny][nx] == 0) {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int K;\n        scanf(\"%d %d %d\", &M, &N, &K);\n\n        for (int y = 0; y < N; y++) {\n            for (int x = 0; x < M; x++) {\n                field[y][x] = 0;\n                visited[y][x] = 0;\n            }\n        }\n\n        for (int i = 0; i < K; i++) {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            field[y][x] = 1;\n        }\n\n        int count = 0;\n\n        for (int y = 0; y < N; y++) {\n            for (int x = 0; x < M; x++) {\n                if (field[y][x] == 1 && visited[y][x] == 0) {\n                    dfs(x, y);\n                    count++;\n                }\n            }\n        }\n\n        printf(\"%d\n\", count);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] void 반환형 함수 dfs(x, y)를 정의하세요. (매개변수: int x, int y)\n2. 방문한 위치를 표시하기 위해 visited[y][x]를 1로 설정하세요.\n3. [rep_start(1)] 0부터 3까지 반복하는 for 루프를 작성하세요.\n4. nx와 ny를 계산하여 현재 x와 y에서 각각 dx[i]와 dy[i]를 더해 다음 위치를 구하세요.\n5. [cond_start(2)] nx와 ny가 유효한 인덱스 범위 내에 있는지 확인하는 조건문을 작성하세요.\n6. [cond_start(3)] field[ny][nx]가 1인지, 그리고 visited[ny][nx]가 0인지 확인하는 조건문을 작성하세요.\n7. 条件が満たされた場合、フォルダ内で再帰的にdfs(nx, ny)を呼び出します。\n8. [cond_end(3)]\n9. [cond_end(2)]\n10. [rep_end(1)]\n11. [func_def_end(1)]\n12. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n13. 정수형 변수 T를 선언하세요.\n14. T의 값을 입력받으세요.\n15. [rep_start(1)] T번 반복하는 while 루프를 작성하세요.\n16. 정수형 변수 K를 선언하고 값을 입력받으세요.\n17. [rep_start(2)] y를 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n18. [rep_start(3)] x를 0부터 M-1까지 반복하는 for 루프를 작성하세요.\n19. field[y][x]와 visited[y][x]를 0으로 초기화하세요.\n20. [rep_end(3)]\n21. [rep_end(2)]\n22. [rep_start(2)] K번 반복하는 for 루프를 작성하세요.\n23. 정수형 변수 x와 y를 입력받으세요.\n24. field[y][x]를 1로 설정하세요.\n25. [rep_end(2)]\n26. 정수형 변수 count를 0으로 초기화하세요.\n27. [rep_start(2)] y를 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n28. [rep_start(3)] x를 0부터 M-1까지 반복하는 for 루프를 작성하세요.\n29. [cond_start(2)] field[y][x]가 1이고 visited[y][x]가 0인 경우를 확인하는 조건문을 작성하세요.\n30. 조건이 만족되면 dfs(x, y) 호출하고 count를 증가시키세요.\n31. [cond_end(2)]\n32. [rep_end(3)]\n33. [rep_end(2)]\n34. count의 값을 출력하세요.\n35. [rep_end(1)]\n36. return 0;으로 프로그램을 종료하세요.\n37. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N;\n    char map[50][51];\n    int max = 0;\n\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", map[i]);\n    }\n\n    for (int i = 0; i < N; i++) {\n        int count = 0;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            if (map[i][j] == 'Y') {\n                count++;\n            } else {\n                for (int k = 0; k < N; k++) {\n                    if (map[i][k] == 'Y' && map[k][j] == 'Y') {\n                        count++;\n                        break;\n                    }\n                }\n            }\n        }\n        if (count > max) max = count;\n    }\n\n    printf(\"%d\n\", max);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N을 선언하세요.\n3. 50x51 크기의 2차원 char 배열 map을 선언하세요.\n4. 정수형 변수 max를 0으로 초기화하세요.\n5. N의 값을 입력받으세요.\n6. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n7. map[i]에 문자열을 입력받으세요.\n8. [rep_end(1)]\n9. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n10. 정수형 변수 count를 0으로 초기화하세요.\n11. [rep_start(2)] j를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n12. [cond_start(2)] i와 j가 같은지 확인하는 조건문을 작성하세요.\n13. i와 j가 같다면 다음 반복으로 넘어가세요.\n14. [cond_end(2)]\n15. [cond_start(2)] map[i][j]가 'Y'인지 확인하는 조건문을 작성하세요.\n16. map[i][j]가 'Y'라면 count를 1 증가시키세요.\n17. [cond_end(2)]\n18. [cond_start(2)] map[i][j]가 'Y'가 아니라면, k를 활용한 추가 조건문을 작성하세요.\n19. [rep_start(3)] k를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n20. [cond_start(3)] map[i][k]가 'Y'이고 map[k][j]가 'Y'인지 확인하는 조건문을 작성하세요.\n21. 조건이 참이면 count를 1 증가시키고 루프를 종료하세요.\n22. [cond_end(3)]\n23. [rep_end(3)]\n24. [cond_end(2)]\n25. [rep_end(2)]\n26. [cond_start(1)] count가 max보다 클 때의 조건문을 작성하세요.\n27. count가 max보다 크면 max를 count로 업데이트하세요.\n28. [cond_end(1)]\n29. printf를 사용하여 max의 값을 출력하세요.\n30. return 0;으로 프로그램을 종료하세요.\n31. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, a[10], line[10] = {0};\n\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for (int i = 0; i < N; i++) {\n        int cnt = 0;\n        for (int j = 0; j < N; j++) {\n            if (line[j] == 0) {\n                if (cnt == a[i]) {\n                    line[j] = i + 1;\n                    break;\n                }\n                cnt++;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", line[i]);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 N을 선언합니다.  \n3. 정수형 배열 a[10]과 line[10]을 선언하고 line 배열을 0으로 초기화합니다.  \n4. N의 값을 입력받습니다.  \n5. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.  \n6. i번째 원소에 대한 값을 입력받아 a[i]에 저장합니다.  \n7. [rep_end(1)]  \n8. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.  \n9. int형 변수 cnt를 0으로 초기화합니다.  \n10. [rep_start(2)] j를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.  \n11. [cond_start(2)] line[j]가 0인지 확인하는 조건문을 작성하세요.  \n12. [cond_start(3)] cnt가 a[i]와 같은지 확인하는 조건문을 작성하세요.  \n13. cnt가 a[i]와 같다면 line[j]에 i+1을 저장합니다.  \n14. 루프를 종료하기 위해 break를 실행합니다.  \n15. [cond_end(3)]  \n16. cnt를 증가시킵니다.  \n17. [cond_end(2)]  \n18. [rep_end(2)]  \n19. [rep_end(1)]  \n20. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.  \n21. i번째 원소에 해당하는 line[i]를 출력합니다.  \n22. [rep_end(1)]  \n23. return 0;으로 프로그램을 종료하세요.  \n24. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint n, s, a[20], cnt;\n\nvoid dfs(int idx, int sum) {\n    if (idx == n) return;\n    if (sum + a[idx] == s) cnt++;\n    dfs(idx + 1, sum + a[idx]);\n    dfs(idx + 1, sum);\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &s);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    dfs(0, 0);\n    printf(\"%d\n\", cnt);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 dfs를 정의하세요. (매개변수: int idx, int sum)\n2. [cond_start(1)] idx가 n과 같은지 확인하는 조건문을 작성하세요.\n3. idx가 n과 같다면 함수를 종료하세요.\n4. [cond_end(1)]\n5. [cond_start(1)] sum과 a[idx]의 합이 s와 같은지 확인하는 조건문을 작성하세요.\n6. 합이 s와 같으면 카운트를 증가시키세요.\n7. [cond_end(1)]\n8. dfs 함수를 idx + 1과 sum + a[idx]로 재귀 호출하세요.\n9. dfs 함수를 idx + 1과 sum으로 재귀 호출하세요.\n10. [func_def_end(1)]\n11. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n12. n과 s를 저장할 변수를 선언하세요.\n13. n과 s의 값을 입력받으세요.\n14. [rep_start(1)] i를 선언해 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n15. a[i]에 입력값을 저장하세요.\n16. [rep_end(1)]\n17. dfs 함수를 0과 0으로 호출하세요.\n18. cnt를 출력하세요.\n19. return 0;으로 프로그램을 종료하세요.\n20. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nvoid swap(int *a, int *b) {\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid quicksort(int arr[], int left, int right) {\n    if (left >= right) return;\n    int pivot = arr[(left + right) / 2];\n    int l = left, r = right;\n\n    while (l <= r) {\n        while (arr[l] < pivot) l++;\n        while (arr[r] > pivot) r--;\n        if (l <= r) {\n            swap(&arr[l], &arr[r]);\n            l++;\n            r--;\n        }\n    }\n\n    quicksort(arr, left, r);\n    quicksort(arr, l, right);\n}\n\nint main() {\n    int n;\n    int a[100000], b[100000], diff[100000];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &a[i], &b[i]);\n        diff[i] = b[i] - a[i];\n    }\n\n    quicksort(diff, 0, n - 1);\n\n    int median1 = diff[(n - 1) / 2];\n    int median2 = diff[n / 2];\n\n    printf(\"%d\n\", median2 - median1 + 1);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] void 반환형 swap 함수를 정의하세요. (매개변수: int 포인터 a, int 포인터 b)\n2. int형 변수 t를 선언하고, a가 가리키는 값을 t에 저장하세요.\n3. a가 가리키는 값을 b가 가리키는 값으로 변경하세요.\n4. b가 가리키는 값을 t로 변경하세요.\n5. [func_def_end(1)]\n6. [func_def_start(1)] void 반환형 quicksort 함수를 정의하세요. (매개변수: int 배열 arr[], int left, int right)\n7. [cond_start(1)] left가 right보다 크거나 같은지 확인하는 조건문을 작성하세요.\n8. left가 right보다 크거나 같다면 함수를 종료하세요.\n9. [cond_end(1)]\n10. 배열의 중간 지점을 기준으로 pivot 값을 설정하세요.\n11. int형 변수 l와 r을 각각 left와 right로 초기화하세요.\n12. [rep_start(1)] l이 r보다 작거나 같은 동안 반복하는 while 루프를 작성하세요.\n13. [rep_start(2)] arr[l]이 pivot보다 작은 동안 l을 증가시키는 while 루프를 작성하세요.\n14. [rep_end(2)]\n15. [rep_start(2)] arr[r]이 pivot보다 큰 동안 r을 감소시키는 while 루프를 작성하세요.\n16. [rep_end(2)]\n17. [cond_start(2)] l이 r보다 작거나 같은지 확인하는 조건문을 작성하세요.\n18. l이 r보다 작거나 같다면, arr[l]과 arr[r]을 swap하세요.\n19. l과 r을 각각 증가시키고 감소시키세요.\n20. [cond_end(2)]\n21. [rep_end(1)]\n22. quicksort 함수를 재귀적으로 호출하여 arr[left]부터 arr[r]까지 정렬하세요.\n23. quicksort 함수를 재귀적으로 호출하여 arr[l]부터 arr[right]까지 정렬하세요.\n24. [func_def_end(1)]\n25. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n26. int형 변수 n을 선언하세요.\n27. int형 배열 a[100000], b[100000], diff[100000]를 선언하세요.\n28. n의 값을 입력받으세요.\n29. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n30. a[i]와 b[i]의 값을 입력받으세요.\n31. diff 배열의 i번째 값에 b[i]에서 a[i]를 뺀 결과를 저장하세요.\n32. [rep_end(1)]\n33. quicksort 함수를 호출하여 diff 배열을 정렬하세요.\n34. int형 변수 median1에 diff의 중간 값을 대입하세요. (n-1)/2의 인덱스)\n35. int형 변수 median2에 diff의 중간 값을 대입하세요. (n/2의 인덱스)\n36. median2와 median1의 차이에 1을 더한 값을 출력하세요.\n37. return 0;으로 프로그램을 종료하세요.\n38. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint is_palindrome(char *s, int start, int end) {\n    while (start < end) {\n        if (s[start] != s[end]) return 0;\n        start++;\n        end--;\n    }\n    return 1;\n}\n\nint main() {\n    char s[51];\n    int len, i;\n\n    scanf(\"%s\", s);\n    for (len = 0; s[len]; len++);\n\n    for (i = 0; i < len; i++) {\n        if (is_palindrome(s, i, len - 1)) {\n            printf(\"%d\n\", len + i);\n            return 0;\n        }\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] char 포인터 s와 두 개의 int 매개변수를 받는 함수 is_palindrome을 정의하세요.\n2. [rep_start(1)] start가 end보다 작은 동안 반복하는 while 루프를 작성하세요.\n3. [cond_start(2)] s의 start 위치와 end 위치의 문자가 같은지 확인하는 조건문을 작성하세요.\n4. s[start]와 s[end]가 다르면 0을 반환하여 소문자 문자열이 아닌 경우를 처리하세요.\n5. [cond_end(2)]\n6. start를 증가시키고 end를 감소시켜 문자열의 앞과 뒤를 비교합니다.\n7. [rep_end(1)]\n8. 모든 문자가 일치하면 1을 반환하여 소문자 문자열임을 확인하세요.\n9. [func_def_end(1)]\n10. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n11. char형 배열 s를 51 바이트 크기로 선언하세요.\n12. int형 변수 len과 i를 선언하세요.\n13. 문자열 s에 입력을 받으세요.\n14. [rep_start(1)] len을 0으로 초기화하고 s[len]이 0이 아닐 때까지 반복하여 문자열의 길이를 계산하세요.\n15. [rep_end(1)]\n16. [rep_start(1)] i를 0으로 초기화하고 i가 len보다 작을 동안 반복하는 for 루프를 작성하세요.\n17. [cond_start(2)] is_palindrome 함수를 이용하여 문자열의 i번째 인덱스부터 끝까지가 팰린돔인지 확인하는 조건문을 작성하세요.\n18. 팰린돔이라면 해당 index와 len을 더한 값을 출력하세요.\n19. 프로그램을 종료하기 위해 0을 반환하세요.\n20. [cond_end(2)]\n21. [rep_end(1)]\n22. return 0;으로 main 함수를 종료하세요.\n23. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint queue[10000], front, rear;\nint visited[10000], dist[10000];\nint stone[10000];\n\nint main() {\n    int n, a, b;\n    int i;\n\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &stone[i]);\n        visited[i] = 0;\n        dist[i] = -1;\n    }\n\n    scanf(\"%d %d\", &a, &b);\n    a--; b--;\n\n    front = rear = 0;\n    queue[rear++] = a;\n    visited[a] = 1;\n    dist[a] = 0;\n\n    while (front < rear) {\n        int cur = queue[front++];\n        int jump = stone[cur];\n        for (i = 1; cur + i * jump < n; i++) {\n            int next = cur + i * jump;\n            if (!visited[next]) {\n                visited[next] = 1;\n                dist[next] = dist[cur] + 1;\n                queue[rear++] = next;\n            }\n        }\n        for (i = 1; cur - i * jump >= 0; i++) {\n            int next = cur - i * jump;\n            if (!visited[next]) {\n                visited[next] = 1;\n                dist[next] = dist[cur] + 1;\n                queue[rear++] = next;\n            }\n        }\n    }\n\n    printf(\"%d\n\", dist[b]);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 배열 queue를 선언하고 크기를 10000으로 설정합니다.\n3. front와 rear 변수를 선언하여 큐의 앞과 뒤를 추적합니다.\n4. visited 배열을 선언하여 각 노드의 방문 여부를 저장합니다.\n5. dist 배열을 선언하여 각 노드까지의 거리(최소 점프 수)를 저장합니다.\n6. stone 배열을 선언하여 각 위치에서 점프할 거리 저장합니다.\n7. 정수형 변수 n, a, b를 선언합니다.\n8. 정수형 변수 i를 선언합니다.\n9. n의 값을 입력받습니다.\n10. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n11. 각 위치에 대한 stone 값을 입력받습니다.\n12. 해당 위치를 방문하지 않은 것으로 표시합니다.\n13. 거리 값을 -1로 초기화합니다.\n14. [rep_end(1)]\n15. a와 b의 값을 입력받습니다.\n16. a와 b를 0부터 시작하는 인덱스로 변환합니다. (1 감소)\n17. front와 rear를 0으로 초기화합니다. 큐를 초기화합니다.\n18. a를 큐에 추가하고, visited[a]를 1로 설정합니다. (방문 처리)\n19. dist[a]를 0으로 설정하여 a의 거리를 초기화합니다.\n20. [rep_start(1)] front가 rear보다 작은 동안 반복하는 while 루프를 작성하세요.\n21. 현재 큐의 front에 있는 값을 cur로 설정하고 front를 증가시킵니다.\n22. cur 위치에서의 점프 거리를 jump로 설정합니다.\n23. [rep_start(2)] i를 1부터 시작해 cur + i * jump가 n보다 작은 동안 반복하는 for 루프를 작성하세요.\n24. 다음 위치를 계산하여 next에 저장합니다.\n25. [cond_start(3)] next가 방문되지 않았는지 확인하는 조건문을 작성하세요.\n26. 방문하지 않았다면 visited[next]를 1로 설정하여 방문 처리합니다.\n27. dist[next]를 cur의 거리 + 1로 설정합니다.\n28. next를 큐에 추가합니다.\n29. [cond_end(3)]\n30. [rep_end(2)]\n31. [rep_start(2)] i를 1부터 시작해 cur - i * jump가 0 이상인 동안 반복하는 for 루프를 작성하세요.\n32. 다음 위치를 계산하여 next에 저장합니다.\n33. [cond_start(3)] next가 방문되지 않았는지 확인하는 조건문을 작성하세요.\n34. 방문하지 않았다면 visited[next]를 1로 설정하여 방문 처리합니다.\n35. dist[next]를 cur의 거리 + 1로 설정합니다.\n36. next를 큐에 추가합니다.\n37. [cond_end(3)]\n38. [rep_end(2)]\n39. [rep_end(1)]\n40. dist[b]를 출력하여 b까지의 거리(최소 점프 수)를 표시합니다.\n41. return 0;으로 프로그램을 종료하세요.\n42. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nchar left[600001], right[600001];\nint l_top = 0, r_top = 0;\n\nint main() {\n    int m;\n    char cmd, ch;\n\n    int c;\n    while ((c = getchar()) != '\n' && c != EOF)\n        left[l_top++] = c;\n\n    scanf(\"%d\", &m);\n    while (m--) {\n        scanf(\" %c\", &cmd);\n        if (cmd == 'L') {\n            if (l_top > 0)\n                right[r_top++] = left[--l_top];\n        } else if (cmd == 'D') {\n            if (r_top > 0)\n                left[l_top++] = right[--r_top];\n        } else if (cmd == 'B') {\n            if (l_top > 0)\n                --l_top;\n        } else if (cmd == 'P') {\n            scanf(\" %c\", &ch);\n            left[l_top++] = ch;\n        }\n    }\n\n    for (int i = 0; i < l_top; i++)\n        putchar(left[i]);\n    for (int i = r_top - 1; i >= 0; i--)\n        putchar(right[i]);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 m을 선언하세요.\n3. 문자형 변수 cmd와 ch를 선언하세요.\n4. 정수형 변수 c를 선언하세요.\n5. [rep_start(1)] getchar()를 이용해 입력을 받을 때까지 반복하세요.\n6. 입력받은 문자가 줄바꿈('\\n')이나 파일의 끝(EOF)이 아닐 경우 left 배열에 문자를 저장하세요.\n7. left 배열의 상단을 증가시키세요.\n8. [rep_end(1)]\n9. m에 대한 입력을 받으세요.\n10. [rep_start(1)] m이 남아있는 동안 반복하세요.\n11. 명령어 cmd를 입력받으세요.\n12. [cond_start(2)] cmd가 'L'인 경우를 확인하세요.\n13. l_top이 0보다 클 경우 right 배열에 left 배열의 최상단 요소를 이동하세요.\n14. l_top을 감소시키세요.\n15. [cond_end(2)]\n16. [cond_start(2)] cmd가 'D'인 경우를 확인하세요.\n17. r_top이 0보다 클 경우 left 배열에 right 배열의 최상단 요소를 이동하세요.\n18. r_top을 감소시키세요.\n19. [cond_end(2)]\n20. [cond_start(2)] cmd가 'B'인 경우를 확인하세요.\n21. l_top이 0보다 클 경우 l_top을 감소시켜 왼쪽에서 마지막 문자를 삭제하세요.\n22. [cond_end(2)]\n23. [cond_start(2)] cmd가 'P'인 경우를 확인하세요.\n24. 추가할 문자 ch를 입력받으세요.\n25. left 배열의 최상단에 ch를 추가하고 l_top을 증가시키세요.\n26. [cond_end(2)]\n27. [rep_end(1)]\n28. [rep_start(1)] left 배열의 모든 문자에 대해 반복하세요.\n29. 각 문자를 출력하세요.\n30. [rep_end(1)]\n31. [rep_start(1)] right 배열을 역순으로 반복하며 출력하세요.\n32. [rep_end(1)]\n33. return 0;으로 프로그램을 종료하세요.\n34. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint n;\nchar words[100][51];\nint pattern[100][51];\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n        scanf(\"%s\", words[i]);\n\n    for (int i = 0; i < n; i++) {\n        int map[26];\n        for (int j = 0; j < 26; j++) map[j] = -1;\n        int next_id = 0;\n\n        for (int j = 0; words[i][j]; j++) {\n            int ch = words[i][j] - 'a';\n            if (map[ch] == -1) map[ch] = next_id++;\n            pattern[i][j] = map[ch];\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int k = 0;\n            for (; words[i][k] && words[j][k]; k++) {\n                if (pattern[i][k] != pattern[j][k])\n                    break;\n            }\n            if (!words[i][k] && !words[j][k])\n                count++;\n        }\n    }\n\n    printf(\"%d\n\", count);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n의 값을 입력 받으세요.\n3. [rep_start(1)] i를 선언하여 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n4. 각 반복에서 words[i]에 문자열을 입력 받으세요.\n5. [rep_end(1)]\n6. [rep_start(1)] i를 선언하여 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n7. 문자 맵을 저장할 int형 배열 map[26]을 선언하세요.\n8. [rep_start(2)] j를 선언하여 0부터 25까지 반복하는 for 루프를 작성하세요.\n9. 각 문자를 초기화하여 -1로 설정하세요.\n10. [rep_end(2)]\n11. next_id를 0으로 초기화하세요.\n12. [rep_start(2)] j를 사용하여 words[i][j]가 존재하는 동안 반복하세요.\n13. 현재 문자 ch를 words[i][j]에서 가져와서 'a'를 뺀 값을 사용하세요.\n14. [cond_start(3)] map[ch]가 -1인지 확인하는 조건문을 작성하세요.\n15. map[ch]가 -1이라면, map[ch]에 next_id를 할당하고 next_id를 증가시키세요.\n16. [cond_end(3)]\n17. pattern[i][j]에 map[ch] 값을 저장하세요.\n18. [rep_end(2)]\n19. [rep_end(1)]\n20. int형 변수 count를 0으로 초기화하세요.\n21. [rep_start(1)] i를 선언하여 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n22. [rep_start(2)] j를 선언하여 i+1부터 n-1까지 반복하는 for 루프를 작성하세요.\n23. int형 변수 k를 0으로 초기화하세요.\n24. [rep_start(3)] words[i][k]와 words[j][k]가 존재하는 동안 반복하세요.\n25. [cond_start(4)] pattern[i][k]와 pattern[j][k]가 다른지 확인하는 조건문을 작성하세요.\n26. 서로 다르면 루프를 종료하세요.\n27. [cond_end(4)]\n28. [cond_start(3)] words[i][k]와 words[j][k]가 모두 존재하지 않는지 확인하세요.\n29. 둘 다 존재하지 않으면 count를 증가시키세요.\n30. [cond_end(3)]\n31. [rep_end(3)]\n32. [rep_end(2)]\n33. [rep_end(1)]\n34. count 값을 출력하세요.\n35. 프로그램을 0을 반환하며 종료하세요.\n36. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int s, k;\n    scanf(\"%d %d\", &s, &k);\n\n    long long result = 1;\n    int q = s / k;\n    int r = s % k;\n\n    for (int i = 0; i < r; i++)\n        result *= (q + 1);\n    for (int i = r; i < k; i++)\n        result *= q;\n\n    printf(\"%lld\n\", result);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 s와 k를 선언하세요.\n3. s와 k에 입력을 받으세요.\n4. long long형 변수 result를 1로 초기화하세요.\n5. 정수형 변수 q를 선언하고 s를 k로 나눈 값을 저장하세요.\n6. 정수형 변수 r를 선언하고 s를 k로 나눈 나머지를 저장하세요.\n7. [rep_start(1)] i를 선언해 0부터 r-1까지 반복하는 for 루프를 작성하세요.\n8. result에 (q + 1)을 곱하세요.\n9. [rep_end(1)]\n10. [rep_start(1)] i를 선언해 r부터 k-1까지 반복하는 for 루프를 작성하세요.\n11. result에 q를 곱하세요.\n12. [rep_end(1)]\n13. result를 출력하세요.\n14. return 0;으로 프로그램을 종료하세요.\n15. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint square(int x) {\n    return x * x;\n}\n\nint abs(int x) {\n    if (x < 0)\n        return -x;\n    else\n        return x;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int x1, y1, r1, x2, y2, r2;\n        scanf(\"%d %d %d %d %d %d\", &x1, &y1, &r1, &x2, &y2, &r2);\n\n        int dx = x1 - x2;\n        int dy = y1 - y2;\n        int d2 = square(dx) + square(dy);\n        int sumR = r1 + r2;\n        int diffR = abs(r1 - r2);\n        int sumR2 = square(sumR);\n        int diffR2 = square(diffR);\n\n        if (d2 == 0 && r1 == r2)\n            printf(\"-1\n\");\n        else if (d2 == sumR2 || d2 == diffR2)\n            printf(\"1\n\");\n        else if (diffR2 < d2 && d2 < sumR2)\n            printf(\"2\n\");\n        else\n            printf(\"0\n\");\n    }\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 square 함수를 정의하세요. (매개변수: int x)\n2. x의 제곱을 반환하세요.\n3. [func_def_end(1)]\n4. [func_def_start(1)] int 반환형 abs 함수를 정의하세요. (매개변수: int x)\n5. [cond_start(1)] x가 0보다 작은지 확인하는 조건문을 작성하세요.\n6. x가 0보다 작으면 -x를 반환하세요.\n7. [cond_end(1)]\n8. 그렇지 않으면 x를 반환하세요.\n9. [func_def_end(1)]\n10. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n11. 정수형 변수 T를 선언하세요.\n12. T에 대한 입력을 받으세요.\n13. [rep_start(1)] T가 남아있을 동안 반복하는 while 루프를 작성하세요.\n14. 정수형 변수 x1, y1, r1, x2, y2, r2를 선언하세요.\n15. 원의 중심 좌표와 반지름에 대한 입력을 받으세요.\n16. dx를 x1 - x2로 정의하세요.\n17. dy를 y1 - y2로 정의하세요.\n18. d2를 dx의 제곱과 dy의 제곱을 더하여 계산하세요.\n19. sumR을 r1과 r2의 합으로 정의하세요.\n20. diffR을 r1과 r2의 차의 절댓값으로 정의하세요.\n21. sumR2를 sumR의 제곱으로 정의하세요.\n22. diffR2를 diffR의 제곱으로 정의하세요.\n23. [cond_start(1)] d2가 0이고, r1과 r2가 같은지 확인하는 조건문을 작성하세요.\n24. 두 원이 동일 위치에 있다면 -1을 출력하세요.\n25. [cond_end(1)]\n26. [cond_start(1)] d2가 sumR2와 같거나 d2가 diffR2와 같은지 확인하는 조건문을 작성하세요.\n27. 원이 접하는 경우 1을 출력하세요.\n28. [cond_end(1)]\n29. [cond_start(1)] diffR2가 d2보다 작고, d2가 sumR2보다 작으면 확인하는 조건문을 작성하세요.\n30. 두 원이 서로를 포함하는 경우 2를 출력하세요.\n31. [cond_end(1)]\n32. 그렇지 않다면 두 원이 겹치지 않음을 의미하므로 0을 출력하세요.\n33. [cond_end(1)]\n34. [rep_end(1)]\n35. return 0;으로 프로그램을 종료하세요.\n36. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    int count0[41];\n    int count1[41];\n\n    count0[0] = 1;\n    count1[0] = 0;\n    count0[1] = 0;\n    count1[1] = 1;\n\n    for (int i = 2; i <= 40; i++) {\n        count0[i] = count0[i - 1] + count0[i - 2];\n        count1[i] = count1[i - 1] + count1[i - 2];\n    }\n\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        printf(\"%d %d\n\", count0[n], count1[n]);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 T를 선언하세요.\n3. T에 사용자로부터 입력을 받으세요.\n4. 정수형 배열 count0[41]과 count1[41]을 선언하세요.\n5. count0[0]을 1로 초기화하세요.\n6. count1[0]을 0으로 초기화하세요.\n7. count0[1]을 0으로 초기화하세요.\n8. count1[1]을 1로 초기화하세요.\n9. [rep_start(1)] i를 선언해 2부터 40까지 반복하는 for 루프를 작성하세요.\n10. count0[i]를 count0[i - 1]과 count0[i - 2]의 합으로 계산하세요.\n11. count1[i]를 count1[i - 1]과 count1[i - 2]의 합으로 계산하세요.\n12. [rep_end(1)]\n13. [rep_start(1)] T번 반복하여 입력을 처리하는 while 루프를 작성하세요.\n14. 정수형 변수 n을 선언하세요.\n15. n에 사용자로부터 입력을 받으세요.\n16. count0[n]과 count1[n]을 출력하세요.\n17. [rep_end(1)]\n18. return 0;으로 프로그램을 종료하세요.\n19. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint is_inside(int x, int y, int cx, int cy, int r) {\n    int dx = x - cx;\n    int dy = y - cy;\n    return dx * dx + dy * dy < r * r;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int x1, y1, x2, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\n        int n;\n        scanf(\"%d\", &n);\n\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            int cx, cy, r;\n            scanf(\"%d %d %d\", &cx, &cy, &r);\n\n            int start_inside = is_inside(x1, y1, cx, cy, r);\n            int end_inside = is_inside(x2, y2, cx, cy, r);\n\n            if (start_inside != end_inside) {\n                count++;\n            }\n        }\n\n        printf(\"%d\n\", count);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 is_inside를 정의하세요. (매개변수: int x, int y, int cx, int cy, int r)\n2. x와 cx의 차이를 변수 dx에 저장하세요.\n3. y와 cy의 차이를 변수 dy에 저장하세요.\n4. (dx*dx + dy*dy)가 r*r보다 작은지 확인하여 그 결과를 반환하세요.\n5. [func_def_end(1)]\n6. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n7. 정수형 변수 T를 선언하세요.\n8. T에 값을 입력받으세요.\n9. [rep_start(1)] T가 0보다 클 동안 반복하세요.\n10. 정수형 변수 x1, y1, x2, y2를 선언하세요.\n11. x1, y1, x2, y2의 값을 입력받으세요.\n12. 정수형 변수 n을 선언하고 값을 입력받으세요.\n13. 정수형 변수 count를 0으로 초기화하세요.\n14. [rep_start(2)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n15. 정수형 변수 cx, cy, r를 선언하세요.\n16. cx, cy, r의 값을 입력받으세요.\n17. start_inside 변수를 is_inside 함수를 호출하여 x1, y1, cx, cy, r로 초기화하세요.\n18. end_inside 변수를 is_inside 함수를 호출하여 x2, y2, cx, cy, r로 초기화하세요.\n19. [cond_start(2)] start_inside와 end_inside가 다르면 실행되는 조건문을 작성하세요.\n20. 다르다면 count를 1 증가시키세요.\n21. [cond_end(2)]\n22. [rep_end(2)]\n23. count의 값을 출력하세요.\n24. [rep_end(1)]\n25. return 0;으로 프로그램을 종료하세요.\n26. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int target[50];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d\", &target[i]);\n    }\n\n    int deque[100];\n    int front = 0, rear = N;\n\n    for (int i = 0; i < N; i++) {\n        deque[i] = i + 1;\n    }\n\n    int total_ops = 0;\n\n    for (int i = 0; i < M; i++) {\n        int t = target[i];\n        int idx = 0;\n\n        for (int j = front; j < rear; j++) {\n            if (deque[j] == t) {\n                idx = j - front;\n                break;\n            }\n        }\n\n        int left_ops = idx;\n        int right_ops = (rear - front) - idx;\n\n        if (left_ops <= right_ops) {\n            total_ops += left_ops;\n            for (int j = 0; j < left_ops; j++) {\n                int tmp = deque[front];\n                for (int k = front; k < rear - 1; k++) {\n                    deque[k] = deque[k + 1];\n                }\n                deque[rear - 1] = tmp;\n            }\n        }\n        else {\n            total_ops += right_ops;\n            for (int j = 0; j < right_ops; j++) {\n                int tmp = deque[rear - 1];\n                for (int k = rear - 1; k > front; k--) {\n                    deque[k] = deque[k - 1];\n                }\n                deque[front] = tmp;\n            }\n        }\n\n        front++;\n    }\n\n    printf(\"%d\n\", total_ops);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N과 M을 선언하세요.\n3. N과 M에 입력을 받으세요.\n4. 정수형 배열 target[50]을 선언하세요.\n5. [rep_start(1)] i를 0부터 M 미만까지 반복하는 for 루프를 작성하세요.\n6. target 배열의 i번째 요소에 정수를 입력 받으세요.\n7. [rep_end(1)]\n8. 정수형 배열 deque[100]을 선언하세요.\n9. 정수형 변수 front를 0으로 초기화하세요.\n10. 정수형 변수 rear를 N으로 초기화하세요.\n11. [rep_start(1)] i를 0부터 N 미만까지 반복하는 for 루프를 작성하세요.\n12. deque 배열의 i번째 요소에 i + 1을 할당하세요.\n13. [rep_end(1)]\n14. int형 변수 total_ops를 0으로 초기화하세요.\n15. [rep_start(1)] i를 0부터 M 미만까지 반복하는 for 루프를 작성하세요.\n16. target[i]의 값을 int형 변수 t에 저장하세요.\n17. int형 변수 idx를 0으로 초기화하세요.\n18. [rep_start(2)] j를 front부터 rear 미만까지 반복하는 for 루프를 작성하세요.\n19. [cond_start(3)] deque[j]와 t가 같은지 확인하는 조건문을 작성하세요.\n20. 같다면 idx에 j - front를 할당하고 루프를 종료하세요.\n21. [cond_end(3)]\n22. [rep_end(2)]\n23. int형 변수 left_ops에 idx를 저장하세요.\n24. int형 변수 right_ops에 (rear - front) - idx를 저장하세요.\n25. [cond_start(1)] left_ops가 right_ops보다 작거나 같은지 확인하는 조건문을 작성하세요.\n26. 조건이 참이면 total_ops에 left_ops를 더하세요.\n27. [rep_start(2)] j를 0부터 left_ops 미만까지 반복하는 for 루프를 작성하세요.\n28. deque의 front 요소를 tmp에 저장하세요.\n29. [rep_start(3)] k를 front부터 rear - 2까지 반복하는 for 루프를 작성하세요.\n30. deque[k]에 deque[k + 1]을 할당하세요.\n31. [rep_end(3)]\n32. deque[rear - 1]에 tmp를 할당하세요.\n33. [rep_end(2)]\n34. [cond_end(1)]\n35. [cond_start(1)] 그렇지 않은 경우를 처리하는 조건문을 작성하세요.\n36. total_ops에 right_ops를 더하세요.\n37. [rep_start(2)] j를 0부터 right_ops 미만까지 반복하는 for 루프를 작성하세요.\n38. deque의 rear - 1 요소를 tmp에 저장하세요.\n39. [rep_start(3)] k를 rear - 1부터 front + 1까지 반복하는 for 루프를 작성하세요.\n40. deque[k]에 deque[k - 1]을 할당하세요.\n41. [rep_end(3)]\n42. deque[front]에 tmp를 할당하세요.\n43. [rep_end(2)]\n44. [cond_end(1)]\n45. front의 값을 증가시키세요.\n46. [rep_end(1)]\n47. total_ops를 출력하세요.\n48. return 0;으로 프로그램을 종료하세요.\n49. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    char map[50][51];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", map[i]);\n    }\n\n    int max = 1;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            for (int size = 1; i + size < N && j + size < M; size++) {\n                if (map[i][j] == map[i][j + size]\n                    && map[i][j] == map[i + size][j]\n                    && map[i][j] == map[i + size][j + size]) {\n                    int area = (size + 1) * (size + 1);\n                    if (area > max) {\n                        max = area;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d\n\", max);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N과 M을 선언하세요.\n3. N과 M에 입력을 받으세요.\n4. char형 2차원 배열 map을 선언하여 50x51 크기의 공간을 할당하세요.\n5. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n6. 각 행에 대한 문자열을 입력받아 map 배열에 저장하세요.\n7. [rep_end(1)]\n8. int형 변수 max를 1로 초기화하세요.\n9. [rep_start(1)] i를 선언해 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n10. [rep_start(2)] j를 선언해 0부터 M-1까지 반복하는 for 루프를 작성하세요.\n11. [rep_start(3)] size 변수를 선언해 1부터 시작하여 N과 M의 크기 내에서 반복하는 for 루프를 작성하세요.\n12. [cond_start(3)] 현재의 사각형이 map 배열의 범위 내에 있는지 확인하는 조건문을 작성하세요.\n13. 사각형의 좌표가 유효하면 해당 위치의 값을 비교하는 조건문을 작성하세요.\n14. map의 네 꼭짓점 위치의 값이 같으면, area를 계산하세요.\n15. area가 max보다 크면 max를 area로 업데이트하세요.\n16. [cond_end(3)]\n17. [rep_end(3)]\n18. [rep_end(2)]\n19. [rep_end(1)]\n20. max 값을 출력하세요.\n21. return 0;으로 프로그램을 종료하세요.\n22. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    long long x, y;\n    scanf(\"%lld %lld\", &x, &y);\n\n    int z = (int)((y * 100) / x);\n\n    if (z >= 99) {\n        printf(\"-1\n\");\n        return 0;\n    }\n\n    long long left = 1;\n    long long right = 1000000000;\n    long long result = -1;\n\n    while (left <= right) {\n        long long mid = (left + right) / 2;\n        long long new_x = x + mid;\n        long long new_y = y + mid;\n        int new_z = (int)((new_y * 100) / new_x);\n\n        if (new_z > z) {\n            result = mid;\n            right = mid - 1;\n        }\n        else {\n            left = mid + 1;\n        }\n    }\n\n    printf(\"%lld\n\", result);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. long long 형 변수 x와 y를 선언하세요.\n3. x와 y에 입력을 받으세요.\n4. 비율 z를 계산하기 위해 y를 x로 나누고 100을 곱한 후 int형으로 변환하세요.\n5. [cond_start(1)] z가 99 이상인지 확인하는 조건문을 작성하세요.\n6. z가 99 이상이면 -1을 출력하고 프로그램을 종료하세요.\n7. [cond_end(1)]\n8. long long 형 변수 left를 1로 초기화하세요.\n9. long long 형 변수 right를 1000000000으로 초기화하세요.\n10. long long 형 변수 result를 -1로 초기화하세요.\n11. [rep_start(1)] left가 right보다 작거나 같은 동안 반복합니다.\n12. 중간값 mid를 left와 right의 평균으로 계산하세요.\n13. long long 형 변수 new_x를 x와 mid를 더하여 계산하세요.\n14. long long 형 변수 new_y를 y와 mid를 더하여 계산하세요.\n15. 새로운 비율 new_z를 계산하기 위해 new_y를 new_x로 나누고 100을 곱한 후 int형으로 변환하세요.\n16. [cond_start(2)] new_z가 z보다 큰지 확인하는 조건문을 작성하세요.\n17. new_z가 z보다 크면 result를 mid로 업데이트하고 right를 mid - 1로 설정하세요.\n18. [cond_end(2)]\n19. 그렇지 않으면 left를 mid + 1로 설정하세요.\n20. [rep_end(1)]\n21. result를 출력하세요.\n22. return 0;으로 프로그램을 종료하세요.\n23. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char name[51];\n    int count[26] = {0};\n    int i, len = 0;\n    int odd_count = 0;\n    int odd_index = -1;\n\n    scanf(\"%s\", name);\n\n    while (name[len] != '\u0000') {\n        count[name[len] - 'A']++;\n        len++;\n    }\n\n    for (i = 0; i < 26; i++) {\n        if ((count[i] % 2) == 1) {\n            odd_count++;\n            odd_index = i;\n        }\n    }\n\n    if ((len % 2 == 0 && odd_count != 0) || (len % 2 == 1 && odd_count != 1)) {\n        printf(\"I'm Sorry Hansoo\n\");\n        return 0;\n    }\n\n    for (i = 0; i < 26; i++) {\n        int j = 0;\n        while ((j + 1) <= (count[i] / 2)) {\n            printf(\"%c\", i + 'A');\n            j++;\n        }\n    }\n\n    if ((len % 2) == 1) {\n        printf(\"%c\", odd_index + 'A');\n    }\n\n    for (i = 25; i >= 0; i--) {\n        int j = 0;\n        while ((j + 1) <= (count[i] / 2)) {\n            printf(\"%c\", i + 'A');\n            j++;\n        }\n    }\n\n    printf(\"\n\");\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 배열 name을 크기 51로 선언합니다. (문자열을 저장하기 위함)\n3. int형 배열 count를 크기 26으로 선언하고 0으로 초기화합니다. (각 알파벳의 개수를 세기 위함)\n4. int형 변수 i, len을 0으로 초기화합니다. (len은 문자열의 길이를 나타냄)\n5. int형 변수 odd_count를 0으로 초기화합니다. (홀수 개수의 알파벳을 셀 것임)\n6. int형 변수 odd_index를 -1로 초기화합니다. (홀수 개수 알파벳의 인덱스를 저장하기 위함)\n7. scanf를 이용해 문자열 name에 입력을 받습니다.\n8. [rep_start(1)] 문자열의 각 문자에 대해 반복합니다. (길이가 '\\0'이 아닐 동안)\n9. count 배열의 해당 알파벳 인덱스의 값을 증가시킵니다.\n10. len을 1 증가시켜 문자열 길이를 늘립니다.\n11. [rep_end(1)]\n12. [rep_start(1)] count 배열을 사용하여 각 알파벳의 개수를 검사하는 for 루프를 실행합니다. (0부터 25까지)\n13. [cond_start(2)] count[i]가 홀수인지 확인합니다.\n14. 홀수인 경우 odd_count를 증가시킵니다.\n15. odd_index에 현재의 i 값을 저장합니다.\n16. [cond_end(2)]\n17. [rep_end(1)]\n18. [cond_start(1)] 문자열의 길이에 따른 조건을 확인합니다.\n19. 길이가 짝수이면서 odd_count가 0이 아니거나, 길이가 홀수이면서 odd_count가 1이 아니면\n20. \"I'm Sorry Hansoo\"를 출력하고 프로그램을 종료합니다.\n21. [cond_end(1)]\n22. [rep_start(1)] count 배열을 사용하여 출력할 알파벳을 만드는 반복문을 실행합니다. (0부터 25까지)\n23. int형 변수 j를 0으로 초기화합니다.\n24. [rep_start(2)] j가 count[i]의 절반 이하인 동안 반복합니다.\n25. 해당 알파벳(i + 'A')을 출력합니다.\n26. j를 1 증가시킵니다.\n27. [rep_end(2)]\n28. [rep_end(1)]\n29. [cond_start(1)] 문자열 길이가 홀수일 때 알파벳을 출력하는 조건문을 작성합니다.\n30. 홀수인 경우 odd_index에 해당하는 알파벳을 출력합니다.\n31. [cond_end(1)]\n32. [rep_start(1)] count 배열을 사용하여 출력할 알파벳을 만드는 두 번째 반복문을 실행합니다. (25부터 0까지)\n33. int형 변수 j를 0으로 초기화합니다.\n34. [rep_start(2)] j가 count[i]의 절반 이하인 동안 반복합니다.\n35. 해당 알파벳(i + 'A')을 출력합니다.\n36. j를 1 증가시킵니다.\n37. [rep_end(2)]\n38. [rep_end(1)]\n39. 새 줄을 출력합니다.\n40. 프로그램 종료를 위해 return 0;을 사용합니다.\n41. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int i, j;\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++) {\n        int t;\n        scanf(\"%d\", &t);\n\n        int count = 0;\n        int majority = 0;\n        int army[100000];\n        \n        for (j = 0; j < t; j++) {\n            scanf(\"%d\", &army[j]);\n        }\n\n        int candidate = army[0];\n        count = 1;\n\n        for (j = 1; j < t; j++) {\n            if (army[j] == candidate) {\n                count++;\n            }\n            else {\n                count--;\n                if (count == 0) {\n                    candidate = army[j];\n                    count = 1;\n                }\n            }\n        }\n\n        int total = 0;\n        for (j = 0; j < t; j++) {\n            if (army[j] == candidate) {\n                total++;\n            }\n        }\n\n        if (total > (t / 2)) {\n            printf(\"%d\n\", candidate);\n        }\n        else {\n            printf(\"SYJKGW\n\");\n        }\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 정수형 변수 i와 j를 선언하세요.\n4. 사용자로부터 n을 입력받으세요.\n5. [rep_start(1)] i를 선언해 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n6. 정수형 변수 t를 선언하세요.\n7. 사용자로부터 t를 입력받으세요.\n8. 정수형 변수 count를 0으로 초기화하세요.\n9. 정수형 변수 majority를 0으로 초기화하세요.\n10. 정수형 배열 army[100000]을 선언하세요.\n11. [rep_start(2)] j를 선언해 0부터 t-1까지 반복하는 for 루프를 작성하세요.\n12. 사용자로부터 army 배열의 각 요소를 입력받으세요.\n13. [rep_end(2)]\n14. 배열의 첫 번째 값 army[0]을 candidate 변수에 할당하세요.\n15. count를 1로 초기화하세요.\n16. [rep_start(1)] j를 1부터 t-1까지 반복하는 for 루프를 작성하세요.\n17. [cond_start(2)] army[j]가 candidate와 동일한지 확인하는 조건문을 작성하세요.\n18. army[j]가 candidate와 동일하다면 count를 증가시키세요.\n19. [cond_end(2)]\n20. [cond_start(2)] army[j]가 candidate와 다르다면 count를 감소시키세요.\n21. [cond_start(3)] count가 0인지 확인하는 조건문을 작성하세요.\n22. count가 0이라면 candidate를 army[j]로 변경하세요.\n23. count를 1로 재설정하세요.\n24. [cond_end(3)]\n25. [cond_end(2)]\n26. [rep_end(1)]\n27. 정수형 변수 total을 0으로 초기화하세요.\n28. [rep_start(1)] j를 0부터 t-1까지 반복하는 for 루프를 작성하세요.\n29. [cond_start(2)] army[j]가 candidate와 동일한지 확인하는 조건문을 작성하세요.\n30. army[j]가 candidate와 같다면 total을 증가시키세요.\n31. [cond_end(2)]\n32. [rep_end(1)]\n33. [cond_start(1)] total이 (t / 2)보다 큰지 확인하는 조건문을 작성하세요.\n34. total이 (t / 2)보다 크다면 candidate를 출력하세요.\n35. [cond_end(1)]\n36. [cond_start(1)] total이 (t / 2)보다 작거나 같다면 \"SYJKGW\"를 출력하세요.\n37. [cond_end(1)]\n38. [rep_end(1)]\n39. return 0;으로 프로그램을 종료하세요.\n40. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint get_digit_sum(char *s) {\n    int sum = 0;\n    int i = 0;\n    while (s[i] != '\u0000') {\n        if (s[i] >= '0' && s[i] <= '9') {\n            sum += s[i] - '0';\n        }\n        i++;\n    }\n    return sum;\n}\n\nint compare(char *a, char *b) {\n    int i = 0;\n    int len_a = 0;\n    int len_b = 0;\n\n    while (a[len_a] != '\u0000') {\n        len_a++;\n    }\n\n    while (b[len_b] != '\u0000') {\n        len_b++;\n    }\n\n    if (len_a < len_b) {\n        return -1;\n    }\n    else if (len_a > len_b) {\n        return 1;\n    }\n\n    int sum_a = get_digit_sum(a);\n    int sum_b = get_digit_sum(b);\n\n    if (sum_a < sum_b) {\n        return -1;\n    }\n    else if (sum_a > sum_b) {\n        return 1;\n    }\n\n    while (a[i] != '\u0000' && b[i] != '\u0000') {\n        if (a[i] < b[i]) {\n            return -1;\n        }\n        else if (a[i] > b[i]) {\n            return 1;\n        }\n        i++;\n    }\n\n    return 0;\n}\n\nvoid swap(char a[51], char b[51]) {\n    char temp[51];\n    int i = 0;\n    while (a[i] != '\u0000') {\n        temp[i] = a[i];\n        i++;\n    }\n    temp[i] = '\u0000';\n\n    i = 0;\n    while (b[i] != '\u0000') {\n        a[i] = b[i];\n        i++;\n    }\n    a[i] = '\u0000';\n\n    i = 0;\n    while (temp[i] != '\u0000') {\n        b[i] = temp[i];\n        i++;\n    }\n    b[i] = '\u0000';\n}\n\nint main() {\n    int n;\n    char serials[50][51];\n    int i, j;\n\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++) {\n        scanf(\"%s\", serials[i]);\n    }\n\n    for (i = 0; i < n - 1; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (compare(serials[i], serials[j]) > 0) {\n                swap(serials[i], serials[j]);\n            }\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        printf(\"%s\n\", serials[i]);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 get_digit_sum을 정의하세요. (매개변수: char *s)\n2. int형 변수 sum을 0으로 초기화하세요.\n3. int형 변수 i를 0으로 초기화하세요.\n4. [rep_start(1)] s[i]가 널 문자('\\0')가 아닐 동안 반복하세요.\n5. [cond_start(2)] s[i]가 숫자('0' ~ '9')인지 확인하는 조건문을 작성하세요.\n6. 숫자라면 sum에 s[i] - '0' 값을 더하세요.\n7. [cond_end(2)]\n8. i를 1 증가시키세요.\n9. [rep_end(1)]\n10. sum을 반환하세요.\n11. [func_def_end(1)]\n\n12. [func_def_start(1)] int 반환형 함수 compare을 정의하세요. (매개변수: char *a, char *b)\n13. int형 변수 i를 0으로 초기화하세요.\n14. int형 변수 len_a와 len_b를 0으로 초기화하세요.\n15. [rep_start(1)] a[len_a]가 널 문자('\\0')가 아닐 동안 반복하여 len_a를 계산하세요.\n16. [rep_end(1)]\n17. [rep_start(1)] b[len_b]가 널 문자('\\0')가 아닐 동안 반복하여 len_b를 계산하세요.\n18. [rep_end(1)]\n19. [cond_start(1)] len_a가 len_b보다 작은지 확인하는 조건문을 작성하세요.\n20. len_a가 len_b보다 작다면 -1을 반환하세요.\n21. [cond_end(1)]\n22. [cond_start(1)] len_a가 len_b보다 큰지 확인하는 조건문을 작성하세요.\n23. len_a가 len_b보다 크다면 1을 반환하세요.\n24. [cond_end(1)]\n25. sum_a에 get_digit_sum(a)의 값을 저장하세요.\n26. sum_b에 get_digit_sum(b)의 값을 저장하세요.\n27. [cond_start(1)] sum_a가 sum_b보다 작은지 확인하는 조건문을 작성하세요.\n28. sum_a가 sum_b보다 작다면 -1을 반환하세요.\n29. [cond_end(1)]\n30. [cond_start(1)] sum_a가 sum_b보다 큰지 확인하는 조건문을 작성하세요.\n31. sum_a가 sum_b보다 크다면 1을 반환하세요.\n32. [cond_end(1)]\n33. [rep_start(1)] a와 b를 한 글자씩 비교하며 반복하세요.\n34. [cond_start(2)] a[i]가 b[i]보다 작은지 확인하는 조건문을 작성하세요.\n35. a[i]가 b[i]보다 작다면 -1을 반환하세요.\n36. [cond_end(2)]\n37. [cond_start(2)] a[i]가 b[i]보다 큰지 확인하는 조건문을 작성하세요.\n38. a[i]가 b[i]보다 크다면 1을 반환하세요.\n39. [cond_end(2)]\n40. i를 1 증가시키세요.\n41. [rep_end(1)]\n42. 모든 조건을 통과했으므로 0을 반환하세요.\n43. [func_def_end(1)]\n\n44. [func_def_start(1)] void 반환형 함수 swap을 정의하세요. (매개변수: char a[51], char b[51])\n45. char형 배열 temp를 선언하세요.\n46. int형 변수 i를 0으로 초기화하세요.\n47. [rep_start(1)] a[i]가 널 문자('\\0')가 아닐 동안 반복하세요. \n48. temp[i]에 a[i]를 저장하세요.\n49. i를 1 증가시키세요.\n50. [rep_end(1)]\n51. temp[i]를 널 문자('\\0')로 설정하세요.\n52. i를 0으로 초기화하세요.\n53. [rep_start(1)] b[i]가 널 문자('\\0')가 아닐 동안 반복하세요.\n54. a[i]에 b[i]를 저장하세요.\n55. i를 1 증가시키세요.\n56. [rep_end(1)]\n57. a[i]에 널 문자('\\0')를 설정하세요.\n58. i를 0으로 초기화하세요.\n59. [rep_start(1)] temp[i]가 널 문자('\\0')가 아닐 동안 반복하세요.\n60. b[i]에 temp[i]를 저장하세요.\n61. i를 1 증가시키세요.\n62. [rep_end(1)]\n63. b[i]에 널 문자('\\0')를 설정하세요.\n64. [func_def_end(1)]\n\n65. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n66. int형 변수 n을 선언하세요.\n67. char형 2차원 배열 serials[50][51]을 선언하세요.\n68. int형 변수 i와 j를 선언하세요.\n69. n에 값을 입력받으세요.\n70. [rep_start(1)] i를 0으로 초기화하고 n만큼 반복하는 for 루프를 만드세요.\n71. serials[i]에 문자열을 입력받으세요.\n72. [rep_end(1)]\n73. [rep_start(1)] i를 0으로 초기화하고 n-1만큼 반복하는 for 루프를 만드세요.\n74. [rep_start(2)] j를 i+1로 초기화하고 n만큼 반복하는 for 루프를 만드세요.\n75. [cond_start(2)] compare 함수의 결과가 0보다 큰지 확인하는 조건문을 작성하세요.\n76. 결과가 0보다 크다면 swap 함수를 통해 serials[i]와 serials[j]를 교환하세요.\n77. [cond_end(2)]\n78. [rep_end(2)]\n79. [rep_end(1)]\n80. [rep_start(1)] i를 0으로 초기화하고 n만큼 반복하는 for 루프를 만드세요.\n81. serials[i]를 출력하세요.\n82. [rep_end(1)]\n83. return 0;으로 프로그램을 종료하세요.\n84. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nvoid sort(int arr[], int n) {\n    int i, j, temp;\n    for (i = 0; i < n - 1; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int n, l;\n    int leak[1000];\n    int i, count = 0;\n    int tape_end = 0;\n\n    scanf(\"%d %d\", &n, &l);\n\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &leak[i]);\n    }\n\n    sort(leak, n);\n\n    for (i = 0; i < n; i++) {\n        if (leak[i] <= tape_end) {\n            continue;\n        }\n        tape_end = leak[i] + l - 1;\n        count++;\n    }\n\n    printf(\"%d\n\", count);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] void 반환형 함수를 정의하고, 매개변수로 int형 배열 arr와 정수 n을 받습니다.\n2. int형 변수 i, j, temp를 선언합니다.\n3. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성합니다.\n4. [rep_start(2)] j를 i+1부터 n까지 반복하는 for 루프를 작성합니다.\n5. [cond_start(3)] arr[i]가 arr[j]보다 큰지 확인하는 조건문을 작성합니다.\n6. arr[i]가 arr[j]보다 크면, temp에 arr[i]를 저장합니다.\n7. arr[i]에 arr[j] 값을 할당합니다.\n8. arr[j]에 temp 값을 할당합니다.\n9. [cond_end(3)]\n10. [rep_end(2)]\n11. [rep_end(1)]\n12. [func_def_end(1)]\n13. [func_def_start(1)] int 반환형 main 함수를 정의하고, 매개변수는 없습니다.\n14. 정수형 변수 n, l을 선언합니다.\n15. 길이가 1000인 int형 배열 leak을 선언합니다.\n16. 정수형 변수 i와 count를 0으로 초기화합니다.\n17. 정수형 tape_end를 0으로 초기화합니다.\n18. n과 l에 대한 입력을 받습니다.\n19. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성합니다.\n20. leaking[i]에 정수를 입력받습니다.\n21. [rep_end(1)]\n22. sort 함수를 호출하여 leak 배열을 정렬합니다.\n23. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성합니다.\n24. [cond_start(2)] leak[i]가 tape_end 이하인지를 확인하는 조건문을 작성합니다.\n25. leak[i]가 tape_end 이하라면 continue로 다음 반복으로 넘어갑니다.\n26. tape_end에 leak[i] + l - 1 값을 할당합니다.\n27. count를 증가시킵니다.\n28. [cond_end(2)]\n29. [rep_end(1)]\n30. count를 출력합니다.\n31. return 0;으로 프로그램을 종료합니다.\n32. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\ntypedef struct {\n    int value;\n    int index;\n} Element;\n\nvoid swap(Element *a, Element *b) {\n    Element temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid sort(Element arr[], int n) {\n    int i, j;\n    for (i = 0; i < n - 1; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (arr[i].value > arr[j].value) {\n                swap(&arr[i], &arr[j]);\n            }\n            else if (arr[i].value == arr[j].value && arr[i].index > arr[j].index) {\n                swap(&arr[i], &arr[j]);\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    int i;\n    int P[50];\n    Element A[50];\n\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++) {\n        scanf(\"%d\", &A[i].value);\n        A[i].index = i;\n    }\n\n    sort(A, n);\n\n    for (i = 0; i < n; i++) {\n        P[A[i].index] = i;\n    }\n\n    for (i = 0; i < n; i++) {\n        printf(\"%d \", P[i]);\n    }\n\n    printf(\"\n\");\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [struct_start(1)] `Element`이라는 구조체를 정의하여 두 개의 정수형 멤버 `value`와 `index`를 가집니다.\n2. [struct_end(1)]\n3. [func_def_start(1)] `void` 반환형의 `swap` 함수를 정의합니다. (매개변수: `Element *a`, `Element *b`)\n4. `Element temp`라는 임시 변수를 선언하여 `a`의 값을 저장합니다.\n5. `a`에 `b`의 값을 대입합니다.\n6. `b`에 `temp`의 값을 대입하여 두 값을 교환합니다.\n7. [func_def_end(1)]\n8. [func_def_start(1)] `void` 반환형의 `sort` 함수를 정의합니다. (매개변수: `Element arr[]`, `int n`)\n9. 정수형 변수 `i`와 `j`를 선언합니다.\n10. [rep_start(1)] `i`를 선언해 0부터 `n-1`까지 반복하는 for 루프를 작성합니다.\n11. [rep_start(2)] `j`를 선언해 `i+1`부터 `n`까지 반복하는 for 루프를 작성합니다.\n12. [cond_start(2)] `arr[i].value`가 `arr[j].value`보다 큰지를 확인하는 조건문을 작성합니다.\n13. 크면 `swap` 함수를 호출하여 `arr[i]`와 `arr[j]`를 교환합니다.\n14. [cond_end(2)]\n15. [cond_start(2)] `arr[i].value`가 `arr[j].value`와 같고, `arr[i].index`가 `arr[j].index`보다 큰지를 확인하는 조건문을 작성합니다.\n16. 크면 `swap` 함수를 호출하여 `arr[i]`와 `arr[j]`를 교환합니다.\n17. [cond_end(2)]\n18. [rep_end(2)]\n19. [rep_end(1)]\n20. [func_def_end(1)]\n21. [func_def_start(1)] `int` 반환형의 `main` 함수를 정의합니다. (매개변수 없음)\n22. 정수형 변수 `n`과 `i`를 선언합니다.\n23. 정수형 배열 `P[50]`과 `Element A[50]`를 선언합니다.\n24. 사용자로부터 `n`을 입력받습니다.\n25. [rep_start(1)] `i`를 선언해 0부터 `n-1`까지 반복하는 for 루프를 작성합니다.\n26. 배열 `A`의 `i`번째 요소의 `value`를 입력받습니다.\n27. `A[i].index`에 현재 인덱스 `i`를 저장합니다.\n28. [rep_end(1)]\n29. `sort` 함수를 호출하여 배열 `A`를 정렬합니다.\n30. [rep_start(1)] `i`를 선언해 0부터 `n-1`까지 반복하는 for 루프를 작성합니다.\n31. 배열 `P`의 `A[i].index`에 현재의 인덱스 `i`를 대입합니다.\n32. [rep_end(1)]\n33. [rep_start(1)] `i`를 선언해 0부터 `n-1`까지 반복하는 for 루프를 작성합니다.\n34. 배열 `P[i]`의 값을 출력합니다.\n35. [rep_end(1)]\n36. 한 줄을 출력하여 출력 포맷을 맞춥니다.\n37. `return 0;`으로 프로그램을 종료합니다.\n38. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nchar board[50][51];\n\nint min(int a, int b) {\n    if (a < b) {\n        return a;\n    }\n    return b;\n}\n\nint count_repaint(int x, int y) {\n    int i, j;\n    int repaint_w = 0;\n    int repaint_b = 0;\n\n    for (i = 0; i < 8; i++) {\n        for (j = 0; j < 8; j++) {\n            if (((i + j) % 2 == 0 && board[x + i][y + j] != 'W') ||\n                ((i + j) % 2 == 1 && board[x + i][y + j] != 'B')) {\n                repaint_w++;\n            }\n            if (((i + j) % 2 == 0 && board[x + i][y + j] != 'B') ||\n                ((i + j) % 2 == 1 && board[x + i][y + j] != 'W')) {\n                repaint_b++;\n            }\n        }\n    }\n\n    return min(repaint_w, repaint_b);\n}\n\nint main() {\n    int n, m;\n    int i, j;\n    int min_repaint = 64;\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (i = 0; i < n; i++) {\n        scanf(\"%s\", board[i]);\n    }\n\n    for (i = 0; i <= n - 8; i++) {\n        for (j = 0; j <= m - 8; j++) {\n            int repaint = count_repaint(i, j);\n            if (repaint < min_repaint) {\n                min_repaint = repaint;\n            }\n        }\n    }\n\n    printf(\"%d\n\", min_repaint);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] char 배열 board를 선언하여 50x51 크기의 바둑판을 정의하세요.\n2. [func_def_start(1)] int 반환형 함수 min을 정의하세요. (매개변수: int a, int b)\n3. [cond_start(1)] a가 b보다 작은지 확인하는 조건문을 작성하세요.\n4. a가 b보다 작으면 a를 반환하세요.\n5. [cond_end(1)]\n6. b를 반환하세요.\n7. [func_def_end(1)]\n8. [func_def_start(1)] int 반환형 함수 count_repaint을 정의하세요. (매개변수: int x, int y)\n9. int형 변수 i, j를 선언하세요.\n10. int형 변수 repaint_w를 0으로 초기화하세요.\n11. int형 변수 repaint_b를 0으로 초기화하세요.\n12. [rep_start(1)] i를 0부터 7까지 반복하는 for 루프를 작성하세요.\n13. [rep_start(2)] j를 0부터 7까지 반복하는 for 루프를 작성하세요.\n14. [cond_start(3)] (i + j) 가 짝수인지 확인하는 조건문을 작성하세요.\n15. 짝수인 경우 board[x + i][y + j]가 'W'가 아닌지 확인하세요.\n16. 조건을 만족하면 repaint_w를 증가시킵니다.\n17. [cond_end(3)]\n18. [cond_start(3)] (i + j) 가 홀수인지 확인하는 조건문을 작성하세요.\n19. 홀수인 경우 board[x + i][y + j]가 'B'가 아닌지 확인하세요.\n20. 조건을 만족하면 repaint_w를 증가시킵니다.\n21. [cond_end(3)]\n22. [rep_end(2)]\n23. [rep_start(1)] i + j가 짝수인지 확인하는 조건문을 작성하세요.\n24. 짝수인 경우 board[x + i][y + j]가 'B'가 아닌지 확인하세요.\n25. 조건을 만족하면 repaint_b를 증가시킵니다.\n26. [cond_end(3)]\n27. [cond_start(3)] (i + j) 가 홀수인지 확인하는 조건문을 작성하세요.\n28. 홀수인 경우 board[x + i][y + j]가 'W'가 아닌지 확인하세요.\n29. 조건을 만족하면 repaint_b를 증가시킵니다.\n30. [cond_end(3)]\n31. [rep_end(1)]\n32. repaint_w와 repaint_b 중 최소값을 반환하세요.\n33. [func_def_end(1)]\n34. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n35. int형 변수 n, m을 선언하세요.\n36. int형 변수 i, j를 선언하세요.\n37. int형 변수 min_repaint를 64로 초기화하세요.\n38. n과 m을 입력 받으세요.\n39. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n40. board[i]에 문자열을 입력 받으세요.\n41. [rep_end(1)]\n42. [rep_start(1)] i를 0부터 n-8까지 반복하는 for 루프를 작성하세요.\n43. [rep_start(2)] j를 0부터 m-8까지 반복하는 for 루프를 작성하세요.\n44. count_repaint 함수로 repaint를 계산하세요.\n45. [cond_start(2)] repaint가 min_repaint보다 작은지 확인하는 조건문을 작성하세요.\n46. min_repaint를 repaint로 업데이트하세요.\n47. [cond_end(2)]\n48. [rep_end(2)]\n49. min_repaint를 출력하세요.\n50. return 0;으로 프로그램을 종료하세요.\n51. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint min(int a, int b) {\n    if (a < b) {\n        return a;\n    }\n    return b;\n}\n\nint main() {\n    int n, m;\n    int i;\n    int package_min = 1001;\n    int single_min = 1001;\n    int result;\n\n    scanf(\"%d %d\", &n, &m);\n\n    for (i = 0; i < m; i++) {\n        int pkg, single;\n        scanf(\"%d %d\", &pkg, &single);\n        if (pkg < package_min) {\n            package_min = pkg;\n        }\n        if (single < single_min) {\n            single_min = single;\n        }\n    }\n\n    if (single_min * 6 <= package_min) {\n        result = single_min * n;\n    }\n    else {\n        result = (n / 6) * package_min;\n        if ((n % 6) * single_min <= package_min) {\n            result += (n % 6) * single_min;\n        }\n        else {\n            result += package_min;\n        }\n    }\n\n    printf(\"%d\n\", result);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 min 함수를 정의하세요. (매개변수: int a, int b)\n2. [cond_start(1)] a가 b보다 작은지 확인하는 조건문을 작성하세요.\n3. a가 b보다 작으면 a를 반환하세요.\n4. [cond_end(1)]\n5. b를 반환하세요.\n6. [func_def_end(1)]\n7. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n8. 정수형 변수 n, m 및 i를 선언하세요.\n9. int형 변수 package_min을 1001로 초기화하세요.\n10. int형 변수 single_min을 1001로 초기화하세요.\n11. int형 변수 result를 선언하세요.\n12. n과 m에 대한 입력을 받으세요.\n13. [rep_start(1)] i를 0부터 m-1까지 반복하는 for 루프를 작성하세요.\n14. int형 변수 pkg와 single을 선언하세요.\n15. pkg와 single의 값을 입력받으세요.\n16. [cond_start(2)] pkg가 package_min보다 작은지 확인하는 조건문을 작성하세요.\n17. pkg가 더 작으면 package_min의 값을 pkg로 업데이트하세요.\n18. [cond_end(2)]\n19. [cond_start(2)] single이 single_min보다 작은지 확인하는 조건문을 작성하세요.\n20. single이 더 작으면 single_min의 값을 single로 업데이트하세요.\n21. [cond_end(2)]\n22. [rep_end(1)]\n23. [cond_start(1)] single_min의 6배가 package_min보다 작거나 같은지 확인하는 조건문을 작성하세요.\n24. 조건이 참이면 result에 single_min과 n을 곱한 값을 저장하세요.\n25. [cond_end(1)]\n26. [cond_start(1)] 그렇지 않은 경우를 처리하는 조건문을 작성하세요.\n27. result에 n을 6으로 나눈 몫에 package_min을 곱한 값을 저장하세요.\n28. [cond_start(2)] n이 6으로 나눈 나머지에 single_min을 곱한 값이 package_min보다 작거나 같은지 확인하세요.\n29. 조건이 참이면 result에 (n % 6)과 single_min을 곱한 값을 더하세요.\n30. [cond_end(2)]\n31. [cond_end(1)]\n32. result에 package_min을 더하세요.\n33. [cond_end(1)]\n34. result를 출력하세요.\n35. return 0;으로 프로그램을 종료하세요.\n36. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, a, b;\n    int round = 0;\n\n    scanf(\"%d %d %d\", &n, &a, &b);\n\n    while (a != b) {\n        a = (a + 1) / 2;\n        b = (b + 1) / 2;\n        round++;\n    }\n\n    printf(\"%d\n\", round);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n, a, b를 선언하세요.\n3. int형 변수 round를 0으로 초기화하세요.\n4. n, a, b에 입력을 받으세요.\n5. [rep_start(1)] a와 b가 다를 때까지 반복하는 while 루프를 작성하세요.\n6. a를 (a + 1) / 2로 업데이트하세요.\n7. b를 (b + 1) / 2로 업데이트하세요.\n8. round 값을 1 증가시키세요.\n9. [rep_end(1)]\n10. round 값을 출력하세요.\n11. return 0;으로 프로그램을 종료하세요.\n12. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int l, n, i;\n    int s[51];\n    int low = 0;\n    int high = 1001;\n    int count = 0;\n\n    scanf(\"%d\", &l);\n\n    for (i = 0; i < l; i++) {\n        scanf(\"%d\", &s[i]);\n    }\n\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < l; i++) {\n        if (s[i] == n) {\n            printf(\"0\n\");\n            return 0;\n        }\n        if (s[i] < n && s[i] > low) {\n            low = s[i];\n        }\n        if (s[i] > n && s[i] < high) {\n            high = s[i];\n        }\n    }\n\n    count = (n - low) * (high - n) - 1;\n\n    printf(\"%d\n\", count);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 l, n, i를 선언하세요.\n3. 정수형 배열 s를 크기 51로 선언하세요.\n4. int형 변수 low를 0으로 초기화하세요.\n5. int형 변수 high를 1001로 초기화하세요.\n6. int형 변수 count를 0으로 초기화하세요.\n7. l의 값을 입력받으세요.\n8. [rep_start(1)] i를 0부터 l-1까지 반복하는 for 루프를 작성하세요.\n9. s 배열의 i 번째 인덱스에 입력을 받으세요.\n10. [rep_end(1)]\n11. n의 값을 입력받으세요.\n12. [rep_start(1)] i를 0부터 l-1까지 반복하는 for 루프를 작성하세요.\n13. [cond_start(2)] s 배열의 i 번째 값이 n과 같은지 확인하는 조건문을 작성하세요.\n14. s[i]가 n과 같다면 0을 출력하고 프로그램을 종료하세요.\n15. [cond_end(2)]\n16. [cond_start(2)] s 배열의 i 번째 값이 n보다 작고 low보다 큰지 확인하는 조건문을 작성하세요.\n17. 조건이 참이라면 low를 s[i]로 업데이트하세요.\n18. [cond_end(2)]\n19. [cond_start(2)] s 배열의 i 번째 값이 n보다 크고 high보다 작은지 확인하는 조건문을 작성하세요.\n20. 조건이 참이라면 high를 s[i]로 업데이트하세요.\n21. [cond_end(2)]\n22. [rep_end(1)]\n23. count를 (n - low) * (high - n) - 1로 계산하세요.\n24. count의 값을 출력하세요.\n25. return 0;으로 프로그램을 종료하세요.\n26. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i, count = 0;\n    scanf(\"%d\", &n);\n\n    for (i = 1; i <= n; i++) {\n        if (i < 100) {\n            count++;\n        }\n        else {\n            int a = i / 100;\n            int b = (i / 10) % 10;\n            int c = i % 10;\n\n            if ((a - b) == (b - c)) {\n                count++;\n            }\n        }\n    }\n\n    printf(\"%d\n\", count);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n, i와 0으로 초기화된 count 변수를 선언하세요.\n3. n에 대한 입력을 받으세요.\n4. [rep_start(1)] i를 선언하여 1부터 n까지 반복하는 for 루프를 작성하세요.\n5. [cond_start(2)] i가 100보다 작은지 확인하는 조건문을 작성하세요.\n6. i가 100보다 작다면 count를 1 증가시키세요.\n7. [cond_end(2)]\n8. [cond_start(2)] 그렇지 않으면 (i가 100 이상인 경우) 각 자리 숫자를 구분합니다.\n9. a는 i의 백의 자리를, b는 i의 십의 자리를, c는 i의 일의 자리를 저장하세요.\n10. [cond_start(3)] a와 b의 차이가 b와 c의 차이와 같은지 확인하는 조건문을 작성하세요.\n11. 같다면 count를 1 증가시키세요.\n12. [cond_end(3)]\n13. [cond_end(2)]\n14. [rep_end(1)]\n15. count의 값을 출력하세요.\n16. return 0;으로 프로그램을 종료하세요.\n17. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, K;\n    int people[5000];\n    int result[5000];\n    int i, count = 0, index = 0, pos = 0;\n\n    scanf(\"%d %d\", &N, &K);\n\n    for(i = 0; i < N; i++) {\n        people[i] = i + 1;\n    }\n\n    while(count < N) {\n        int step = 0;\n\n        while(step < K) {\n            if(people[pos] != 0) {\n                step = step + 1;\n            }\n\n            if(step == K) {\n                break;\n            }\n\n            pos = pos + 1;\n\n            if(pos == N) {\n                pos = 0;\n            }\n        }\n\n        result[index] = people[pos];\n        people[pos] = 0;\n        count = count + 1;\n        index = index + 1;\n\n        pos = pos + 1;\n\n        if(pos == N) {\n            pos = 0;\n        }\n    }\n\n    printf(\"<\");\n\n    for(i = 0; i < N; i++) {\n        printf(\"%d\", result[i]);\n\n        if(i != N - 1) {\n            printf(\", \");\n        }\n    }\n\n    printf(\">\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N과 K를 선언하세요.\n3. 크기가 5000인 int형 배열 people을 선언하세요.\n4. 크기가 5000인 int형 배열 result를 선언하세요.\n5. 정수형 변수 i, count(0으로 초기화), index(0으로 초기화), pos(0으로 초기화)를 선언하세요.\n6. N과 K의 값을 입력받으세요.\n7. [rep_start(1)] i를 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n8. people 배열의 i번째 요소에 i+1 값을 저장하세요.\n9. [rep_end(1)]\n10. [rep_start(1)] count가 N보다 작을 때까지 반복하는 while 루프를 작성하세요.\n11. step 변수를 0으로 초기화하세요.\n12. [rep_start(2)] step이 K보다 작을 때까지 반복하는 while 루프를 작성하세요.\n13. [cond_start(3)] people 배열의 pos 위치에 값이 0이 아닌지 확인하는 조건문을 작성하세요.\n14. 값이 0이 아니면 step을 1 증가시키세요.\n15. [cond_end(3)]\n16. [cond_start(4)] step이 K와 같아지면 반복을 종료하는 조건문을 작성하세요.\n17. K에 도달하면 break를 실행하세요.\n18. [cond_end(4)]\n19. pos를 1 증가시키세요.\n20. [cond_start(5)] pos가 N과 같아지면 pos를 0으로 재설정하세요.\n21. [cond_end(5)]\n22. [rep_end(2)]\n23. result 배열의 index 위치에 people 배열의 pos 값을 저장하세요.\n24. people 배열의 pos 값을 0으로 설정하세요.\n25. count를 1 증가시키세요.\n26. index를 1 증가시키세요.\n27. pos를 1 증가시키세요.\n28. [cond_start(6)] pos가 N과 같아지면 pos를 0으로 재설정하세요.\n29. [cond_end(6)]\n30. [rep_end(1)]\n31. \"<\"를 출력하세요.\n32. [rep_start(1)] i를 0부터 N-1까지 반복하면서 result 배열의 요소를 출력하는 for 루프를 작성하세요.\n33. result 배열의 i번째 요소를 출력하세요.\n34. [cond_start(7)] i가 N-1이 아닐 경우 ','와 공백을 출력하는 조건문을 작성하세요.\n35. i가 N-1이 아니면 \", \"을 출력하세요.\n36. [cond_end(7)]\n37. [rep_end(1)]\n38. \">\"를 출력하세요.\n39. 줄바꿈 후 출력하세요.\n40. return 0;으로 프로그램을 종료하세요.\n41. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, score, P;\n    int rank[51];\n    int i, position = 1, count = 0;\n\n    scanf(\"%d %d %d\", &N, &score, &P);\n\n    for(i = 0; i < N; i++) {\n        scanf(\"%d\", &rank[i]);\n    }\n\n    if(N == 0) {\n        printf(\"1\n\");\n        return 0;\n    }\n\n    for(i = 0; i < N; i++) {\n        if(score < rank[i]) {\n            position = position + 1;\n        }\n        else if(score == rank[i]) {\n            position = position;\n        }\n        else {\n            break;\n        }\n    }\n\n    if(N == P && score <= rank[N - 1]) {\n        printf(\"-1\n\");\n    }\n    else {\n        printf(\"%d\n\", position);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N, score, P를 선언하세요.\n3. 순위 저장을 위한 정수형 배열 rank를 크기 51로 선언하세요.\n4. 정수형 변수 i, position을 1로 초기화하고, count를 0으로 초기화하세요.\n5. N, score, P의 입력을 받으세요.\n6. [rep_start(1)] i를 0부터 N-1까지 반복하여 순위를 입력받는 for 루프를 작성하세요.\n7. rank[i]에 점수를 입력받으세요.\n8. [rep_end(1)]\n9. [cond_start(1)] N이 0인지 확인하는 조건문을 작성하세요.\n10. N이 0이면 1을 출력하세요.\n11. 프로그램을 종료하기 위해 return 0을 수행하세요.\n12. [cond_end(1)]\n13. [rep_start(1)] i를 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n14. [cond_start(2)] score가 rank[i]보다 작은지 확인하는 조건문을 작성하세요.\n15. score가 rank[i]보다 작으면 position을 1 증가시키세요.\n16. [cond_end(2)]\n17. [cond_start(2)] score가 rank[i]와 같은지 확인하는 조건문을 작성하세요.\n18. score가 rank[i]와 같으면 position을 각기 유지하세요.\n19. [cond_end(2)]\n20. score가 rank[i]보다 크면 반복문을 종료하세요.\n21. [rep_end(1)]\n22. [cond_start(1)] N이 P와 같고 score가 rank[N-1]보다 작거나 같은지 확인하는 조건문을 작성하세요.\n23. 조건이 참이면 -1을 출력하세요.\n24. [cond_end(1)]\n25. 그렇지 않으면 position을 출력하세요.\n26. return 0;으로 프로그램을 종료하세요.\n27. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char numbers[1000][101];\n    int N;\n    int i, j, k, length = 0, unique;\n\n    scanf(\"%d\", &N);\n\n    for(i = 0; i < N; i++) {\n        scanf(\"%s\", numbers[i]);\n    }\n\n    while(numbers[0][length] != '\u0000') {\n        length = length + 1;\n    }\n\n    for(k = 1; k <= length; k++) {\n        unique = 1;\n\n        for(i = 0; i < N - 1; i++) {\n            for(j = i + 1; j < N; j++) {\n                int same = 1;\n                int a, start = length - k;\n\n                for(a = 0; a < k; a++) {\n                    if(numbers[i][start + a] != numbers[j][start + a]) {\n                        same = 0;\n                        break;\n                    }\n                }\n\n                if(same == 1) {\n                    unique = 0;\n                }\n            }\n        }\n\n        if(unique == 1) {\n            printf(\"%d\n\", k);\n            break;\n        }\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 2차원 배열 numbers를 선언하여 최대 1000개의 문자열(각각 101자) 저장을 준비하세요.\n3. 정수형 변수 N을 선언하여 입력 받을 문자열 개수를 저장할 준비를 하세요.\n4. 정수형 변수 i, j, k와 length(문자열 길이)를 0으로 초기화한 변수 length를 선언하세요.\n5. 정수형 변수 unique를 선언하여 고유성 여부를 체크할 준비를 하세요.\n6. N을 입력받아 몇 개의 문자열을 읽어들일지 지정하세요.\n7. [rep_start(1)] i를 0부터 N-1까지 반복하여 문자열을 입력받는 for 루프를 작성하세요.\n8. 각 반복에서 numbers[i]에 문자열을 입력받으세요.\n9. [rep_end(1)]\n10. [rep_start(1)] numbers[0]의 길이를 구하기 위해 length를 계산하는 while 루프를 시작하세요.\n11. numbers[0][length]가 NULL이 아닐 경우 length를 1 증가시키세요.\n12. [rep_end(1)]\n13. [rep_start(1)] k를 1부터 length까지 반복하는 for 루프를 시작하세요.\n14. unique 변수를 1로 초기화하여 현재 k 길이를 가진 부분 문자열의 고유성을 가정하세요.\n15. [rep_start(2)] i를 0부터 N-2까지 반복하는 for 루프를 시작하세요.\n16. [rep_start(3)] j를 i+1부터 N-1까지 반복하는 for 루프를 시작하세요.\n17. int형 변수 same을 1로 초기화하여 동일성 여부를 가정하세요.\n18. 정수형 변수 a와 start를 선언하고, start를 length - k로 초기화하세요.\n19. [rep_start(4)] a를 0부터 k-1까지 반복하는 for 루프를 시작하세요.\n20. numbers[i][start + a]와 numbers[j][start + a]가 다르면 same을 0으로 설정하고 반복문을 종료하세요.\n21. [rep_end(4)]\n22. [cond_start(3)] same이 1이라면 고유성이 없는 것을 확인하세요.\n23. unique를 0으로 설정하세요.\n24. [cond_end(3)]\n25. [rep_end(3)]\n26. [rep_end(2)]\n27. [cond_start(2)] unique가 1이라면 현재 k 값을 출력하세요.\n28. k를 출력하고 반복을 종료하세요.\n29. [cond_end(2)]\n30. [rep_end(1)]\n31. return 0;으로 프로그램을 종료하세요.\n32. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, M;\n    int price[1000];\n    int i, j, temp;\n    int max_profit = 0;\n    int best_price = 0;\n\n    scanf(\"%d %d\", &N, &M);\n\n    for(i = 0; i < M; i++) {\n        scanf(\"%d\", &price[i]);\n    }\n\n    for(i = 0; i < M - 1; i++) {\n        for(j = i + 1; j < M; j++) {\n            if(price[i] > price[j]) {\n                temp = price[i];\n                price[i] = price[j];\n                price[j] = temp;\n            }\n        }\n    }\n\n    for(i = 0; i < M; i++) {\n        int count = M - i;\n\n        if(count > N) {\n            count = N;\n        }\n\n        if(price[i] * count > max_profit) {\n            max_profit = price[i] * count;\n            best_price = price[i];\n        }\n    }\n\n    printf(\"%d %d\n\", best_price, max_profit);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N과 M을 선언하세요.\n3. 정수형 배열 price[1000]을 선언하여 최대 1000개의 가격을 저장할 수 있게 합니다.\n4. 정수형 변수 i, j, temp를 선언하여 반복문 및 정렬에 사용할 임시 변수를 준비합니다.\n5. 최대 이익을 저장할 정수형 변수 max_profit을 0으로 초기화합니다.\n6. 최적의 가격을 저장할 정수형 변수 best_price를 0으로 초기화합니다.\n7. N과 M에 대한 입력을 받으세요.\n8. [rep_start(1)] i를 사용하여 0부터 M-1까지 반복하는 for 루프를 작성하세요.\n9. price 배열에 각각의 가격을 입력받아 저장하세요.\n10. [rep_end(1)]\n11. [rep_start(1)] i를 사용하여 0부터 M-2까지 반복하는 for 루프를 작성하세요.\n12. [rep_start(2)] j를 사용하여 i+1부터 M-1까지 반복하는 for 루프를 작성하세요.\n13. [cond_start(2)] price[i]가 price[j]보다 큰지 확인하는 조건문을 작성하세요.\n14. price[i]가 price[j]보다 크면 두 값을 교환하세요.\n15. [cond_end(2)]\n16. [rep_end(2)]\n17. [rep_end(1)]\n18. [rep_start(1)] i를 사용하여 0부터 M-1까지 반복하는 for 루프를 작성하세요.\n19. 소유한 물건의 수를 count로 계산하고, 이를 M에서 i를 빼서 구하세요.\n20. [cond_start(2)] count가 N보다 큰지 확인하는 조건문을 작성하세요.\n21. count가 N보다 크면 count를 N으로 설정하세요.\n22. [cond_end(2)]\n23. [cond_start(2)] price[i] * count가 max_profit보다 큰지 확인하는 조건문을 작성하세요.\n24. max_profit을 price[i] * count로 업데이트하고, best_price를 price[i]로 설정하세요.\n25. [cond_end(2)]\n26. [rep_end(1)]\n27. best_price와 max_profit을 출력하세요.\n28. return 0;으로 프로그램을 종료하세요.\n29. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int T;\n    int i, j, n, m;\n    int dp[30][30];\n\n    for(i = 0; i < 30; i++) {\n        for(j = 0; j <= i; j++) {\n            if(j == 0 || j == i) {\n                dp[i][j] = 1;\n            }\n            else {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            }\n        }\n    }\n\n    scanf(\"%d\", &T);\n\n    for(i = 0; i < T; i++) {\n        scanf(\"%d %d\", &n, &m);\n        printf(\"%d\n\", dp[m][n]);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 T를 선언하세요.\n3. 정수형 변수 i, j, n, m을 선언하세요.\n4. 30x30 크기의 2D 배열 dp를 선언하세요.\n5. [rep_start(1)] i를 선언해 0부터 29까지 반복하는 for 루프를 작성하세요.\n6. [rep_start(2)] j를 선언해 0부터 i까지 반복하는 for 루프를 작성하세요.\n7. [cond_start(3)] j가 0이거나 j가 i와 같은지 확인하는 조건문을 작성하세요.\n8. j가 0이거나 j가 i라면 dp[i][j]에 1을 저장하세요.\n9. [cond_end(3)]\n10. [cond_start(3)] j가 0이나 i가 아닐 경우의 처리입니다. dp[i][j]에 이전 계산 값을 더하여 저장하세요. \n11. dp[i][j]에 dp[i - 1][j - 1]와 dp[i - 1][j]의 합을 저장하세요.\n12. [cond_end(3)]\n13. [rep_end(2)]\n14. [rep_end(1)]\n15. T에 대한 입력을 받으세요.\n16. [rep_start(1)] i를 선언해 0부터 T-1까지 반복하는 for 루프를 작성하세요.\n17. n과 m에 대한 입력을 받으세요.\n18. dp[m][n]의 값을 출력하세요.\n19. [rep_end(1)]\n20. return 0;으로 프로그램을 종료하세요.\n21. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int X;\n    int count = 0;\n\n    scanf(\"%d\", &X);\n\n    while(X > 0) {\n        if((X % 2) == 1) {\n            count = count + 1;\n        }\n\n        X = X / 2;\n    }\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 X를 선언하세요.\n3. 소수의 개수를 저장할 int형 변수 count를 0으로 초기화하세요.\n4. X에 대한 입력을 받으세요.\n5. [rep_start(1)] X가 0보다 큰 동안 반복하는 while 루프를 작성하세요.\n6. [cond_start(2)] X가 홀수인지 확인하는 조건문을 작성하세요.\n7. X가 홀수라면 count에 1을 더하세요.\n8. [cond_end(2)]\n9. X를 2로 나누어 반으로 줄이세요.\n10. [rep_end(1)]\n11. count 값을 출력하세요.\n12. return 0;으로 프로그램을 종료하세요.\n13. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char word[51];\n    char result[51];\n    char temp[51];\n    int i, j, k, l;\n    int len = 0;\n\n    scanf(\"%s\", word);\n\n    while(word[len] != '\u0000') {\n        len = len + 1;\n    }\n\n    for(i = 1; i < len - 1; i++) {\n        for(j = i + 1; j < len; j++) {\n            int index = 0;\n\n            for(k = i - 1; k >= 0; k--) {\n                temp[index] = word[k];\n                index = index + 1;\n            }\n\n            for(k = j - 1; k >= i; k--) {\n                temp[index] = word[k];\n                index = index + 1;\n            }\n\n            for(k = len - 1; k >= j; k--) {\n                temp[index] = word[k];\n                index = index + 1;\n            }\n\n            temp[index] = '\u0000';\n\n            if(i == 1 && j == 2) {\n                k = 0;\n                while(temp[k] != '\u0000') {\n                    result[k] = temp[k];\n                    k = k + 1;\n                }\n                result[k] = '\u0000';\n            }\n            else {\n                k = 0;\n                while(temp[k] != '\u0000') {\n                    if(temp[k] < result[k]) {\n                        l = 0;\n                        while(temp[l] != '\u0000') {\n                            result[l] = temp[l];\n                            l = l + 1;\n                        }\n                        result[l] = '\u0000';\n                        break;\n                    }\n                    else if(temp[k] > result[k]) {\n                        break;\n                    }\n                    k = k + 1;\n                }\n            }\n        }\n    }\n\n    printf(\"%s\n\", result);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 배열 word를 선언하여 최대 50자의 입력을 받을 수 있도록 합니다.\n3. char형 배열 result를 선언하여 결과를 저장합니다.\n4. char형 배열 temp를 선언하여 임시로 문자열을 저장합니다.\n5. int형 변수 i, j, k, l를 선언합니다.\n6. 소스 문자열의 길이를 저장할 int형 변수 len을 0으로 초기화합니다.\n\n7. word 배열에 문자열을 입력받습니다.\n8. [rep_start(1)] word의 null 문자('\\0')를 찾도록 반복하는 while 루프를 작성합니다.\n9. word의 각 문자에 대해 len을 1씩 증가시킵니다.\n10. [rep_end(1)]\n\n11. [rep_start(1)] i를 1로 초기화하여 len-1까지 반복하는 for 루프를 작성합니다.\n12. [rep_start(2)] j를 i+1로 초기화하여 len까지 반복하는 for 루프를 작성합니다.\n13. int형 변수 index를 0으로 초기화합니다.\n\n14. [rep_start(3)] k를 i-1로 초기화하여 0까지 반복하는 for 루프를 작성합니다.\n15. word의 i-1 이전의 문자를 temp 배열에 저장합니다.\n16. index를 1 증가시킵니다.\n17. [rep_end(3)]\n\n18. [rep_start(3)] k를 j-1로 초기화하여 i까지 반복하는 for 루프를 작성합니다.\n19. word의 j-1부터 i까지의 문자를 temp 배열에 저장합니다.\n20. index를 1 증가시킵니다.\n21. [rep_end(3)]\n\n22. [rep_start(3)] k를 len-1로 초기화하여 j까지 반복하는 for 루프를 작성합니다.\n23. word의 j부터 len까지의 문자를 temp 배열에 저장합니다.\n24. index를 1 증가시킵니다.\n25. [rep_end(3)]\n\n26. temp의 마지막에 null 문자('\\0')를 저장합니다.\n\n27. [cond_start(1)] i가 1이고 j가 2인지 확인하는 조건문을 작성합니다.\n28. temp를 result에 복사하여 초기값으로 설정합니다.\n29. [cond_end(1)]\n\n30. [cond_start(1)] i가 1이 아니거나 j가 2가 아닌 경우를 처리합니다.\n31. [rep_start(4)] temp의 각 문자를 비교하는 while 루프를 작성합니다.\n32. [cond_start(2)] temp의 k번째 문자가 result의 k번째 문자보다 작은지 확인하는 조건문을 작성합니다.\n33. temp를 result에 복사합니다.\n34. [cond_end(2)]\n35. [cond_start(2)] temp의 k번째 문자가 result의 k번째 문자보다 큰지 확인하는 조건문을 작성합니다.\n36. 루프를 종료합니다.\n37. [cond_end(2)]\n38. k를 1 증가시킵니다.\n39. [rep_end(4)]\n40. [rep_end(2)]\n41. [rep_end(1)]\n\n42. result를 출력합니다.\n43. return 0;으로 프로그램을 종료하세요.\n44. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int student[1000][5];\n    int i, j, k, l;\n    int max = 0;\n    int leader = 0;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i = i + 1) {\n        for(j = 0; j < 5; j = j + 1) {\n            scanf(\"%d\", &student[i][j]);\n        }\n    }\n\n    for(i = 0; i < n; i = i + 1) {\n        int count = 0;\n\n        for(j = 0; j < n; j = j + 1) {\n            if(i == j) {\n                continue;\n            }\n\n            for(k = 0; k < 5; k = k + 1) {\n                if(student[i][k] == student[j][k]) {\n                    count = count + 1;\n                    break;\n                }\n            }\n        }\n\n        if(count > max) {\n            max = count;\n            leader = i;\n        }\n    }\n\n    printf(\"%d\n\", leader + 1);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 1000명의 학생 정보를 저장할 2차원 배열 student을 선언하세요. (각 학생은 5개의 점수를 가짐)\n4. 정수형 변수 i, j, k, l을 선언하세요.\n5. int형 변수 max를 0으로 초기화하여 최대 점수를 저장할 준비를 하세요.\n6. int형 변수 leader를 0으로 초기화하여 리더의 인덱스를 저장할 준비를 하세요.\n7. n의 값을 입력받으세요.\n8. [rep_start(1)] i를 선언해 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n9. [rep_start(2)] j를 선언해 0부터 4까지 반복하는 for 루프를 작성하세요.\n10. j번째 학생의 점수를 입력받아 student[i][j]에 저장하세요.\n11. [rep_end(2)]\n12. [rep_end(1)]\n13. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n14. int형 변수 count를 0으로 초기화하여 중복 점수를 카운트할 준비를 하세요.\n15. [rep_start(2)] j를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n16. [cond_start(3)] i와 j가 같지 않은지 확인하는 조건문을 작성하세요.\n17. 만약 i와 j가 같다면, continue를 통해 다음 반복으로 넘어가세요.\n18. [cond_end(3)]\n19. [rep_start(3)] k를 0부터 4까지 반복하는 for 루프를 작성하세요.\n20. [cond_start(4)] student[i][k]가 student[j][k]와 같은지 확인하는 조건문을 작성하세요.\n21. 만약 점수가 같다면, count를 1 증가시키고, break를 통해 안쪽 반복문을 종료하세요.\n22. [cond_end(4)]\n23. [rep_end(3)]\n24. [cond_start(2)] count가 max보다 큰지 확인하는 조건문을 작성하세요.\n25. max를 count의 값으로 업데이트하고 리더의 인덱스를 i로 설정하세요.\n26. [cond_end(2)]\n27. [rep_end(1)]\n28. 리더의 인덱스에 1을 더하여 출력하세요.\n29. return 0;으로 프로그램을 종료하세요.\n30. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint isLeap(int year) {\n    if((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n        return 1;\n    } \n    else {\n        return 0;\n    }\n}\n\nint daysInMonth(int year, int month) {\n    int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\n    if(month == 2 && isLeap(year)) {\n        return 29;\n    } \n    else {\n        return days[month - 1];\n    }\n}\n\nint countDays(int y1, int m1, int d1, int y2, int m2, int d2) {\n    int count = 0;\n\n    while(y1 < y2 || m1 < m2 || d1 < d2) {\n        d1 = d1 + 1;\n        count = count + 1;\n\n        if(d1 > daysInMonth(y1, m1)) {\n            d1 = 1;\n            m1 = m1 + 1;\n        }\n\n        if(m1 > 12) {\n            m1 = 1;\n            y1 = y1 + 1;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int y1, m1, d1;\n    int y2, m2, d2;\n\n    scanf(\"%d %d %d\", &y1, &m1, &d1);\n    scanf(\"%d %d %d\", &y2, &m2, &d2);\n\n    if(y2 > y1 + 1000 || (y2 == y1 + 1000 && m2 >= m1 && d2 >= d1)) {\n        printf(\"gg\n\");\n    } \n    else {\n        int result = countDays(y1, m1, d1, y2, m2, d2);\n        printf(\"D-%d\n\", result);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 isLeap을 정의하세요. (매개변수: int year)\n2. [cond_start(1)] year가 윤년인지 확인하는 조건문을 작성하세요.\n3. year가 4로 나누어지고 100으로 나누어지지 않거나, 400으로 나누어지는 경우 1을 반환하세요.\n4. [cond_end(1)]\n5. year가 윤년이 아니면 0을 반환하세요.\n6. [func_def_end(1)]\n7. [func_def_start(1)] int 반환형 함수 daysInMonth을 정의하세요. (매개변수: int year, int month)\n8. int형 배열 days를 선언하여 각 월의 날 수를 초기화하세요.\n9. [cond_start(1)] month가 2이면서 year가 윤년인지 확인하는 조건문을 작성하세요.\n10. 윤년이면 29를 반환하세요.\n11. [cond_end(1)]\n12. 그렇지 않으면 days 배열에서 해당 month's 날 수를 반환하세요.\n13. [func_def_end(1)]\n14. [func_def_start(1)] int 반환형 함수 countDays을 정의하세요. (매개변수: int y1, int m1, int d1, int y2, int m2, int d2)\n15. int형 변수 count를 0으로 초기화하세요.\n16. [rep_start(1)] y1이 y2보다 작거나, m1이 m2보다 작거나, d1이 d2보다 작은 동안 반복하세요.\n17. d1을 1 증가시키고, count를 1 증가시키세요.\n18. [cond_start(2)] d1이 현재 월의 날 수를 초과하는지 확인하는 조건문을 작성하세요.\n19. d1이 초과하면 d1을 1로 초기화하고, m1을 1 증가시키세요.\n20. [cond_end(2)]\n21. [cond_start(2)] m1이 12를 초과하는지 확인하는 조건문을 작성하세요.\n22. m1이 초과하면 m1을 1로 초기화하고, y1을 1 증가시키세요.\n23. [cond_end(2)]\n24. [rep_end(1)]\n25. count를 반환하세요.\n26. [func_def_end(1)]\n27. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n28. 정수형 변수 y1, m1, d1를 선언하세요.\n29. 정수형 변수 y2, m2, d2를 선언하세요.\n30. y1, m1, d1에 대한 입력을 받으세요.\n31. y2, m2, d2에 대한 입력을 받으세요.\n32. [cond_start(1)] y2가 y1 + 1000보다 크거나, y2가 y1 + 1000과 같고 m2와 d2가 각각 m1과 d1보다 크거나 같은지 확인하는 조건문을 작성하세요.\n33. 조건이 맞으면 \"gg\"를 출력하세요.\n34. [cond_end(1)]\n35. 그렇지 않으면 countDays 함수를 호출하여 결과를 정수형 변수 result에 저장하세요.\n36. \"D-%d\" 형식으로 result 값을 출력하세요.\n37. [func_def_end(1)]\n38. return 0;으로 프로그램을 종료하세요.\n39. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int A, B, N;\n    int i;\n\n    scanf(\"%d %d %d\", &A, &B, &N);\n\n    A = A % B;\n\n    for(i = 1; i <= N; i++) {\n        A = A * 10;\n\n        if(i == N) {\n            printf(\"%d\n\", A / B);\n        }\n\n        A = A % B;\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 A, B, N을 선언하세요.\n3. 정수형 변수 i를 선언하세요.\n4. A, B, N에 입력을 받으세요.\n5. A를 B로 나눈 나머지로 갱신하세요.\n6. [rep_start(1)] i를 1부터 N까지 반복하는 for 루프를 작성하세요.\n7. A를 10배로 곱하세요.\n8. [cond_start(2)] i가 N과 같은지 확인하는 조건문을 작성하세요.\n9. i가 N이라면 A를 B로 나눈 결과를 출력하세요.\n10. [cond_end(2)]\n11. A를 B로 나눈 나머지로 갱신하세요.\n12. [rep_end(1)]\n13. return 0;으로 프로그램을 종료하세요.\n14. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, i, j;\n    int count = 0;\n    char word[101];\n\n    scanf(\"%d\", &N);\n\n    for(i = 0; i < N; i++) {\n        int alpha[26] = {0};\n        int is_group = 1;\n\n        scanf(\"%s\", word);\n\n        for(j = 0; word[j] != '\u0000'; j++) {\n            if(j > 0) {\n                if(word[j] != word[j - 1]) {\n                    if(alpha[word[j] - 'a'] == 1) {\n                        is_group = 0;\n                        break;\n                    }\n                }\n            }\n\n            alpha[word[j] - 'a'] = 1;\n        }\n\n        if(is_group == 1) {\n            count = count + 1;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N, i, j를 선언하세요.\n3. 그룹 단어의 개수를 세기 위한 count 변수를 0으로 초기화하세요.\n4. 최대 100자까지 입력할 수 있는 char형 배열 word를 선언하세요.\n5. N의 값을 입력받으세요.\n6. [rep_start(1)] i를 0부터 N-1까지 반복하는 for 루프를 작성하세요.\n7. 알파벳의 출현 여부를 기록하기 위한 int형 배열 alpha를 26개로 선언하고 모두 0으로 초기화하세요.\n8. 그룹 단어 여부를 확인하기 위한 is_group 변수를 1로 초기화하세요.\n9. word 배열에 단어를 입력받으세요.\n10. [rep_start(2)] j를 0부터 word 배열의 끝까지 반복하는 for 루프를 작성하세요.\n11. [cond_start(3)] j가 0보다 클 때 조건문을 작성하세요.\n12. 현재 문자와 이전 문자가 다른지 확인하는 조건문을 작성하세요.\n13. [cond_start(4)] alpha 배열에서 현재 문자의 출현 여부를 확인하는 조건문을 작성하세요.\n14. 이전에 나온 문자가 아니라면 is_group 변수를 0으로 설정하고 루프를 종료하세요.\n15. [cond_end(4)]\n16. [cond_end(3)]\n17. 현재 문자의 출현 여부를 기록하세요.\n18. [rep_end(2)]\n19. [cond_start(1)] is_group이 1인지 확인하는 조건문을 작성하세요.\n20. 그룹 단어이면 count를 1 증가시키세요.\n21. [cond_end(1)]\n22. [rep_end(1)]\n23. count 변수를 출력하세요.\n24. return 0;으로 프로그램을 종료하세요.\n25. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int day, year, hour, minute;\n    char month[20];\n    int month_days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};\n    int month_index = 0;\n    int i;\n    double total_minutes = 0;\n    double passed_minutes = 0;\n\n    scanf(\"%s %d, %d %d:%d\", month, &day, &year, &hour, &minute);\n\n    if((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n        month_days[1] = 29;\n    }\n\n    if(month[0] == 'J' && month[1] == 'a') {\n        month_index = 0;\n    }\n    else if(month[0] == 'F') {\n        month_index = 1;\n    }\n    else if(month[0] == 'M' && month[2] == 'r') {\n        month_index = 2;\n    }\n    else if(month[0] == 'A' && month[1] == 'p') {\n        month_index = 3;\n    }\n    else if(month[0] == 'M' && month[2] == 'y') {\n        month_index = 4;\n    }\n    else if(month[0] == 'J' && month[2] == 'n') {\n        month_index = 5;\n    }\n    else if(month[0] == 'J' && month[2] == 'l') {\n        month_index = 6;\n    }\n    else if(month[0] == 'A' && month[1] == 'u') {\n        month_index = 7;\n    }\n    else if(month[0] == 'S') {\n        month_index = 8;\n    }\n    else if(month[0] == 'O') {\n        month_index = 9;\n    }\n    else if(month[0] == 'N') {\n        month_index = 10;\n    }\n    else if(month[0] == 'D') {\n        month_index = 11;\n    }\n\n    for(i = 0; i < 12; i++) {\n        total_minutes = total_minutes + month_days[i] * 24 * 60;\n    }\n\n    for(i = 0; i < month_index; i++) {\n        passed_minutes = passed_minutes + month_days[i] * 24 * 60;\n    }\n\n    passed_minutes = passed_minutes + (day - 1) * 24 * 60;\n    passed_minutes = passed_minutes + hour * 60 + minute;\n\n    printf(\"%.10lf\n\", passed_minutes / total_minutes * 100.0);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 day, year, hour, minute을 선언하세요.\n3. char형 배열 month를 선언하여 20개의 문자 공간을 확보하세요.\n4. 정수형 배열 month_days를 선언하여 각 월에 해당하는 일 수를 초기화하세요.\n5. int형 변수 month_index를 0으로 초기화하세요.\n6. 정수형 변수 i를 선언하세요.\n7. double형 변수 total_minutes를 0으로 초기화하세요.\n8. double형 변수 passed_minutes를 0으로 초기화하세요.\n9. scanf 함수를 사용하여 month, day, year, hour, minute을 입력받으세요.\n10. [cond_start(1)] 윤년을 판단하는 조건문을 작성하세요.\n11. 윤년이라면 2월의 일수를 29로 설정하세요.\n12. [cond_end(1)]\n13. [cond_start(1)] 입력된 month의 첫 글자에 따라 month_index를 설정하는 조건문을 작성하세요.\n14. month가 'January'일 경우 month_index를 0으로 설정하세요.\n15. [cond_start(2)] month가 'February'일 경우 month_index를 1로 설정하세요.\n16. [cond_end(2)]\n17. [cond_start(2)] month가 'March'일 경우 month_index를 2로 설정하세요.\n18. [cond_end(2)]\n19. [cond_start(2)] month가 'April'일 경우 month_index를 3으로 설정하세요.\n20. [cond_end(2)]\n21. [cond_start(2)] month가 'May'일 경우 month_index를 4로 설정하세요.\n22. [cond_end(2)]\n23. [cond_start(2)] month가 'June'일 경우 month_index를 5로 설정하세요.\n24. [cond_end(2)]\n25. [cond_start(2)] month가 'July'일 경우 month_index를 6으로 설정하세요.\n26. [cond_end(2)]\n27. [cond_start(2)] month가 'August'일 경우 month_index를 7로 설정하세요.\n28. [cond_end(2)]\n29. [cond_start(2)] month가 'September'일 경우 month_index를 8로 설정하세요.\n30. [cond_end(2)]\n31. [cond_start(2)] month가 'October'일 경우 month_index를 9로 설정하세요.\n32. [cond_end(2)]\n33. [cond_start(2)] month가 'November'일 경우 month_index를 10로 설정하세요.\n34. [cond_end(2)]\n35. [cond_start(2)] month가 'December'일 경우 month_index를 11로 설정하세요.\n36. [cond_end(2)]\n37. [rep_start(1)] 모든 월의 총 분을 계산하기 위한 for 루프를 작성하세요.\n38. total_minutes에 month_days[i] * 24 * 60을 더하세요.\n39. [rep_end(1)]\n40. [rep_start(1)] 선택된 달까지의 분을 계산하기 위한 for 루프를 작성하세요.\n41. passed_minutes에 month_days[i] * 24 * 60을 더하세요.\n42. [rep_end(1)]\n43. passed_minutes에 (day - 1) * 24 * 60을 더하세요.\n44. passed_minutes에 hour * 60 + minute을 더하세요.\n45. printf 함수를 사용하여 총 경과 시간을 백분율로 출력하세요.\n46. return 0;으로 프로그램을 종료하세요.\n47. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i, num;\n    int scenario = 1;\n    char names[101][61];\n    int count[101];\n    char temp;\n    char c;\n\n    while(1) {\n        scanf(\"%d\", &n);\n\n        if(n == 0) {\n            break;\n        }\n\n        for(i = 1; i <= n; i++) {\n            scanf(\" \");\n            fgets(names[i], 61, stdin);\n            for(int j = 0; names[i][j] != '\u0000'; j++) {\n                if(names[i][j] == '\n') {\n                    names[i][j] = '\u0000';\n                    break;\n                }\n            }\n            count[i] = 0;\n        }\n\n        for(i = 0; i < 2 * n - 1; i++) {\n            scanf(\"%d %c\", &num, &c);\n            count[num] = count[num] + 1;\n        }\n\n        for(i = 1; i <= n; i++) {\n            if(count[i] == 1) {\n                printf(\"%d %s\n\", scenario, names[i]);\n                break;\n            }\n        }\n\n        scenario = scenario + 1;\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 n, i, num을 선언하세요.  \n3. 시나리오를 추적하는 int형 변수 scenario를 1로 초기화하세요.  \n4. 이름을 저장할 char형 배열 names를 선언하세요 (최대 101개의 이름, 각 최대 60자).  \n5. 출현 횟수를 저장할 int형 배열 count를 선언하세요 (최대 101개).  \n6. char형 변수 temp와 c를 선언하세요.  \n7. [rep_start(1)] 무한 루프를 시작하세요.  \n8. n값을 입력받으세요.  \n9. [cond_start(1)] n 값이 0인지 확인하는 조건문을 작성하세요.  \n10. n이 0이면 루프를 종료하세요.  \n11. [cond_end(1)]  \n12. [rep_start(2)] i를 1부터 n까지 반복하는 for 루프를 작성하세요.  \n13. 공백 문자를 제거하기 위해 scanf에서 빈 문자열을 입력받으세요.  \n14. names 배열의 i번째 요소에 최대 60자까지 fgets로 문자열을 읽어들이세요.  \n15. [rep_start(3)] names[i]의 문자 배열을 반복하여 각 문자를 확인하세요.  \n16. [cond_start(4)] 현재 문자가 NULL 문자(종료 문자)가 아닌지 확인하세요.  \n17. [cond_start(5)] 현재 문자가 줄 바꿈 문자('\\n')인지 확인하는 조건문을 작성하세요.  \n18. 줄 바꿈 문자가 맞다면, 해당 문자를 NULL 문자로 바꾸고 루프를 종료하세요.  \n19. [cond_end(5)]  \n20. [cond_end(4)]  \n21. [rep_end(3)]  \n22. count 배열의 i번째 요소를 0으로 초기화하세요.  \n23. [rep_end(2)]  \n24. [rep_start(2)] i를 0부터 2n-2까지 반복하는 for 루프를 작성하세요.  \n25. num과 c의 값을 입력받으세요.  \n26. count[num]의 값을 1 증가시키세요.  \n27. [rep_end(2)]  \n28. [rep_start(2)] i를 1부터 n까지 반복하는 for 루프를 작성하세요.  \n29. [cond_start(1)] count[i]가 1인지 확인하는 조건문을 작성하세요.  \n30. count[i]가 1이라면 scenario와 names[i]를 출력하세요.  \n31. 루프를 종료하세요.  \n32. [cond_end(1)]  \n33. [rep_end(2)]  \n34. scenario 변수의 값을 1 증가시키세요.  \n35. [rep_end(1)]  \n36. return 0;으로 프로그램을 종료하세요.  \n37. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int group = 1;\n    int i, j, k;\n    char names[20][61];\n    char messages[20][20];\n    int nasty[400][2];\n    int nastyCount;\n\n    while(1) {\n        scanf(\"%d\", &n);\n\n        if(n == 0) {\n            break;\n        }\n\n        for(i = 0; i < n; i++) {\n            scanf(\"%s\", names[i]);\n            for(j = 0; j < n - 1; j++) {\n                scanf(\" %c\", &messages[i][j]);\n            }\n        }\n\n        printf(\"Group %d\n\", group);\n        nastyCount = 0;\n\n        for(i = 0; i < n; i++) {\n            for(j = 0; j < n - 1; j++) {\n                if(messages[i][j] == 'N') {\n                    int from = (i - j - 1 + n) % n;\n                    nasty[nastyCount][0] = from;\n                    nasty[nastyCount][1] = i;\n                    nastyCount = nastyCount + 1;\n                }\n            }\n        }\n\n        if(nastyCount == 0) {\n            printf(\"Nobody was nasty\n\");\n        }\n\n        for(i = 0; i < nastyCount; i++) {\n            printf(\"%s was nasty about %s\n\", names[nasty[i][0]], names[nasty[i][1]]);\n        }\n\n        printf(\"\n\");\n        group = group + 1;\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 그룹 번호를 저장할 int형 변수 group을 1로 초기화하세요.\n4. int형 변수를 i, j, k를 선언하세요.\n5. char형 배열 names[20][61]을 선언하여 20명의 이름을 최대 60자까지 저장할 수 있도록 합니다.\n6. char형 배열 messages[20][20]을 선언하여 20명의 메시지를 최대 19자까지 저장할 수 있도록 합니다.\n7. int형 2차 배열 nasty[400][2]을 선언하여 최대 400개의 'nasty' 짓을 기록할 수 있도록 합니다.\n8. int형 변수 nastyCount를 선언합니다.\n9. [rep_start(1)] 무한 루프를 시작하여 계속 입력을 받도록 합니다.\n10. n에 정수를 입력받습니다.\n11. [cond_start(1)] n이 0인지 확인하는 조건문을 작성하세요.\n12. n이 0이면 반복문을 종료하세요.\n13. [cond_end(1)]\n14. [rep_start(2)] i를 0부터 n-1까지 반복하는 for 루프를 시작합니다.\n15. names 배열에 i번째 위치에 문자열을 입력받습니다.\n16. [rep_start(3)] j를 0부터 n-2까지 반복하는 for 루프를 시작합니다.\n17. messages 배열에 i번째 이름에 대한 j번째 메시지를 입력받습니다.\n18. [rep_end(3)]\n19. [rep_end(2)]\n20. group 번호에 해당하는 제목을 출력합니다.\n21. nastyCount를 0으로 초기화합니다.\n22. [rep_start(2)] i를 0부터 n-1까지 반복하는 for 루프를 시작합니다.\n23. [rep_start(3)] j를 0부터 n-2까지 반복하는 for 루프를 시작합니다.\n24. [cond_start(4)] messages[i][j]가 'N'인지 확인하는 조건문을 작성하세요.\n25. 'N'이 발견되면 from 변수를 계산하여 nasty 배열에 기록합니다.\n26. nastyCount를 1 증가시킵니다.\n27. [cond_end(4)]\n28. [rep_end(3)]\n29. [rep_end(2)]\n30. [cond_start(2)] nastyCount가 0인지 확인하는 조건문을 작성하세요.\n31. nastyCount가 0이면 'Nobody was nasty'를 출력하세요.\n32. [cond_end(2)]\n33. [rep_start(2)] i를 0부터 nastyCount - 1까지 반복하는 for 루프를 시작합니다.\n34. nasty 배열에 기록된 내용을 출력합니다.\n35. [rep_end(2)]\n36. 빈 줄을 출력합니다.\n37. group을 1 증가시킵니다.\n38. [rep_end(1)]\n39. return 0;으로 프로그램을 종료하세요.\n40. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int arr[50];\n    int i;\n    int min;\n    int max;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    min = arr[0];\n    max = arr[0];\n\n    for(i = 1; i < n; i++) {\n        if(arr[i] < min) {\n            min = arr[i];\n        }\n        if(arr[i] > max) {\n            max = arr[i];\n        }\n    }\n\n    printf(\"%d\n\", min * max);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 크기가 50인 정수형 배열 arr를 선언하세요.\n4. 정수형 변수 i를 선언하세요.\n5. 정수형 변수 min을 선언하세요.\n6. 정수형 변수 max를 선언하세요.\n7. n의 값에 대해 사용자로부터 입력을 받으세요.\n8. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n9. 배열 arr의 각 요소에 대해 사용자로부터 값을 입력 받으세요.\n10. [rep_end(1)]\n11. min을 배열 arr의 첫 번째 요소로 초기화하세요.\n12. max를 배열 arr의 첫 번째 요소로 초기화하세요.\n13. [rep_start(1)] i를 1부터 n-1까지 반복하는 for 루프를 작성하세요.\n14. [cond_start(2)] arr[i]가 min보다 작은지 확인하는 조건문을 작성하세요.\n15. arr[i]가 min보다 작으면 min을 arr[i]로 업데이트하세요.\n16. [cond_end(2)]\n17. [cond_start(2)] arr[i]가 max보다 큰지 확인하는 조건문을 작성하세요.\n18. arr[i]가 max보다 크면 max를 arr[i]로 업데이트하세요.\n19. [cond_end(2)]\n20. [rep_end(1)]\n21. min과 max의 곱을 출력하세요.\n22. return 0;으로 프로그램을 종료하세요.\n23. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int original;\n    int count;\n    int a;\n    int b;\n    int sum;\n\n    scanf(\"%d\", &n);\n\n    original = n;\n    count = 0;\n\n    while(1) {\n        a = n / 10;\n        b = n % 10;\n        sum = a + b;\n        n = b * 10 + sum % 10;\n        count = count + 1;\n\n        if(n == original) {\n            break;\n        }\n    }\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 원래의 n 값을 저장할 int형 변수 original을 선언하세요.\n4. 반복 횟수를 세기 위한 int형 변수 count를 선언하세요.\n5. 두 개의 int형 변수 a와 b를 선언하세요.\n6. 소수의 각 자리수의 합을 저장할 int형 변수 sum을 선언하세요.\n7. n에 대한 입력을 받으세요.\n8. original에 n의 값을 저장하세요.\n9. count를 0으로 초기화하세요.\n10. [rep_start(1)] 무한 루프를 시작하세요.\n11. a에 n을 10으로 나눈 값을 저장하여 n의 10의 자리수를 구하세요.\n12. b에 n을 10으로 나눈 나머지 값을 저장하여 n의 1의 자리수를 구하세요.\n13. sum에 a와 b의 합을 저장하세요.\n14. n을 b에 sum을 10으로 나눈 나머지를 더해 10의 자리로 만들고 새로운 값을 계산하세요.\n15. count를 1 증가시키세요.\n16. [cond_start(1)] n이 original과 같은지 확인하는 조건문을 작성하세요.\n17. n과 original이 같다면 루프를 종료하세요.\n18. [cond_end(1)]\n19. [rep_end(1)]\n20. count의 값을 출력하세요.\n21. return 0;으로 프로그램을 종료하세요.\n22. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int a[5];\n    int i;\n    int n;\n    int count;\n\n    for(i = 0; i < 5; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    n = 1;\n\n    while(1) {\n        count = 0;\n\n        for(i = 0; i < 5; i++) {\n            if(n % a[i] == 0) {\n                count = count + 1;\n            }\n        }\n\n        if(count >= 3) {\n            break;\n        }\n\n        n = n + 1;\n    }\n\n    printf(\"%d\n\", n);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 배열 a를 5개의 원소로 선언하세요.\n3. 정수형 변수 i를 선언하세요.\n4. 정수형 변수 n을 선언하세요.\n5. 정수형 변수 count를 선언하세요.\n6. [rep_start(1)] i를 0부터 5 미만까지 반복하는 for 루프를 작성하세요.\n7. 배열 a의 각 원소에 대해 사용자로부터 입력을 받으세요.\n8. [rep_end(1)]\n9. n을 1로 초기화하세요.\n10. [rep_start(1)] 무한 루프를 시작합니다.\n11. count를 0으로 초기화하세요.\n12. [rep_start(2)] i를 0부터 5 미만까지 반복하는 for 루프를 작성하세요.\n13. [cond_start(3)] n이 배열 a의 i번째 원소로 나누어지는지 확인하는 조건문을 작성하세요.\n14. n이 a[i]로 나누어지면 count를 1 증가시키세요.\n15. [cond_end(3)]\n16. [rep_end(2)]\n17. [cond_start(2)] count가 3 이상인지 확인하는 조건문을 작성하세요.\n18. count가 3 이상이라면 반복문을 종료하세요.\n19. [cond_end(2)]\n20. n을 1 증가시키세요.\n21. [rep_end(1)]\n22. n의 값을 출력하세요.\n23. return 0;으로 프로그램을 종료하세요.\n24. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char s[1000001];\n    int count[26] = {0};\n    int i;\n    int max;\n    int max_index;\n    int duplicate;\n\n    scanf(\"%s\", s);\n\n    i = 0;\n\n    while(s[i] != '\u0000') {\n        if(s[i] >= 'a' && s[i] <= 'z') {\n            count[s[i] - 'a'] = count[s[i] - 'a'] + 1;\n        }\n        else if(s[i] >= 'A' && s[i] <= 'Z') {\n            count[s[i] - 'A'] = count[s[i] - 'A'] + 1;\n        }\n        i = i + 1;\n    }\n\n    max = 0;\n    max_index = -1;\n    duplicate = 0;\n\n    for(i = 0; i < 26; i++) {\n        if(count[i] > max) {\n            max = count[i];\n            max_index = i;\n            duplicate = 0;\n        }\n        else if(count[i] == max) {\n            duplicate = 1;\n        }\n    }\n\n    if(duplicate == 1) {\n        printf(\"?\n\");\n    }\n    else {\n        printf(\"%c\n\", max_index + 'A');\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 1000001 크기의 char 배열 s를 선언하여 문자열을 저장할 공간을 만드세요.\n3. 26 크기의 정수형 배열 count를 0으로 초기화하여 각 알파벳의 개수를 저장할 공간을 만드세요.\n4. 정수형 변수 i를 선언하세요.\n5. 정수형 변수 max를 선언하세요. (최대 개수를 저장할 변수)\n6. 정수형 변수 max_index를 선언하세요. (최대 개수를 가진 알파벳의 인덱스를 저장할 변수)\n7. 정수형 변수 duplicate를 선언하세요. (동일한 최대 개수의 알파벳이 있는지 여부를 확인하기 위한 변수)\n8. s 배열에 문자열을 입력받기 위해 scanf 함수를 사용하세요.\n9. i를 0으로 초기화하세요. (문자열의 인덱스를 추적하기 위한 변수)\n10. [rep_start(1)] s[i]가 널 문자가 아닐 때 반복하는 while 루프를 시작하세요.\n11. [cond_start(2)] s[i]가 소문자 알파벳인지 확인하는 조건문을 작성하세요.\n12. 소문자일 경우 해당 알파벳의 개수를 count 배열에 1 증가시켜 저장하세요.\n13. [cond_end(2)]\n14. [cond_start(2)] s[i]가 대문자 알파벳인지 확인하는 조건문을 작성하세요.\n15. 대문자일 경우 해당 알파벳의 개수를 count 배열에 1 증가시켜 저장하세요.\n16. [cond_end(2)]\n17. i를 1 증가시켜 다음 문자로 넘어가게 하세요.\n18. [rep_end(1)]\n19. max를 0으로 초기화하세요. (최대 개수를 찾기 위한 변수)\n20. max_index를 -1로 초기화하세요. (최대 개수를 가진 인덱스 초기화)\n21. duplicate를 0으로 초기화하세요. (일치하는 최대 개수가 존재하는지 여부)\n22. [rep_start(1)] i를 0부터 25까지 반복하는 for 루프를 작성하세요.\n23. [cond_start(2)] count[i]가 max보다 큰지 확인하는 조건문을 작성하세요.\n24. max를 count[i]로 업데이트하고, max_index를 i로 저장하세요. (현재 알파벳에 대한 최대 개수를 기록하세요.)\n25. duplicate를 0으로 설정하여 중복 여부를 초기화하세요.\n26. [cond_end(2)]\n27. [cond_start(2)] count[i]가 max와 같은지 확인하는 조건문을 작성하세요.\n28. duplicate를 1로 설정하여 중복이 있음을 기록하세요.\n29. [cond_end(2)]\n30. [rep_end(1)]\n31. [cond_start(1)] duplicate가 1인지 확인하는 조건문을 작성하세요.\n32. 동일한 최대 개수가 있다면 \"?\"를 출력하세요.\n33. [cond_end(1)]\n34. [cond_start(1)] duplicate가 1이 아니라면 최대 인덱스에 해당하는 알파벳을 출력하세요.\n35. max_index에 65를 더하여 대문자로 변환 후 출력하세요.\n36. [cond_end(1)]\n37. return 0;으로 프로그램을 종료하세요.\n38. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int m;\n    char castle[50][51];\n    int row[50] = {0};\n    int col[50] = {0};\n    int i;\n    int j;\n    int row_count;\n    int col_count;\n\n    scanf(\"%d %d\", &n, &m);\n\n    for(i = 0; i < n; i++) {\n        scanf(\"%s\", castle[i]);\n    }\n\n    for(i = 0; i < n; i++) {\n        for(j = 0; j < m; j++) {\n            if(castle[i][j] == 'X') {\n                row[i] = 1;\n                col[j] = 1;\n            }\n        }\n    }\n\n    row_count = 0;\n    col_count = 0;\n\n    for(i = 0; i < n; i++) {\n        if(row[i] == 0) {\n            row_count = row_count + 1;\n        }\n    }\n\n    for(j = 0; j < m; j++) {\n        if(col[j] == 0) {\n            col_count = col_count + 1;\n        }\n    }\n\n    if(row_count > col_count) {\n        printf(\"%d\n\", row_count);\n    }\n    else {\n        printf(\"%d\n\", col_count);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n과 m을 선언하세요.\n3. char형 2차원 배열 castle을 선언하여 50행 51열로 크기를 지정하세요. \n4. int형 1차원 배열 row를 선언하고 모든 요소를 0으로 초기화하세요. \n5. int형 1차원 배열 col을 선언하고 모든 요소를 0으로 초기화하세요.\n6. int형 변수 i와 j를 선언하세요.\n7. int형 변수 row_count와 col_count를 선언하세요.\n8. n과 m에 대한 값을 입력 받으세요.\n9. [rep_start(1)] i를 0부터 n-1까지 반복하며 입력을 받는 for 루프를 작성하세요.\n10. 각 행에 대해 castle 배열에 문자열을 입력 받으세요.\n11. [rep_end(1)]\n12. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n13. [rep_start(2)] j를 0부터 m-1까지 반복하는 for 루프를 작성하세요.\n14. [cond_start(2)] castle[i][j]가 'X'인지 확인하는 조건문을 작성하세요.\n15. castle[i][j]가 'X'라면 해당 행의 row 배열과 해당 열의 col 배열을 1로 설정하세요.\n16. [cond_end(2)]\n17. [rep_end(2)]\n18. [rep_end(1)]\n19. row_count 변수를 0으로 초기화하세요.\n20. col_count 변수를 0으로 초기화하세요.\n21. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n22. [cond_start(2)] row[i]가 0인지 확인하는 조건문을 작성하세요.\n23. row[i]가 0이라면 row_count를 1 증가시키세요.\n24. [cond_end(2)]\n25. [rep_end(1)]\n26. [rep_start(1)] j를 0부터 m-1까지 반복하는 for 루프를 작성하세요.\n27. [cond_start(2)] col[j]가 0인지 확인하는 조건문을 작성하세요.\n28. col[j]가 0이라면 col_count를 1 증가시키세요.\n29. [cond_end(2)]\n30. [rep_end(1)]\n31. [cond_start(1)] row_count가 col_count보다 큰지 확인하는 조건문을 작성하세요.\n32. row_count가 col_count보다 크면 row_count를 출력하세요.\n33. [cond_end(1)]\n34. [cond_start(1)] col_count가 더 크거나 같으면 col_count를 출력하세요.\n35. [cond_end(1)]\n36. return 0;으로 프로그램을 종료하세요.\n37. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char s[6];\n    int i;\n    int len;\n    int is_palindrome;\n\n    while(1) {\n        scanf(\"%s\", s);\n\n        if(s[0] == '0' && s[1] == '\u0000') {\n            break;\n        }\n\n        i = 0;\n        while(s[i] != '\u0000') {\n            i = i + 1;\n        }\n\n        len = i;\n        is_palindrome = 1;\n\n        for(i = 0; i < len / 2; i++) {\n            if(s[i] != s[len - 1 - i]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n\n        if(is_palindrome == 1) {\n            printf(\"yes\n\");\n        }\n        else {\n            printf(\"no\n\");\n        }\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 배열 s를 선언하여 최대 5개의 문자를 저장할 수 있도록 합니다.\n3. 정수형 변수 i를 선언합니다.\n4. 정수형 변수 len을 선언하여 문자열의 길이를 저장할 준비를 합니다.\n5. 정수형 변수 is_palindrome을 선언하여 회문 여부를 저장할 준비를 합니다.\n6. [rep_start(1)] 무한 루프를 시작합니다.\n7. 사용자로부터 문자열을 입력받아 s에 저장합니다.\n8. [cond_start(1)] s의 첫 번째와 두 번째 문자가 '0'인지 확인하는 조건문을 작성합니다.\n9. 두 문자가 모두 '0'이면 루프를 종료합니다.\n10. [cond_end(1)]\n11. i를 0으로 초기화합니다.\n12. [rep_start(2)] s[i]가 널 문자('\\0')가 아닐 때까지 루프를 지속합니다.\n13. s의 각 문자를 통해 i를 증가시켜 문자열의 길이를 계산합니다.\n14. [rep_end(2)]\n15. 문자열의 길이를 len에 저장합니다.\n16. is_palindrome을 1로 초기화하여 회문으로 가정합니다.\n17. [rep_start(1)] i를 0으로 초기화하고, len의 절반까지 반복하는 for 루프를 시작합니다.\n18. [cond_start(2)] s[i]와 s[len - 1 - i]가 같은지 비교하는 조건문을 작성합니다.\n19. 두 문자가 다르면 is_palindrome을 0으로 설정하고 루프를 종료합니다.\n20. [cond_end(2)]\n21. [rep_end(1)]\n22. [cond_start(1)] is_palindrome이 1인지 확인하는 조건문을 작성합니다.\n23. is_palindrome이 1이면 \"yes\"를 출력합니다.\n24. [cond_end(1)]\n25. [cond_start(1)] is_palindrome이 1이 아닌 경우를 처리하는 조건문을 작성합니다.\n26. is_palindrome이 0이면 \"no\"를 출력합니다.\n27. [cond_end(1)]\n28. [rep_end(1)]\n29. return 0;으로 프로그램을 종료하세요.\n30. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int a;\n    int b;\n    int i;\n    int count;\n    int num;\n    int index;\n    int sum;\n\n    scanf(\"%d %d\", &a, &b);\n\n    count = 0;\n    num = 1;\n    index = 1;\n    sum = 0;\n\n    while(index <= b) {\n        for(i = 0; i < num; i++) {\n            if(index >= a && index <= b) {\n                sum = sum + num;\n            }\n            index = index + 1;\n            if(index > b) {\n                break;\n            }\n        }\n        num = num + 1;\n    }\n\n    printf(\"%d\n\", sum);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 a, b, i, count, num, index, sum을 선언하세요.\n3. a와 b에 입력을 받으세요.\n4. count 변수를 0으로 초기화하세요.\n5. num 변수를 1로 초기화하세요.\n6. index 변수를 1로 초기화하세요.\n7. sum 변수를 0으로 초기화하세요.\n8. [rep_start(1)] index가 b 이하인 동안 반복하는 while 루프를 작성하세요.\n9. [rep_start(2)] i를 0부터 num-1까지 반복하는 for 루프를 작성하세요.\n10. [cond_start(3)] index가 a 이상 b 이하인지 확인하는 조건문을 작성하세요.\n11. index가 a 이상 b 이하라면, sum에 num을 더하세요.\n12. index를 1만큼 증가시키세요.\n13. [cond_end(3)]\n14. [cond_start(4)] index가 b를 초과하는지 확인하는 조건문을 작성하세요.\n15. index가 b를 초과하면 루프를 종료하세요.\n16. [cond_end(4)]\n17. [rep_end(2)]\n18. num을 1만큼 증가시키세요.\n19. [rep_end(1)]\n20. sum을 출력하세요.\n21. return 0;으로 프로그램을 종료하세요.\n22. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char s[11];\n    int i, j, len, left, right;\n\n    scanf(\"%s\", s);\n\n    i = 0;\n    while (s[i] != '\u0000') {\n        i = i + 1;\n    }\n\n    len = i;\n\n    i = 1;\n    while (i < len) {\n        left = 1;\n        right = 1;\n\n        j = 0;\n        while (j < i) {\n            left = left * (s[j] - '0');\n            j = j + 1;\n        }\n\n        j = i;\n        while (j < len) {\n            right = right * (s[j] - '0');\n            j = j + 1;\n        }\n\n        if (left == right) {\n            printf(\"YES\n\");\n            return 0;\n        }\n\n        i = i + 1;\n    }\n\n    printf(\"NO\n\");\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 문자열을 저장할 char 배열 s[11]을 선언하세요.  \n3. 정수형 변수 i, j, len, left, right를 선언하세요.  \n4. s 배열에 문자열을 입력 받으세요.  \n5. i를 0으로 초기화하여 문자열의 길이를 측정하는 루프를 시작하세요.  \n6. [rep_start(1)] 입력된 문자열의 각 문자에 대해 반복하세요.  \n7. 문자열의 끝을 확인하여 i를 증가시키세요.  \n8. [rep_end(1)]   \n9. len에 i의 값을 저장하여 문자열의 길이를 얻으세요.  \n10. i를 1로 초기화하여 분할을 시작할 루프를 시작하세요.  \n11. [rep_start(1)] i가 len보다 작은 동안 반복하세요.  \n12. 왼쪽 부분의 곱을 저장할 변수 left를 1로 초기화하세요.  \n13. 오른쪽 부분의 곱을 저장할 변수 right를 1로 초기화하세요.  \n14. j를 0으로 초기화하여 왼쪽 부분의 곱을 계산하는 루프를 시작하세요.  \n15. [rep_start(2)] j가 i보다 작은 동안 반복하세요.  \n16. left에 s[j]에서 '0'을 뺀 값을 곱하세요.  \n17. j를 증가시키세요.  \n18. [rep_end(2)]  \n19. j를 i로 초기화하여 오른쪽 부분의 곱을 계산하는 루프를 시작하세요.  \n20. [rep_start(2)] j가 len보다 작은 동안 반복하세요.  \n21. right에 s[j]에서 '0'을 뺀 값을 곱하세요.  \n22. j를 증가시키세요.  \n23. [rep_end(2)]  \n24. [cond_start(1)] 왼쪽과 오른쪽의 곱이 같은지 확인하는 조건문을 작성하세요.  \n25. 같다면 \"YES\"를 출력하고 프로그램을 종료하세요.  \n26. [cond_end(1)]  \n27. i를 증가시켜 다음 분할을 진행하세요.  \n28. [rep_end(1)]  \n29. \"NO\"를 출력하세요.  \n30. return 0;으로 프로그램을 종료하세요.  \n31. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint reverse(int n) {\n    int r = 0;\n\n    while (n > 0) {\n        r = r * 10 + (n % 10);\n        n = n / 10;\n    }\n\n    return r;\n}\n\nint main() {\n    int X, Y;\n    int RX, RY, sum, result;\n\n    scanf(\"%d %d\", &X, &Y);\n\n    RX = reverse(X);\n    RY = reverse(Y);\n\n    sum = RX + RY;\n\n    result = reverse(sum);\n\n    printf(\"%d\n\", result);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 reverse을 정의하세요. (매개변수: int n)\n2. 정수형 변수 r을 0으로 초기화하세요.\n3. [rep_start(1)] n이 0보다 큰 동안 반복하는 while 루프를 작성하세요.\n4. r에 n의 나머지를 10으로 나눈 값을 더한 후 10을 곱하여 저장하세요.\n5. n을 10으로 나누어 자릿수를 줄이세요.\n6. [rep_end(1)]\n7. r을 반환하여 n의 반전된 값을 제공하세요.\n8. [func_def_end(1)]\n9. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n10. 정수형 변수 X와 Y를 선언하세요.\n11. 결과를 저장할 정수형 변수 RX, RY, sum, result를 선언하세요.\n12. X와 Y에 입력을 받으세요.\n13. RX에 X의 반전된 값을 저장하기 위해 reverse 함수를 호출하세요.\n14. RY에 Y의 반전된 값을 저장하기 위해 reverse 함수를 호출하세요.\n15. RX와 RY의 합을 sum에 저장하세요.\n16. sum의 반전된 값을 result에 저장하기 위해 reverse 함수를 호출하세요.\n17. result를 출력하세요.\n18. return 0;으로 프로그램을 종료하세요.\n19. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char bin[1000001];\n    int i = 0;\n    int len;\n    int start;\n    int val;\n\n    scanf(\"%s\", bin);\n\n    while (bin[i] != '\u0000') {\n        i = i + 1;\n    }\n\n    len = i;\n    start = len % 3;\n\n    if (start == 1) {\n        val = bin[0] - '0';\n        printf(\"%d\", val);\n    }\n    else if (start == 2) {\n        val = (bin[0] - '0') * 2 + (bin[1] - '0');\n        printf(\"%d\", val);\n    }\n\n    i = start;\n    while (i < len) {\n        val = (bin[i] - '0') * 4 + (bin[i + 1] - '0') * 2 + (bin[i + 2] - '0');\n        printf(\"%d\", val);\n        i = i + 3;\n    }\n\n    printf(\"\n\");\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char 타입의 배열 bin을 1,000,001 크기로 선언하여 이진수를 저장할 공간을 확보하세요.\n3. int형 변수 i를 0으로 초기화하세요. (현재 인덱스)\n4. int형 변수 len, start, val을 선언하세요. (각각 길이, 시작 위치, 값 저장 용도)\n5. bin 배열에 이진수를 입력받기 위해 scanf를 사용하세요.\n6. [rep_start(1)] bin[i]가 널 문자가 아닐 동안 반복하세요.\n7. 현재 인덱스를 1 증가시켜서 다음 문자로 이동하세요.\n8. [rep_end(1)]\n9. len 변수를 i로 설정하여 입력받은 문자열의 길이를 저장하세요.\n10. len을 3으로 나눈 나머지를 start에 저장하세요. (3비트 단위 변환을 위해 필요)\n11. [cond_start(1)] start가 1인지 확인하는 조건문을 작성하세요.\n12. start가 1이면 bin[0]의 값을 정수형으로 변환하여 val에 저장하세요.\n13. val을 출력하세요.\n14. [cond_end(1)]\n15. [cond_start(1)] start가 2인지 확인하는 조건문을 작성하세요.\n16. start가 2이면 bin[0]의 값을 정수형으로 변환하고 2를 곱하여 bin[1]의 값을 더하여 val에 저장하세요.\n17. val을 출력하세요.\n18. [cond_end(1)]\n19. i를 start로 설정하고, [rep_start(1)] i가 len보다 작을 동안 반복하는 루프를 작성하세요.\n20. bin[i]의 값을 정수형으로 변환하여 4를 곱하고 bin[i+1]의 값을 2를 곱하여 더하며, bin[i+2]의 값을 더하여 val에 저장하세요.\n21. val을 출력하세요.\n22. 현재 인덱스를 3 증가시켜서 다음 3비트로 이동하세요.\n23. [rep_end(1)]\n24. 줄바꿈 문자 출력하세요.\n25. return 0;으로 프로그램을 종료하세요.\n26. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int T, a, b;\n    int i, j, result, power;\n\n    scanf(\"%d\", &T);\n\n    i = 0;\n    while (i < T) {\n        scanf(\"%d %d\", &a, &b);\n\n        power = 1;\n        j = 0;\n        while (j < b) {\n            power = power * a;\n            power = power % 10;\n            j = j + 1;\n        }\n\n        result = power;\n\n        if (result == 0) {\n            result = 10;\n        }\n\n        printf(\"%d\n\", result);\n\n        i = i + 1;\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 T, a, b를 선언하세요.  \n3. 정수형 변수 i, j, result, power를 선언하세요.  \n4. T의 값을 입력받으세요.  \n5. i를 0으로 초기화합니다.  \n6. [rep_start(1)] T번 만큼 반복하기 위한 while 루프를 작성하세요.  \n7. a와 b의 값을 입력받으세요.  \n8. power를 1로 초기화하세요.  \n9. j를 0으로 초기화합니다.  \n10. [rep_start(2)] j가 b보다 작은 동안 반복하기 위한 while 루프를 작성하세요.  \n11. a의 j승을 계산하기 위해 power를 a로 곱하세요.  \n12. power의 마지막 자리수를 구하기 위해 power를 10으로 나눈 나머지를 계산하세요.  \n13. j를 1 증가시키세요.  \n14. [rep_end(2)]  \n15. result에 power의 값을 할당하세요.  \n16. [cond_start(1)] result가 0인지 확인하는 조건문을 작성하세요.  \n17. result가 0이라면 result를 10으로 설정하세요.  \n18. [cond_end(1)]  \n19. result를 출력하세요.  \n20. i를 1 증가시키세요.  \n21. [rep_end(1)]  \n22. return 0;으로 프로그램을 종료하세요.  \n23. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, F;\n    int base, i;\n\n    scanf(\"%d\", &N);\n    scanf(\"%d\", &F);\n\n    base = N / 100 * 100;\n\n    i = 0;\n    while (i < 100) {\n        if ((base + i) % F == 0) {\n            if (i < 10) {\n                printf(\"0%d\n\", i);\n            }\n            else {\n                printf(\"%d\n\", i);\n            }\n            return 0;\n        }\n        i = i + 1;\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 N과 F를 선언하세요.  \n3. 정수형 변수 base와 i를 선언하세요.  \n4. N의 값을 입력받으세요.  \n5. F의 값을 입력받으세요.  \n6. base 변수에 N을 100으로 나누고 100을 곱해서 상수 부분을 저장하세요.  \n7. i를 0으로 초기화하세요.  \n8. [rep_start(1)] i가 100보다 작은 동안 반복하는 while 루프를 시작하세요.  \n9. [cond_start(2)] (base + i)가 F로 나누어지는지 확인하는 조건문을 작성하세요.  \n10. 나누어지면:  \n11. [cond_start(3)] i가 10보다 작은지 확인하는 조건문을 작성하세요.  \n12. i가 10보다 작다면 0을 붙여 출력하세요.  \n13. [cond_end(3)]  \n14. 그렇지 않으면 i를 그대로 출력하세요.  \n15. return 0;으로 함수를 종료하여 프로그램을 끝내세요.  \n16. [cond_end(2)]  \n17. i를 1 증가시키세요.  \n18. [rep_end(1)]  \n19. return 0;으로 프로그램을 종료하세요.  \n20. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char board[8][9];\n    int i, j;\n    int count = 0;\n\n    i = 0;\n    while (i < 8) {\n        scanf(\"%s\", board[i]);\n        i = i + 1;\n    }\n\n    i = 0;\n    while (i < 8) {\n        j = 0;\n        while (j < 8) {\n            if ((i + j) % 2 == 0) {\n                if (board[i][j] == 'F') {\n                    count = count + 1;\n                }\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n\n    printf(\"%d\n\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 2차원 배열 board를 8x9 크기로 선언하세요.\n3. int형 변수 i와 j를 선언하세요.\n4. int형 변수 count를 0으로 초기화하여 세기를 시작할 변수를 준비하세요.\n5. i를 0으로 초기화하여 첫 번째 행부터 시작하세요.\n6. [rep_start(1)] i가 8보다 작을 동안 반복하는 while 루프를 작성하세요.\n7. board[i]에 사용자 입력을 받아 저장하세요.\n8. 한 줄 입력 후 i를 1 증가시키세요.\n9. [rep_end(1)]\n10. i를 0으로 초기화하여 행을 다시 시작하세요.\n11. [rep_start(1)] i가 8보다 작을 동안 반복하는 while 루프를 작성하세요.\n12. j를 0으로 초기화하여 첫 번째 열부터 시작하세요.\n13. [rep_start(2)] j가 8보다 작을 동안 반복하는 while 루프를 작성하세요.\n14. [cond_start(2)] (i + j) 값이 짝수인지 확인하는 조건문을 작성하세요.\n15. [cond_start(3)] board[i][j]가 'F'인지 확인하는 조건문을 작성하세요.\n16. board[i][j]가 'F'라면 count를 1 증가시키세요.\n17. [cond_end(3)]\n18. [cond_end(2)]\n19. j를 1 증가시켜 다음 열로 이동하세요.\n20. [rep_end(2)]\n21. i를 1 증가시켜 다음 행으로 이동하세요.\n22. [rep_end(1)]\n23. count의 값을 출력하세요.\n24. return 0;으로 프로그램을 종료하세요.\n25. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char str[1000001];\n    int i = 0;\n    int count = 0;\n    int in_word = 0;\n\n    scanf(\"%[^\n]\", str);\n\n    while (str[i] != '\u0000') {\n        if (str[i] != ' ') {\n            if (in_word == 0) {\n                count = count + 1;\n                in_word = 1;\n            }\n        }\n        else {\n            in_word = 0;\n        }\n        i = i + 1;\n    }\n\n    printf(\"%d\n\", count);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 문자 배열 str을 길이 1000001로 선언하세요.\n3. 정수형 변수 i를 0으로 초기화하세요.\n4. 정수형 변수 count를 0으로 초기화하여 단어 수를 계산합니다.\n5. 정수형 변수 in_word를 0으로 초기화하여 현재 단어 상태를 추적합니다.\n6. str에서 공백 문자 이전까지 입력을 받는 scanf 함수를 사용하세요.\n7. [rep_start(1)] i를 사용하여 str 배열을 탐색하는 while 루프를 작성하세요.\n8. str[i]가 널 문자가 아닌지 확인하세요.\n9. [cond_start(2)] str[i]가 공백이 아닌지 확인하는 조건문을 작성하세요.\n10. in_word가 0이라면 단어의 시작을 표시합니다.\n11. count를 1 증가시키고 in_word를 1로 설정하세요.\n12. [cond_end(2)]\n13. [cond_start(2)] str[i]가 공백이라면 in_word를 0으로 설정하세요.\n14. [cond_end(2)]\n15. i를 1 증가시켜 다음 문자로 이동하세요.\n16. [rep_end(1)]\n17. count의 값을 출력하세요.\n18. return 0;으로 프로그램을 종료하세요.\n19. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    char name[31];\n    int count[26] = {0};\n    int i = 0;\n    int printed = 0;\n\n    scanf(\"%d\", &n);\n\n    while (i < n) {\n        scanf(\"%s\", name);\n        count[name[0] - 'a'] = count[name[0] - 'a'] + 1;\n        i = i + 1;\n    }\n\n    i = 0;\n\n    while (i < 26) {\n        if (count[i] >= 5) {\n            printf(\"%c\", i + 'a');\n            printed = 1;\n        }\n        i = i + 1;\n    }\n\n    if (printed == 0) {\n        printf(\"PREDAJA\");\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 길이가 31인 문자열 name을 선언하세요.\n4. 길이 26의 정수형 배열 count를 0으로 초기화하여 선언하세요.\n5. 정수형 변수 i를 0으로 초기화하여 선언하세요.\n6. 정수형 변수 printed를 0으로 초기화하여 선언하세요.\n7. n에 대한 입력을 받으세요.\n8. [rep_start(1)] i가 n보다 작을 동안 반복하는 while 루프를 작성하세요.\n9. 문자열 name에 대해 입력을 받으세요.\n10. name의 첫 글자를 기준으로 count 배열의 해당 인덱스를 1 증가시키세요.\n11. i를 1 증가시키세요.\n12. [rep_end(1)]\n13. i를 0으로 다시 초기화하세요.\n14. [rep_start(1)] i가 26보다 작을 동안 반복하는 while 루프를 작성하세요.\n15. [cond_start(2)] count[i]가 5 이상인지를 확인하는 조건문을 작성하세요.\n16. count[i]가 5 이상이라면 i에 해당하는 알파벳을 출력하세요.\n17. printed를 1로 설정하세요.\n18. i를 1 증가시키세요.\n19. [cond_end(2)]\n20. [rep_end(1)]\n21. [cond_start(1)] printed가 0인지 확인하는 조건문을 작성하세요.\n22. printed가 0이라면 \"PREDAJA\"를 출력하세요.\n23. [cond_end(1)]\n24. return 0;으로 프로그램을 종료하세요.\n25. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N, m, M, T, R;\n    int time = 0;\n    int pulse;\n    int exercise = 0;\n\n    scanf(\"%d %d %d %d %d\", &N, &m, &M, &T, &R);\n\n    pulse = m;\n\n    if (m + T > M) {\n        printf(\"-1\n\");\n        return 0;\n    }\n\n    while (exercise < N) {\n        if (pulse + T <= M) {\n            pulse = pulse + T;\n            exercise = exercise + 1;\n        }\n        else {\n            pulse = pulse - R;\n            if (pulse < m) {\n                pulse = m;\n            }\n        }\n        time = time + 1;\n    }\n\n    printf(\"%d\n\", time);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N, m, M, T, R을 선언하세요.\n3. time을 0으로 초기화하여 시간 변수를 선언하세요.\n4. pulse 변수를 선언하세요.\n5. exercise 변수를 0으로 초기화하여 운동한 횟수를 저장할 변수를 선언하세요.\n6. N, m, M, T, R에 대한 입력을 받으세요.\n7. pulse를 m으로 초기화하세요.\n8. [cond_start(1)] m + T가 M보다 큰지 확인하는 조건문을 작성하세요.\n9. m + T가 M보다 크면 -1을 출력하세요.\n10. 프로그램을 종료하기 위해 return 0;을 작성하세요.\n11. [cond_end(1)]\n12. [rep_start(1)] exercise가 N보다 작을 동안 반복하는 while 루프를 작성하세요.\n13. [cond_start(2)] pulse + T가 M보다 작거나 같은지 확인하는 조건문을 작성하세요.\n14. pulse에 T를 더하여 현재 맥박을 업데이트하세요.\n15. exercise를 1 증가시켜 운동한 횟수를 세세요.\n16. [cond_end(2)]\n17. 그렇지 않으면 pulse에서 R을 빼서 맥박을 감소시키세요.\n18. [cond_start(3)] pulse가 m보다 작은지 확인하는 조건문을 작성하세요.\n19. pulse가 m보다 작다면 pulse를 m으로 설정하세요.\n20. [cond_end(3)]\n21. time을 1 증가시켜 시간을 세세요.\n22. [rep_end(1)]\n23. time을 출력하세요.\n24. return 0;으로 프로그램을 종료하세요.\n25. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char oct[333336];\n    int i = 0;\n    int start = 0;\n\n    scanf(\"%s\", oct);\n\n    while (oct[i] != '\u0000') {\n        int digit = oct[i] - '0';\n        int b2 = digit % 2;\n        int b1 = (digit / 2) % 2;\n        int b0 = (digit / 4) % 2;\n\n        if (i == 0) {\n            if (digit >= 4) {\n                printf(\"%d%d%d\", b0, b1, b2);\n            }\n            else if (digit >= 2) {\n                printf(\"%d%d\", b1, b2);\n            }\n            else {\n                printf(\"%d\", b2);\n            }\n        }\n        else {\n            printf(\"%d%d%d\", b0, b1, b2);\n        }\n\n        i = i + 1;\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 배열 oct를 선언하여 333336개의 문자를 저장할 수 있게 합니다.\n3. 정수형 변수 i를 0으로 초기화합니다. (배열의 인덱스로 사용)\n4. 정수형 변수 start를 0으로 초기화하지만, 사용되지 않습니다.\n5. oct 배열에 문자열을 입력받기 위해 scanf 함수를 호출합니다.\n6. [rep_start(1)] oct의 i번째 요소가 널 문자가 아닐 때까지 반복하는 while 루프를 작성하세요.\n7. 입력받은 문자를 정수형 digit 변수에 10진수로 저장합니다.\n8. digit 값을 2진수로 변환하기 위한 계산을 수행합니다. (b2는 digit의 1의 자리, b1은 2의 자리, b0은 4의 자리)\n9. [cond_start(1)] i가 0인지 확인하는 조건문을 작성하세요.\n10. [cond_start(2)] digit이 4 이상인지 확인하는 조건문을 작성하세요.\n11. digit이 4 이상이라면, b0, b1, b2를 출력하세요.\n12. [cond_end(2)]\n13. [cond_start(2)] digit이 2 이상인지 확인하는 조건문을 작성하세요.\n14. digit이 2 이상이라면, b1과 b2를 출력하세요.\n15. [cond_end(2)]\n16. 그렇지 않으면, b2를 출력하세요.\n17. [cond_end(1)]\n18. [cond_start(1)] i가 0이 아닌 경우의 조건문을 작성하세요.\n19. i가 0이 아니면, b0, b1, b2를 출력하세요.\n20. [cond_end(1)]\n21. i를 1 증가시켜 다음 숫자로 넘어갑니다.\n22. [rep_end(1)]\n23. return 0;으로 프로그램을 종료하세요.\n24. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char a[10001];\n    char b[10001];\n    int i = 0;\n    int j = 0;\n    long long sum = 0;\n\n    scanf(\"%s %s\", a, b);\n\n    while (a[i] != '\u0000') {\n        j = 0;\n        while (b[j] != '\u0000') {\n            sum = sum + (a[i] - '0') * (b[j] - '0');\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n\n    printf(\"%lld\n\", sum);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 배열 a를 10001 크기로 선언하세요.\n3. char형 배열 b를 10001 크기로 선언하세요.\n4. 정수형 변수 i를 0으로 초기화하세요.\n5. 정수형 변수 j를 0으로 초기화하세요.\n6. long long형 변수 sum을 0으로 초기화하세요.\n7. a와 b에 문자열을 입력 받으세요.\n8. [rep_start(1)] a의 각 문자를 처리하기 위한 while 반복문을 작성하세요.\n9. a[i]가 null이 아닐 때 반복을 계속하세요.\n10. j를 0으로 초기화하여 b의 각 문자를 처리하기 위한 중첩 while 루프를 작성하세요.\n11. [rep_start(2)] b의 각 문자를 처리하기 위한 while 반복문을 작성하세요.\n12. b[j]가 null이 아닐 때 반복을 계속하세요.\n13. a[i]와 b[j]를 각각 숫자로 변환하여 sum에 곱한 값을 더하세요.\n14. j를 1 증가시켜 다음 b의 문자로 이동하세요.\n15. [rep_end(2)]\n16. i를 1 증가시켜 다음 a의 문자로 이동하세요.\n17. [rep_end(1)]\n18. sum의 값을 출력하세요.\n19. return 0;으로 프로그램을 종료하세요.\n20. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int S1, S2, S3;\n    int count[121] = {0};\n    int i = 1;\n    int j = 1;\n    int k = 1;\n    int max = 0;\n    int result = 0;\n\n    scanf(\"%d %d %d\", &S1, &S2, &S3);\n\n    i = 1;\n    while (i <= S1) {\n        j = 1;\n        while (j <= S2) {\n            k = 1;\n            while (k <= S3) {\n                count[i + j + k] = count[i + j + k] + 1;\n                k = k + 1;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n\n    i = 3;\n    while (i <= S1 + S2 + S3) {\n        if (count[i] > max) {\n            max = count[i];\n            result = i;\n        }\n        i = i + 1;\n    }\n\n    printf(\"%d\n\", result);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 S1, S2, S3를 선언하세요.\n3. 정수형 배열 count를 크기 121로 선언하고 모든 요소를 0으로 초기화하세요.\n4. 정수형 변수 i, j, k, max, result를 각각 1, 1, 1, 0, 0으로 초기화하세요.\n5. S1, S2, S3의 값을 입력받으세요.\n6. i를 1부터 S1까지 반복하는 while 루프를 작성하세요.\n7. j를 1부터 S2까지 반복하는 while 루프를 작성하세요.\n8. k를 1부터 S3까지 반복하는 while 루프를 작성하세요.\n9. count 배열의 (i + j + k)번째 요소를 1씩 증가시키세요.\n10. k를 1씩 증가시키세요.\n11. [rep_end(3)]\n12. j를 1씩 증가시키세요.\n13. [rep_end(2)]\n14. i를 1씩 증가시키세요.\n15. [rep_end(1)]\n16. i를 3으로 초기화하세요.\n17. i가 S1 + S2 + S3까지 반복하는 while 루프를 작성하세요.\n18. [cond_start(1)] count 배열의 i번째 요소가 max보다 큰지 확인하는 조건문을 작성하세요.\n19. max에 count[i]를 할당하고, result에 i를 할당하세요.\n20. [cond_end(1)]\n21. i를 1씩 증가시키세요.\n22. [rep_end(1)]\n23. result 값을 출력하세요.\n24. return 0;으로 프로그램을 종료하세요.\n25. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char c;\n    int freq[26] = {0};\n    int i, max = 0;\n\n    while((c = getchar()) != EOF) {\n        if((c >= 'a') && (c <= 'z')) {\n            freq[c - 'a']++;\n        }\n    }\n\n    for(i = 0; i < 26; i++) {\n        if(freq[i] > max) {\n            max = freq[i];\n        }\n    }\n\n    for(i = 0; i < 26; i++) {\n        if(freq[i] == max) {\n            putchar(i + 'a');\n        }\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 변수 c를 선언하세요.\n3. 26개의 정수를 저장할 배열 freq를 0으로 초기화하여 선언하세요. (알파벳 빈도 수를 저장)\n4. int형 변수 i와 max를 선언하고, max를 0으로 초기화하세요.\n5. [rep_start(1)] getchar()를 통해 입력을 받을 때 EOF에 도달할 때까지 반복하는 while 루프를 작성하세요.\n6. [cond_start(2)] c가 소문자 알파벳인지 확인하는 조건문을 작성하세요.\n7. c가 소문자 알파벳이라면 해당 알파벳의 빈도를 1 증가시키세요. (freq[c - 'a']++)\n8. [cond_end(2)]\n9. [rep_end(1)]\n10. [rep_start(1)] 0부터 25까지 반복하는 for 루프를 작성하세요.\n11. [cond_start(2)] freq 배열의 i번째 요소가 max보다 큰지 확인하는 조건문을 작성하세요.\n12. 빈도 수가 max보다 크다면 max를 freq[i]로 업데이트하세요.\n13. [cond_end(2)]\n14. [rep_end(1)]\n15. [rep_start(1)] 0부터 25까지 반복하는 for 루프를 작성하세요.\n16. [cond_start(2)] freq 배열의 i번째 요소가 max와 같은지 확인하는 조건문을 작성하세요.\n17. 빈도 수가 max와 같다면 해당 문자(i + 'a')를 출력하세요.\n18. [cond_end(2)]\n19. [rep_end(1)]\n20. return 0;으로 프로그램을 종료하세요.\n21. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int x, y, w, h;\n    int min;\n\n    scanf(\"%d %d %d %d\", &x, &y, &w, &h);\n\n    min = x;\n\n    if(y < min) {\n        min = y;\n    }\n\n    if((w - x) < min) {\n        min = w - x;\n    }\n\n    if((h - y) < min) {\n        min = h - y;\n    }\n\n    printf(\"%d\n\", min);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 x, y, w, h를 선언하세요.  \n3. 소수점 이하의 값을 저장할 int형 변수 min을 선언하세요.  \n4. M과 N에 입력을 받으세요.  \n5. min에 x의 값을 할당하세요.  \n6. [cond_start(1)] y가 min보다 작은지 확인하는 조건문을 작성하세요.  \n7. y가 min보다 작다면 min에 y의 값을 할당하세요.  \n8. [cond_end(1)]  \n9. [cond_start(1)] (w - x)가 min보다 작은지 확인하는 조건문을 작성하세요.  \n10. (w - x)가 min보다 작다면 min에 (w - x)의 값을 할당하세요.  \n11. [cond_end(1)]  \n12. [cond_start(1)] (h - y)가 min보다 작은지 확인하는 조건문을 작성하세요.  \n13. (h - y)가 min보다 작다면 min에 (h - y)의 값을 할당하세요.  \n14. [cond_end(1)]  \n15. min의 값을 출력하세요.  \n16. return 0;으로 프로그램을 종료하세요.  \n17. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i;\n    int t;\n    int y = 0;\n    int m = 0;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        scanf(\"%d\", &t);\n\n        y = y + ((t / 30) + 1) * 10;\n        m = m + ((t / 60) + 1) * 15;\n    }\n\n    if(y < m) {\n        printf(\"Y %d\n\", y);\n    }\n    else if(m < y) {\n        printf(\"M %d\n\", m);\n    }\n    else {\n        printf(\"Y M %d\n\", y);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n과 i를 선언하세요.\n3. 정수형 변수 t와 y, m을 각각 선언하고 0으로 초기화하세요.\n4. n에 대한 입력을 받으세요.\n5. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n6. t에 대한 입력을 받으세요.\n7. y에 t를 30으로 나누고 1을 더한 값을 10과 곱해 더하세요.\n8. m에 t를 60으로 나누고 1을 더한 값을 15와 곱해 더하세요.\n9. [rep_end(1)]\n10. [cond_start(1)] y가 m보다 작은지 확인하는 조건문을 작성하세요.\n11. y가 m보다 작다면 Y와 y의 값을 출력하세요.\n12. [cond_end(1)]\n13. [cond_start(1)] m이 y보다 작은지 확인하는 조건문을 작성하세요.\n14. m이 y보다 작다면 M과 m의 값을 출력하세요.\n15. [cond_end(1)]\n16. [cond_start(1)] y와 m이 같은 경우를 처리하는 조건문을 작성하세요.\n17. y와 m이 같다면 Y와 M의 값, 즉 y를 출력하세요.\n18. [cond_end(1)]\n19. return 0;으로 프로그램을 종료하세요.\n20. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int m, i;\n    int x, y;\n    int pos = 1;\n    int cup[4] = {0, 1, 0, 0};\n\n    scanf(\"%d\", &m);\n\n    for(i = 0; i < m; i++) {\n        scanf(\"%d %d\", &x, &y);\n\n        int temp = cup[x];\n        cup[x] = cup[y];\n        cup[y] = temp;\n    }\n\n    for(i = 1; i <= 3; i++) {\n        if(cup[i] == 1) {\n            printf(\"%d\n\", i);\n            return 0;\n        }\n    }\n\n    printf(\"-1\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 m과 i를 선언하세요.\n3. 정수형 변수 x와 y를 선언하세요.\n4. pos라는 정수형 변수를 1로 초기화하세요.\n5. 정수형 배열 cup을 선언하고, 4개의 요소를 0, 1, 0, 0으로 초기화하세요.\n6. m의 값에 대한 입력을 받으세요.\n7. [rep_start(1)] i를 0부터 m-1까지 반복하는 for 루프를 작성하세요.\n8. x와 y의 값에 대한 입력을 받으세요.\n9. cup 배열에서 x의 값을 temp에 저장하세요.\n10. cup[x]에 cup[y]의 값을 저장하세요.\n11. cup[y]에 temp를 저장하여 두 값을 교환하세요.\n12. [rep_end(1)]\n13. [rep_start(1)] i를 1부터 3까지 반복하는 for 루프를 작성하세요.\n14. [cond_start(2)] cup[i]의 값이 1인지 확인하는 조건문을 작성하세요.\n15. cup[i]가 1이라면 i 값을 출력하세요.\n16. 프로그램을 종료하고 0을 반환하세요.\n17. [cond_end(2)]\n18. [rep_end(1)]\n19. -1을 출력하여 아무 값을 찾지 못했음을 알리세요.\n20. return 0;으로 프로그램을 종료하세요.\n21. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int a, b;\n    int ax, ay, bx, by;\n    int dx, dy;\n\n    scanf(\"%d %d\", &a, &b);\n\n    ax = (a - 1) / 4;\n    ay = (a - 1) % 4;\n\n    bx = (b - 1) / 4;\n    by = (b - 1) % 4;\n\n    dx = ax - bx;\n    if(dx < 0) {\n        dx = -dx;\n    }\n\n    dy = ay - by;\n    if(dy < 0) {\n        dy = -dy;\n    }\n\n    printf(\"%d\n\", dx + dy);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 a와 b를 선언하세요.\n3. 정수형 변수 ax, ay, bx, by를 선언하세요.\n4. 정수형 변수 dx, dy를 선언하세요.\n5. M과 N에 입력을 받으세요.\n6. ax에 (a - 1)를 4로 나눈 몫을 저장하세요.\n7. ay에 (a - 1)을 4로 나눈 나머지를 저장하세요.\n8. bx에 (b - 1)를 4로 나눈 몫을 저장하세요.\n9. by에 (b - 1)을 4로 나눈 나머지를 저장하세요.\n10. dx에 ax에서 bx을 뺀 값을 저장하세요.\n11. [cond_start(1)] dx가 0보다 작은지 확인하는 조건문을 작성하세요.\n12. dx가 0보다 작다면 dx를 -dx로 변경하세요.\n13. [cond_end(1)]\n14. dy에 ay에서 by을 뺀 값을 저장하세요.\n15. [cond_start(2)] dy가 0보다 작은지 확인하는 조건문을 작성하세요.\n16. dy가 0보다 작다면 dy를 -dy로 변경하세요.\n17. [cond_end(2)]\n18. dx와 dy의 합을 출력하세요.\n19. return 0;으로 프로그램을 종료하세요.\n20. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char p[102];\n    int k;\n    int i, r;\n    int mod;\n\n    scanf(\"%s %d\", p, &k);\n\n    for(r = 2; r < k; r++) {\n        mod = 0;\n\n        for(i = 0; p[i] != '\u0000'; i++) {\n            mod = (mod * 10 + (p[i] - '0')) % r;\n        }\n\n        if(mod == 0) {\n            printf(\"BAD %d\n\", r);\n            return 0;\n        }\n    }\n\n    printf(\"GOOD\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. char형 배열 p를 102 크기로 선언하세요. (입력받을 문자열)\n3. int형 변수 k를 선언하세요. (정수 입력)\n4. 정수형 변수 i와 r을 선언하세요. (루프 인덱스 및 나누기 수)\n5. int형 mod 변수를 선언하세요. (모듈로 결과 저장)\n6. 사용자가 문자열 p와 정수 k를 입력하게 하세요.\n7. [rep_start(1)] r을 2부터 k-1까지 반복하는 for 루프를 작성하세요.\n8. mod 변수를 0으로 초기화하세요.\n9. [rep_start(2)] p의 각 문자에 대해 반복하는 for 루프를 작성하세요.\n10. p의 i번째 문자를 0-9 숫자로 변환하여 mod를 갱신하세요.\n11. [rep_end(2)]\n12. [cond_start(1)] mod가 0인지 확인하는 조건문을 작성하세요.\n13. mod가 0이라면 \"BAD\"와 r 값을 출력하세요.\n14. 프로그램을 종료하세요.\n15. [cond_end(1)]\n16. [rep_end(1)]\n17. \"GOOD\"을 출력하세요.\n18. return 0;으로 프로그램을 종료하세요.\n19. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i;\n    int plugs;\n    int total = 0;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        scanf(\"%d\", &plugs);\n        total = total + plugs;\n    }\n\n    total = total - (n - 1);\n\n    printf(\"%d\n\", total);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n과 i를 선언하세요.\n3. 정수형 변수 plugs를 선언하세요.\n4. 총 합을 저장할 int형 변수 total을 0으로 초기화하세요.\n5. n값을 입력받기 위해 scanf를 호출하세요.\n6. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n7. 각 반복에서 plugs 값을 입력받기 위해 scanf를 호출하세요.\n8. total에 plugs의 값을 더하세요.\n9. [rep_end(1)]\n10. total에서 (n-1)를 빼세요. (연결되는 플러그를 제외하기 위함)\n11. total 값을 출력하기 위해 printf를 호출하세요.\n12. [func_def_end(1)]\n13. return 0;으로 프로그램을 종료하세요."
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i, j;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        for(j = 0; j < i; j++) {\n            printf(\" \");\n        }\n        for(j = 0; j < n - i; j++) {\n            printf(\"*\");\n        }\n        printf(\"\n\");\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n, i, j를 선언하세요.\n3. n에 대한 입력을 받으세요.\n4. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n5. [rep_start(2)] j를 0부터 i-1까지 반복하는 for 루프를 작성하여 공백을 출력하세요.\n6. 공백을 출력하세요.\n7. [rep_end(2)]\n8. [rep_start(2)] j를 0부터 n-i-1까지 반복하는 for 루프를 작성하여 '*'를 출력하세요.\n9. '*'를 출력하세요.\n10. [rep_end(2)]\n11. 줄 바꿈을 출력하세요.\n12. [rep_end(1)]\n13. return 0;으로 프로그램을 종료하세요.\n14. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i, j;\n\n    scanf(\"%d\", &n);\n\n    for(i = 1; i <= n; i++) {\n        for(j = 0; j < n - i; j++) {\n            printf(\" \");\n        }\n        for(j = 0; j < 2 * i - 1; j++) {\n            printf(\"*\");\n        }\n        printf(\"\n\");\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n, i, j를 선언하세요.\n3. n의 값을 입력받으세요.\n4. [rep_start(1)] i를 선언해 1부터 n까지 반복하는 for 루프를 작성하세요.\n5. [rep_start(2)] j를 선언해 0부터 n-i-1까지 반복하는 for 루프를 작성하세요.\n6. 공백 문자(\" \")를 출력하여 피라미드 모양의 왼쪽 부분을 만드세요.\n7. [rep_end(2)]\n8. [rep_start(2)] j를 선언해 0부터 2*i-1까지 반복하는 for 루프를 작성하세요.\n9. 별 문자(\"*\")를 출력하여 피라미드의 가운데 부분을 만드세요.\n10. [rep_end(2)]\n11. 줄바꿈을 출력하여 다음 줄로 이동하세요.\n12. [rep_end(1)]\n13. return 0;으로 프로그램을 종료하세요.\n14. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int i;\n    int out, in;\n    int current = 0;\n    int max = 0;\n\n    for(i = 0; i < 4; i++) {\n        scanf(\"%d %d\", &out, &in);\n        current = current - out + in;\n        if(current > max) {\n            max = current;\n        }\n    }\n\n    printf(\"%d\n\", max);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 i를 선언하세요.\n3. 정수형 변수 out과 in을 선언하세요.\n4. 현재 승객 수를 저장할 int형 변수 current를 0으로 초기화하세요.\n5. 최대 승객 수를 저장할 int형 변수 max를 0으로 초기화하세요.\n6. [rep_start(1)] i를 선언해 0부터 3까지 반복하는 for 루프를 작성하세요.\n7. scanf를 이용하여 out과 in의 값을 입력받으세요.\n8. 현재 승객 수를 업데이트하기 위해 current에서 out을 빼고 in을 더하세요.\n9. [cond_start(1)] 현재 승객 수(current)가 최대 승객 수(max)보다 큰지 확인하는 조건문을 작성하세요.\n10. 현재 승객 수가 더 크다면 최대 승객 수(max)를 현재 승객 수(current)로 업데이트하세요.\n11. [cond_end(1)]\n12. [rep_end(1)]\n13. 최대 승객 수(max)를 출력하세요.\n14. return 0;으로 프로그램을 종료하세요.\n15. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int i;\n    int a, b, c;\n    int reward;\n    int max = 0;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &a, &b, &c);\n\n        if((a == b) && (b == c)) {\n            reward = 10000 + (a * 1000);\n        }\n        else if((a == b) || (a == c)) {\n            reward = 1000 + (a * 100);\n        }\n        else if(b == c) {\n            reward = 1000 + (b * 100);\n        }\n        else {\n            if((a > b) && (a > c)) {\n                reward = a * 100;\n            }\n            else if(b > c) {\n                reward = b * 100;\n            }\n            else {\n                reward = c * 100;\n            }\n        }\n\n        if(reward > max) {\n            max = reward;\n        }\n    }\n\n    printf(\"%d\n\", max);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 정수형 변수 i를 선언하세요.\n4. 정수형 변수 a, b, c를 선언하세요.\n5. 정수형 변수 reward를 선언하세요.\n6. 정수형 변수 max를 0으로 초기화하세요.\n7. n의 값을 입력받으세요.\n8. [rep_start(1)] i를 0으로 초기화하고 n보다 작은 동안 반복하는 for 루프를 작성하세요.\n9. a, b, c의 값을 입력받으세요.\n10. [cond_start(2)] a, b, c가 모두 같은지 확인하는 조건문을 작성하세요.\n11. a, b, c가 모두 같다면 reward를 10000 + (a * 1000)으로 설정하세요.\n12. [cond_end(2)]\n13. [cond_start(2)] a와 b가 같거나 a와 c가 같은지 확인하는 조건문을 작성하세요.\n14. a와 b 또는 a와 c가 같다면 reward를 1000 + (a * 100)으로 설정하세요.\n15. [cond_end(2)]\n16. [cond_start(2)] b와 c가 같은지 확인하는 조건문을 작성하세요.\n17. b와 c가 같다면 reward를 1000 + (b * 100)으로 설정하세요.\n18. [cond_end(2)]\n19. [cond_start(2)] a, b, c가 모두 다를 경우를 처리하는 조건문을 작성하세요.\n20. [cond_start(3)] a가 b와 c보다 큰지 확인하는 조건문을 작성하세요.\n21. a가 가장 크다면 reward를 a * 100으로 설정하세요.\n22. [cond_end(3)]\n23. [cond_start(3)] b가 c보다 큰지 확인하는 조건문을 작성하세요.\n24. b가 가장 크다면 reward를 b * 100으로 설정하세요.\n25. [cond_end(3)]\n26. 그렇지 않으면 reward를 c * 100으로 설정하세요.\n27. [cond_end(2)]\n28. [cond_start(2)] 현재 reward가 max보다 큰지 확인하는 조건문을 작성하세요.\n29. reward가 max보다 크다면 max를 reward로 업데이트하세요.\n30. [cond_end(2)]\n31. [rep_end(1)]\n32. max의 값을 출력하세요.\n33. return 0;으로 프로그램을 종료하세요.\n34. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int S1, S2, S3;\n    int count[121] = {0};\n    int i = 1;\n    int j = 1;\n    int k = 1;\n    int max = 0;\n    int result = 0;\n\n    scanf(\"%d %d %d\", &S1, &S2, &S3);\n\n    i = 1;\n    while (i <= S1) {\n        j = 1;\n        while (j <= S2) {\n            k = 1;\n            while (k <= S3) {\n                count[i + j + k] = count[i + j + k] + 1;\n                k = k + 1;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n    }\n\n    i = 3;\n    while (i <= S1 + S2 + S3) {\n        if (count[i] > max) {\n            max = count[i];\n            result = i;\n        }\n        i = i + 1;\n    }\n\n    printf(\"%d\n\", result);\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 S1, S2, S3를 선언하세요.\n3. 정수형 배열 count를 크기 121로 선언하고 모든 요소를 0으로 초기화하세요.\n4. 정수형 변수 i, j, k를 각각 1로 초기화하세요.\n5. 정수형 변수 max와 result를 0으로 초기화하세요.\n6. 사용자가 S1, S2, S3의 값을 입력하도록 요청하세요.\n7. i를 1로 초기화하세요.\n8. [rep_start(1)] i가 S1 이하인 동안 반복하는 while 루프를 작성하세요.\n9. j를 1로 초기화하세요.\n10. [rep_start(2)] j가 S2 이하인 동안 반복하는 while 루프를 작성하세요.\n11. k를 1로 초기화하세요.\n12. [rep_start(3)] k가 S3 이하인 동안 반복하는 while 루프를 작성하세요.\n13. count 배열의 (i + j + k) 번째 요소를 1 증가시키세요.\n14. k를 1 증가시키세요.\n15. [rep_end(3)]\n16. j를 1 증가시키세요.\n17. [rep_end(2)]\n18. i를 1 증가시키세요.\n19. [rep_end(1)]\n20. i를 3으로 초기화하세요.\n21. [rep_start(1)] i가 S1+S2+S3 이하인 동안 반복하는 while 루프를 작성하세요.\n22. [cond_start(2)] count[i]가 max보다 큰지 확인하는 조건문을 작성하세요.\n23. count[i]가 max보다 크면 max를 count[i]로 업데이트하고 result를 i로 설정하세요.\n24. [cond_end(2)]\n25. i를 1 증가시키세요.\n26. [rep_end(1)]\n27. result를 출력하세요.\n28. return 0;으로 프로그램을 종료하세요.\n29. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char c;\n    int freq[26] = {0};\n    int i, max = 0;\n\n    while((c = getchar()) != EOF) {\n        if((c >= 'a') && (c <= 'z')) {\n            freq[c - 'a']++;\n        }\n    }\n\n    for(i = 0; i < 26; i++) {\n        if(freq[i] > max) {\n            max = freq[i];\n        }\n    }\n\n    for(i = 0; i < 26; i++) {\n        if(freq[i] == max) {\n            putchar(i + 'a');\n        }\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 문자형 변수 c를 선언하세요.\n3. 정수형 배열 freq[26]을 0으로 초기화하여 알파벳의 빈도수를 저장할 공간을 만드세요.\n4. 정수형 변수 i와 max를 선언하고, max를 0으로 초기화하세요.\n5. [rep_start(1)] getchar()를 이용하여 문자를 입력받는 while 루프를 시작하세요.\n6. [cond_start(2)] 입력받은 문자가 EOF인지 확인하는 조건문을 작성하세요.\n7. EOF가 아니라면 루프를 계속 진행하세요.\n8. [cond_end(2)]\n9. [cond_start(2)] 입력받은 문자가 소문자 알파벳인지 확인하는 조건문을 작성하세요.\n10. 소문자라면 해당 문자의 빈도를 freq 배열에서 증가시키세요.\n11. [cond_end(2)]\n12. [rep_end(1)]\n13. [rep_start(1)] 0부터 25까지 반복하는 for 루프를 시작하세요.\n14. [cond_start(2)] freq[i]가 max보다 큰지 확인하는 조건문을 작성하세요.\n15. freq[i]가 max보다 크면 max를 freq[i]로 업데이트하세요.\n16. [cond_end(2)]\n17. [rep_end(1)]\n18. [rep_start(1)] 0부터 25까지 반복하는 for 루프를 시작하세요.\n19. [cond_start(2)] freq[i]가 max와 같은지 확인하는 조건문을 작성하세요.\n20. freq[i]가 max와 같으면 i에 해당하는 문자를 출력하세요.\n21. [cond_end(2)]\n22. [rep_end(1)]\n23. return 0;으로 프로그램을 종료하세요.\n24. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int x, y, w, h;\n    int min;\n\n    scanf(\"%d %d %d %d\", &x, &y, &w, &h);\n\n    min = x;\n\n    if(y < min) {\n        min = y;\n    }\n\n    if((w - x) < min) {\n        min = w - x;\n    }\n\n    if((h - y) < min) {\n        min = h - y;\n    }\n\n    printf(\"%d\n\", min);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 x, y, w, h를 선언하세요.\n3. 정수형 변수 min을 선언하세요.\n4. x, y, w, h에 대한 입력을 받으세요.\n5. min에 x의 값을 초기화하세요.\n6. [cond_start(1)] y가 min보다 작은지 확인하는 조건문을 작성하세요.\n7. y가 min보다 작다면 min에 y의 값을 설정하세요.\n8. [cond_end(1)]\n9. [cond_start(1)] w - x가 min보다 작은지 확인하는 조건문을 작성하세요.\n10. w - x가 min보다 작다면 min에 w - x의 값을 설정하세요.\n11. [cond_end(1)]\n12. [cond_start(1)] h - y가 min보다 작은지 확인하는 조건문을 작성하세요.\n13. h - y가 min보다 작다면 min에 h - y의 값을 설정하세요.\n14. [cond_end(1)]\n15. min 값을 출력하세요.\n16. return 0;으로 프로그램을 종료하세요.\n17. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i;\n    int t;\n    int y = 0;\n    int m = 0;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        scanf(\"%d\", &t);\n\n        y = y + ((t / 30) + 1) * 10;\n        m = m + ((t / 60) + 1) * 15;\n    }\n\n    if(y < m) {\n        printf(\"Y %d\n\", y);\n    }\n    else if(m < y) {\n        printf(\"M %d\n\", m);\n    }\n    else {\n        printf(\"Y M %d\n\", y);\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n과 i를 선언하세요.\n3. 정수형 변수 t를 선언하세요.\n4. 요금 Y에 대한 int형 변수 y를 0으로 초기화하세요.\n5. 요금 M에 대한 int형 변수 m을 0으로 초기화하세요.\n6. n에 대한 입력을 받으세요.\n7. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n8. 각 반복에서 t에 대한 입력을 받으세요.\n9. y에 t를 30초 단위로 나눈 몫에 1을 더한 후 10을 곱한 값을 더하세요.\n10. m에 t를 60초 단위로 나눈 몫에 1을 더한 후 15를 곱한 값을 더하세요.\n11. [rep_end(1)]\n12. [cond_start(1)] y가 m보다 작은지 확인하는 조건문을 작성하세요.\n13. y가 m보다 작으면 \"Y\"와 요금 y를 출력하세요.\n14. [cond_end(1)]\n15. [cond_start(1)] m이 y보다 작은지 확인하는 조건문을 작성하세요.\n16. m이 y보다 작으면 \"M\"과 요금 m을 출력하세요.\n17. [cond_end(1)]\n18. [cond_start(1)] y와 m이 같은지 확인하는 조건문을 작성하세요.\n19. y와 m이 같으면 \"Y M\"과 요금 y를 출력하세요.\n20. [cond_end(1)]\n21. return 0;으로 프로그램을 종료하세요.\n22. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int m, i;\n    int x, y;\n    int pos = 1;\n    int cup[4] = {0, 1, 0, 0};\n\n    scanf(\"%d\", &m);\n\n    for(i = 0; i < m; i++) {\n        scanf(\"%d %d\", &x, &y);\n\n        int temp = cup[x];\n        cup[x] = cup[y];\n        cup[y] = temp;\n    }\n\n    for(i = 1; i <= 3; i++) {\n        if(cup[i] == 1) {\n            printf(\"%d\n\", i);\n            return 0;\n        }\n    }\n\n    printf(\"-1\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 m과 i를 선언하세요.  \n3. 정수형 변수 x와 y를 선언하세요.  \n4. pos 변수를 1로 초기화합니다.  \n5. 정수형 배열 cup을 선언하고 초기값을 {0, 1, 0, 0}으로 설정합니다.  \n6. m의 값을 입력 받으세요.  \n7. [rep_start(1)] m번 만큼 반복하는 for 루프를 작성하세요.  \n8. x와 y의 값을 입력 받으세요.  \n9. cup 배열의 x 위치의 값을 temp 변수에 저장합니다.  \n10. cup 배열의 x 위치에 y 위치의 값을 저장합니다.  \n11. cup 배열의 y 위치에 temp의 값을 저장합니다.  \n12. [rep_end(1)]  \n13. [rep_start(1)] i를 1부터 3까지 반복하는 for 루프를 작성하세요.  \n14. [cond_start(2)] cup[i]가 1인지 확인하는 조건문을 작성하세요.  \n15. cup[i]가 1이라면 i를 출력하세요.  \n16. 프로그램을 종료합니다.  \n17. [cond_end(2)]  \n18. [rep_end(1)]  \n19. cup 배열에서 1이 없으면 -1을 출력하세요.  \n20. return 0;으로 프로그램을 종료하세요.  \n21. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int a, b;\n    int ax, ay, bx, by;\n    int dx, dy;\n\n    scanf(\"%d %d\", &a, &b);\n\n    ax = (a - 1) / 4;\n    ay = (a - 1) % 4;\n\n    bx = (b - 1) / 4;\n    by = (b - 1) % 4;\n\n    dx = ax - bx;\n    if(dx < 0) {\n        dx = -dx;\n    }\n\n    dy = ay - by;\n    if(dy < 0) {\n        dy = -dy;\n    }\n\n    printf(\"%d\n\", dx + dy);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 a와 b를 선언하세요.\n3. 정수형 변수 ax, ay, bx, by를 선언하세요.\n4. 정수형 변수 dx와 dy를 선언하세요.\n5. M과 N에 입력을 받으세요.\n6. ax를 계산하여 a를 4로 나눈 몫으로 설정하세요.\n7. ay를 계산하여 a를 4로 나눈 나머지로 설정하세요.\n8. bx를 계산하여 b를 4로 나눈 몫으로 설정하세요.\n9. by를 계산하여 b를 4로 나눈 나머지로 설정하세요.\n10. dx를 ax와 bx의 차로 설정하세요.\n11. [cond_start(1)] dx가 0보다 작은지 확인하는 조건문을 작성하세요.\n12. dx가 음수라면 그 값을 절대값으로 변환하세요.\n13. [cond_end(1)]\n14. dy를 ay와 by의 차로 설정하세요.\n15. [cond_start(1)] dy가 0보다 작은지 확인하는 조건문을 작성하세요.\n16. dy가 음수라면 그 값을 절대값으로 변환하세요.\n17. [cond_end(1)]\n18. dx와 dy의 합계를 출력하세요.\n19. return 0;으로 프로그램을 종료하세요.\n20. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    char p[102];\n    int k;\n    int i, r;\n    int mod;\n\n    scanf(\"%s %d\", p, &k);\n\n    for(r = 2; r < k; r++) {\n        mod = 0;\n\n        for(i = 0; p[i] != '\u0000'; i++) {\n            mod = (mod * 10 + (p[i] - '0')) % r;\n        }\n\n        if(mod == 0) {\n            printf(\"BAD %d\n\", r);\n            return 0;\n        }\n    }\n\n    printf(\"GOOD\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. char형 배열 p를 선언하여 102개의 문자를 저장할 수 있게 하세요.  \n3. 정수형 변수 k를 선언하세요.  \n4. 정수형 변수 i와 r, mod를 선언하세요.  \n5. 두 개의 입력값을 받아오기 위해 scanf를 사용하여 문자열 p와 정수 k에 값을 입력하세요.  \n6. [rep_start(1)] r을 2부터 k-1까지 반복하는 for 루프를 작성하세요.  \n7. mod 변수를 0으로 초기화하세요.  \n8. [rep_start(2)] i를 통해 p의 각 문자에 접근하는 for 루프를 작성하세요.  \n9. p의 i번째 문자가 널(NULL) 문자가 아닐 때 반복하세요.  \n10. mod 값에 현재 mod와 p[i]를 숫자로 변환한 값을 사용하는 연산을 적용해 업데이트하세요.  \n11. [rep_end(2)]  \n12. [cond_start(1)] mod가 0인지 확인하는 조건문을 작성하세요.  \n13. mod가 0이라면 \"BAD\"와 r의 값을 출력하세요.  \n14. 프로그램을 종료하기 위해 return 0;을 실행하세요.  \n15. [cond_end(1)]  \n16. [rep_end(1)]  \n17. \"GOOD\"이라는 문자열을 출력하세요.  \n18. 프로그램을 종료하기 위해 return 0;을 실행하세요.  \n19. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i;\n    int plugs;\n    int total = 0;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        scanf(\"%d\", &plugs);\n        total = total + plugs;\n    }\n\n    total = total - (n - 1);\n\n    printf(\"%d\n\", total);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n과 i를 선언하세요.\n3. 사용할 멀티탭의 개수를 저장할 int형 변수 plugs를 선언하세요.\n4. 총 플러그 개수를 저장할 int형 변수 total을 0으로 초기화하세요.\n5. n에 대한 입력을 받으세요.\n6. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n7. 현재 반복에서 사용할 plugs에 대한 입력을 받으세요.\n8. total에 plugs를 더하세요.\n9. [rep_end(1)]\n10. total에서 (n - 1)을 빼주세요. (연결차단을 고려하기 위함)\n11. total 값을 출력하세요.\n12. return 0;으로 프로그램을 종료하세요.\n13. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i, j;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        for(j = 0; j < i; j++) {\n            printf(\" \");\n        }\n        for(j = 0; j < n - i; j++) {\n            printf(\"*\");\n        }\n        printf(\"\n\");\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n, i, j를 선언하세요.\n3. n의 값을 입력 받으세요.\n4. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n5. [rep_start(2)] j를 0부터 i-1까지 반복하는 for 루프를 작성하세요. \n6. 각 반복에서 공백(\" \")을 출력하세요.\n7. [rep_end(2)]\n8. [rep_start(2)] j를 0부터 n-i-1까지 반복하는 for 루프를 작성하세요.\n9. 각 반복에서 별표(\"*\")를 출력하세요.\n10. [rep_end(2)]\n11. 줄 바꿈을 출력하세요.\n12. [rep_end(1)]\n13. return 0;으로 프로그램을 종료하세요.\n14. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n, i, j;\n\n    scanf(\"%d\", &n);\n\n    for(i = 1; i <= n; i++) {\n        for(j = 0; j < n - i; j++) {\n            printf(\" \");\n        }\n        for(j = 0; j < 2 * i - 1; j++) {\n            printf(\"*\");\n        }\n        printf(\"\n\");\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n, i, j를 선언하세요.\n3. n의 값을 입력받으세요.\n4. [rep_start(1)] i를 1부터 n까지 반복하는 for 루프를 작성하세요.\n5. [rep_start(2)] j를 선언하여 n - i 번만큼 반복하는 for 루프를 작성하세요.\n6. 공백(\" \")을 출력하세요.\n7. [rep_end(2)]\n8. [rep_start(2)] j를 선언하여 2 * i - 1 만큼 반복하는 for 루프를 작성하세요.\n9. 별표(\"*\")를 출력하세요.\n10. [rep_end(2)]\n11. 줄바꿈을 출력하세요.\n12. [rep_end(1)]\n13. return 0;으로 프로그램을 종료하세요.\n14. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int i;\n    int out, in;\n    int current = 0;\n    int max = 0;\n\n    for(i = 0; i < 4; i++) {\n        scanf(\"%d %d\", &out, &in);\n        current = current - out + in;\n        if(current > max) {\n            max = current;\n        }\n    }\n\n    printf(\"%d\n\", max);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 i를 선언하여 반복의 인덱스로 사용합니다.\n3. 정수형 변수 out과 in을 선언하여 각각의 입력을 저장합니다.\n4. 현재 탑승 인원을 나타내는 int형 변수 current를 0으로 초기화합니다.\n5. 최대 탑승 인원을 기록할 int형 변수 max를 0으로 초기화합니다.\n6. [rep_start(1)] i를 0부터 3까지 반복하는 for 루프를 작성하세요.\n7. scanf 함수를 사용하여 out과 in의 값을 입력 받으세요.\n8. current에 out을 빼고 in을 더하여 현재 탑승 인원을 갱신하세요.\n9. [cond_start(2)] 현재 탑승 인원 current가 최대 인원 max보다 큰지 확인하는 조건문을 작성하세요.\n10. current가 max보다 크다면 max를 current로 갱신하세요.\n11. [cond_end(2)]\n12. [rep_end(1)]\n13. max 값을 출력하세요.\n14. return 0;으로 프로그램을 종료하세요.\n15. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int i;\n    int a, b, c;\n    int reward;\n    int max = 0;\n\n    scanf(\"%d\", &n);\n\n    for(i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &a, &b, &c);\n\n        if((a == b) && (b == c)) {\n            reward = 10000 + (a * 1000);\n        }\n        else if((a == b) || (a == c)) {\n            reward = 1000 + (a * 100);\n        }\n        else if(b == c) {\n            reward = 1000 + (b * 100);\n        }\n        else {\n            if((a > b) && (a > c)) {\n                reward = a * 100;\n            }\n            else if(b > c) {\n                reward = b * 100;\n            }\n            else {\n                reward = c * 100;\n            }\n        }\n\n        if(reward > max) {\n            max = reward;\n        }\n    }\n\n    printf(\"%d\n\", max);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 정수형 변수 i를 선언하세요.\n4. 정수형 변수 a, b, c를 선언하세요.\n5. 정수형 변수 reward를 선언하세요.\n6. 정수형 변수 max를 0으로 초기화하세요.\n7. n에 대한 입력을 받으세요.\n8. [rep_start(1)] i를 0부터 n-1까지 반복하는 for 루프를 작성하세요.\n9. a, b, c에 대한 입력을 받으세요.\n10. [cond_start(2)] a, b, c가 모두 같은지 확인하는 조건문을 작성하세요.\n11. 모두 같다면 reward를 10000에 a의 1000배를 더한 값으로 설정하세요.\n12. [cond_end(2)]\n13. [cond_start(2)] a와 b가 같거나 a와 c가 같은지 확인하는 조건문을 작성하세요.\n14. a와 b가 같다면 reward를 1000에 a의 100배를 더한 값으로 설정하세요.\n15. [cond_end(2)]\n16. [cond_start(2)] b와 c가 같은지 확인하는 조건문을 작성하세요.\n17. b와 c가 같다면 reward를 1000에 b의 100배를 더한 값으로 설정하세요.\n18. [cond_end(2)]\n19. [cond_start(2)] 모두 같지 않다면 조건문을 작성하세요.\n20. [cond_start(3)] a가 b보다 크고 c보다 큰지 확인하는 조건문을 작성하세요.\n21. a가 가장 크다면 reward를 a의 100배로 설정하세요.\n22. [cond_end(3)]\n23. [cond_start(3)] b가 c보다 크다는 조건문을 작성하세요.\n24. b가 가장 크면 reward를 b의 100배로 설정하세요.\n25. [cond_end(3)]\n26. 그렇지 않으면 reward를 c의 100배로 설정하세요.\n27. [cond_end(2)]\n28. [cond_start(2)] reward가 max보다 큰지 확인하는 조건문을 작성하세요.\n29. 보상이 max보다 크다면 max를 reward로 설정하세요.\n30. [cond_end(2)]\n31. [rep_end(1)]\n32. max를 출력하세요.\n33. return 0;으로 프로그램을 종료하세요.\n34. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N;\n    int i;\n    int sum = 0;\n\n    scanf(\"%d\", &N);\n\n    for(i = 1; i <= N; i++) {\n        int num = i;\n\n        while(num > 0) {\n            if((num % 10) == 2) {\n                sum = sum + i;\n                break;\n            }\n            num = num / 10;\n        }\n    }\n\n    printf(\"%d\", sum);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N을 선언하세요.\n3. 정수형 변수 i를 선언하세요.\n4. 소수의 합을 저장할 int형 변수 sum을 0으로 초기화하세요.\n5. N에 대한 입력을 받으세요.\n6. [rep_start(1)] i를 1부터 N까지 반복하는 for 루프를 작성하세요.\n7. i의 값을 num이라는 정수형 변수에 저장하세요.\n8. [rep_start(2)] num이 0보다 큰 동안 반복하는 while 루프를 작성하세요.\n9. [cond_start(3)] num의 마지막 자리가 2인지 확인하는 조건문을 작성하세요.\n10. 마지막 자리가 2라면 sum에 i를 더하세요.\n11. 반복을 종료하기 위해 break 문을 사용하세요.\n12. [cond_end(3)]\n13. num을 10으로 나누어 마지막 자리를 제거하세요.\n14. [rep_end(2)]\n15. [rep_end(1)]\n16. sum을 출력하세요.\n17. return 0;으로 프로그램을 종료하세요.\n18. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N;\n    int M;\n    int result;\n\n    scanf(\"%d %d\", &N, &M);\n\n    if(N > M)\n    {\n        result = N - M;\n    }\n    else\n    {\n        result = M - N;\n    }\n\n    printf(\"%d\", result);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 N을 선언하세요.  \n3. 정수형 변수 M을 선언하세요.  \n4. 정수형 변수 result를 선언하세요.  \n5. N과 M에 입력을 받으세요.  \n6. [cond_start(1)] N이 M보다 큰지 확인하는 조건문을 작성하세요.  \n7. N이 M보다 크면 result에 N과 M의 차이를 계산하여 저장하세요.  \n8. [cond_end(1)]  \n9. [cond_start(1)] 그렇지 않은 경우를 처리하는 조건문을 작성하세요.  \n10. result에 M과 N의 차이를 계산하여 저장하세요.  \n11. [cond_end(1)]  \n12. result의 값을 출력하세요.  \n13. return 0;으로 프로그램을 종료하세요.  \n14. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int N;\n    int M;\n    int absN;\n    int absM;\n    int result;\n\n    scanf(\"%d %d\", &N, &M);\n\n    if(N < 0)\n    {\n        absN = -N;\n    }\n    else\n    {\n        absN = N;\n    }\n\n    if(M < 0)\n    {\n        absM = -M;\n    }\n    else\n    {\n        absM = M;\n    }\n\n    if(absN > absM)\n    {\n        result = absN - absM;\n    }\n    else\n    {\n        result = absM - absN;\n    }\n\n    printf(\"%d\", result);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 N을 선언하세요.\n3. 정수형 변수 M을 선언하세요.\n4. 정수형 변수 absN을 선언하세요.\n5. 정수형 변수 absM을 선언하세요.\n6. 정수형 변수 result를 선언하세요.\n7. M과 N에 입력을 받으세요.\n8. [cond_start(1)] N이 0보다 작은지 확인하는 조건문을 작성하세요.\n9. N이 작다면 absN를 N의 음수로 설정하세요.\n10. [cond_end(1)]\n11. [cond_start(1)] N이 0보다 크면 absN에 N을 할당하세요.\n12. [cond_end(1)]\n13. [cond_start(1)] M이 0보다 작은지 확인하는 조건문을 작성하세요.\n14. M이 작다면 absM를 M의 음수로 설정하세요.\n15. [cond_end(1)]\n16. [cond_start(1)] M이 0보다 크면 absM에 M을 할당하세요.\n17. [cond_end(1)]\n18. [cond_start(1)] absN이 absM보다 큰지 확인하는 조건문을 작성하세요.\n19. absN이 더 크면 result에 absN에서 absM를 뺀 값을 할당하세요.\n20. [cond_end(1)]\n21. [cond_start(1)] absM가 더 크면 result에 absM에서 absN를 뺀 값을 할당하세요.\n22. [cond_end(1)]\n23. result를 출력하세요.\n24. return 0;으로 프로그램을 종료하세요.\n25. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int num;\n    int even = 0;\n    int odd = 0;\n\n    while(1)\n    {\n        scanf(\"%d\", &num);\n\n        if(num == 0)\n        {\n            break;\n        }\n\n        if(num % 2 == 0)\n        {\n            even = even + 1;\n        }\n        else\n        {\n            odd = odd + 1;\n        }\n    }\n\n    printf(\"%d %d\", even, odd);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 num을 선언하세요.\n3. 소수의 개수를 세기 위한 int형 변수 even을 0으로 초기화하세요.\n4. 소수의 개수를 세기 위한 int형 변수 odd을 0으로 초기화하세요.\n5. [rep_start(1)] 무한 루프를 시작하세요.\n6. num에 대한 입력을 받으세요.\n7. [cond_start(2)] num이 0인지 확인하는 조건문을 작성하세요.\n8. num이 0이라면 루프를 종료하세요.\n9. [cond_end(2)]\n10. [cond_start(2)] num이 짝수인지 확인하는 조건문을 작성하세요.\n11. num이 짝수라면 even을 1 증가시키세요.\n12. [cond_end(2)]\n13. [cond_start(2)] num이 홀수라면 조건문을 작성하세요.\n14. odd을 1 증가시키세요.\n15. [cond_end(2)]\n16. [rep_end(1)]\n17. even과 odd의 값을 출력하세요.\n18. return 0;으로 프로그램을 종료하세요.\n19. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int a, b, c;\n    int max, min;\n\n    scanf(\"%d %d %d\", &a, &b, &c);\n\n    max = a;\n    if(b > max)\n    {\n        max = b;\n    }\n    if(c > max)\n    {\n        max = c;\n    }\n\n    min = a;\n    if(b < min)\n    {\n        min = b;\n    }\n    if(c < min)\n    {\n        min = c;\n    }\n\n    printf(\"%d %d\", max, min);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 a, b, c를 선언하세요.\n3. 정수형 변수 max와 min을 선언하세요.\n4. a, b, c의 값을 입력받으세요.\n5. max를 a로 초기화하세요.\n6. [cond_start(1)] b가 max보다 큰지 확인하는 조건문을 작성하세요.\n7. b가 max보다 크다면 max를 b로 업데이트하세요.\n8. [cond_end(1)]\n9. [cond_start(1)] c가 max보다 큰지 확인하는 조건문을 작성하세요.\n10. c가 max보다 크다면 max를 c로 업데이트하세요.\n11. [cond_end(1)]\n12. min을 a로 초기화하세요.\n13. [cond_start(1)] b가 min보다 작은지 확인하는 조건문을 작성하세요.\n14. b가 min보다 작다면 min을 b로 업데이트하세요.\n15. [cond_end(1)]\n16. [cond_start(1)] c가 min보다 작은지 확인하는 조건문을 작성하세요.\n17. c가 min보다 작다면 min을 c로 업데이트하세요.\n18. [cond_end(1)]\n19. max와 min의 값을 출력하세요.\n20. return 0;으로 프로그램을 종료하세요.\n21. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int a, b, c, d;\n    int max, min;\n\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\n    max = a;\n    if(b > max)\n    {\n        max = b;\n    }\n    if(c > max)\n    {\n        max = c;\n    }\n    if(d > max)\n    {\n        max = d;\n    }\n\n    min = a;\n    if(b < min)\n    {\n        min = b;\n    }\n    if(c < min)\n    {\n        min = c;\n    }\n    if(d < min)\n    {\n        min = d;\n    }\n\n    printf(\"%d %d\", max, min);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 a, b, c, d를 선언하세요.\n3. 정수형 변수 max와 min을 선언하세요.\n4. a, b, c, d에 입력을 받으세요.\n5. max를 a로 초기화하세요.\n6. [cond_start(1)] b가 max보다 큰지 확인하는 조건문을 작성하세요.\n7. b가 max보다 크면 max를 b로 설정하세요.\n8. [cond_end(1)]\n9. [cond_start(1)] c가 max보다 큰지 확인하는 조건문을 작성하세요.\n10. c가 max보다 크면 max를 c로 설정하세요.\n11. [cond_end(1)]\n12. [cond_start(1)] d가 max보다 큰지 확인하는 조건문을 작성하세요.\n13. d가 max보다 크면 max를 d로 설정하세요.\n14. [cond_end(1)]\n15. min을 a로 초기화하세요.\n16. [cond_start(1)] b가 min보다 작은지 확인하는 조건문을 작성하세요.\n17. b가 min보다 작으면 min을 b로 설정하세요.\n18. [cond_end(1)]\n19. [cond_start(1)] c가 min보다 작은지 확인하는 조건문을 작성하세요.\n20. c가 min보다 작으면 min을 c로 설정하세요.\n21. [cond_end(1)]\n22. [cond_start(1)] d가 min보다 작은지 확인하는 조건문을 작성하세요.\n23. d가 min보다 작으면 min을 d로 설정하세요.\n24. [cond_end(1)]\n25. max와 min을 출력하세요.\n26. return 0;으로 프로그램을 종료하세요.\n27. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int a, b;\n    int sum = 0;\n\n    scanf(\"%d %d\", &a, &b);\n\n    for(int i = a + 1; i < b; i++)\n    {\n        int is_prime = 1;\n        if(i < 2)\n        {\n            is_prime = 0;\n        }\n        else\n        {\n            for(int j = 2; j * j <= i; j++)\n            {\n                if(i % j == 0)\n                {\n                    is_prime = 0;\n                    break;\n                }\n            }\n        }\n        if(is_prime)\n        {\n            sum = sum + i;\n        }\n    }\n\n    printf(\"%d\", sum);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 a와 b를 선언하세요.  \n3. 소수의 합을 저장할 int형 변수 sum을 0으로 초기화하세요.  \n4. a와 b에 입력을 받으세요.  \n5. [rep_start(1)] i를 선언해 a + 1부터 b - 1까지 반복하는 for 루프를 작성하세요.  \n6. 소수 상태를 나타내기 위해 int형 변수 is_prime을 1로 초기화하세요.  \n7. [cond_start(2)] i가 2보다 작은지 확인하는 조건문을 작성하세요.  \n8. i가 2보다 작다면 is_prime을 0으로 설정하세요.  \n9. [cond_end(2)]  \n10. [cond_start(2)] 그 외의 경우에 대해 진행하는 조건문을 작성하세요.  \n11. [rep_start(3)] j를 선언해 2부터 √i까지 반복하는 for 루프를 작성하세요.  \n12. [cond_start(4)] i가 j로 나누어지는지 확인하는 조건문을 작성하세요.  \n13. i가 j로 나누어지면 is_prime을 0으로 설정하고 루프를 종료하세요.  \n14. [cond_end(4)]  \n15. [rep_end(3)]  \n16. [cond_end(2)]  \n17. [cond_start(2)] is_prime이 1인 경우의 조건문을 작성하세요.  \n18. i가 소수라면 sum에 i를 더하세요.  \n19. [cond_end(2)]  \n20. [rep_end(1)]  \n21. sum을 출력하세요.  \n22. return 0;으로 프로그램을 종료하세요.  \n23. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n\n    scanf(\"%d\", &n);\n\n    while(n > 0)\n    {\n        printf(\"%d\", n % 10);\n        n = n / 10;\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 n을 선언하세요.  \n3. n에 대한 입력을 받으세요.  \n4. [rep_start(1)] n이 0보다 큰 동안 반복하는 while 루프를 작성하세요.  \n5. n의 일의 자리 숫자를 출력하세요.  \n6. n의 값을 10으로 나누어 일의 자리 숫자를 제거하세요.  \n7. [rep_end(1)]  \n8. return 0;으로 프로그램을 종료하세요.  \n9. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int i;\n    int fact = 1;\n\n    for(i = 1; i <= n; i = i + 1)\n    {\n        fact = fact * i;\n    }\n\n    int count = 0;\n\n    for(i = 2; i < fact; i = i + 1)\n    {\n        int j;\n        int is_prime = 1;\n\n        for(j = 2; j * j <= i; j = j + 1)\n        {\n            if(i % j == 0)\n            {\n                is_prime = 0;\n                break;\n            }\n        }\n\n        if(is_prime == 1)\n        {\n            count = count + 1;\n        }\n    }\n\n    printf(\"%d\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 n을 선언하세요.  \n3. n에 입력을 받으세요.  \n4. 정수형 변수 i를 선언하세요.  \n5. int형 변수 fact를 1로 초기화하세요.  \n6. [rep_start(1)] i를 1부터 n까지 반복하는 for 루프를 작성하세요.  \n7. fact에 i를 곱해 업데이트하세요.  \n8. [rep_end(1)]  \n9. int형 변수 count를 0으로 초기화하세요.  \n10. [rep_start(1)] i를 2부터 fact-1까지 반복하는 for 루프를 작성하세요.  \n11. 정수형 변수 j를 선언하고, int형 변수 is_prime을 1로 초기화하세요.  \n12. [rep_start(2)] j를 2부터 i의 제곱근까지 반복하는 for 루프를 작성하세요.  \n13. [cond_start(3)] i가 j로 나누어지는지 확인하는 조건문을 작성하세요.  \n14. i가 j로 나누어지면 is_prime을 0으로 설정하세요.  \n15. 반복문을 종료합니다 (break).  \n16. [cond_end(3)]  \n17. [rep_end(2)]  \n18. [cond_start(2)] is_prime이 1인지 확인하는 조건문을 작성하세요.  \n19. is_prime이 1이라면 count에 1을 더하세요.  \n20. [cond_end(2)]  \n21. [rep_end(1)]  \n22. count를 출력하세요.  \n23. return 0;으로 프로그램을 종료하세요.  \n24. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int a = 0;\n    int b = 1;\n    int count = 0;\n\n    while(a < n)\n    {\n        count = count + 1;\n        int temp = a + b;\n        a = b;\n        b = temp;\n    }\n\n    printf(\"%d\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. n에 입력을 받으세요.\n4. 정수형 변수 a를 0으로 초기화하세요.\n5. 정수형 변수 b를 1로 초기화하세요.\n6. 정수형 변수 count를 0으로 초기화하세요.\n7. [rep_start(1)] a가 n보다 작은 동안 반복하는 while 루프를 작성하세요.\n8. count를 1 증가시키세요.\n9. 정수형 변수 temp에 a와 b의 합을 저장하세요.\n10. a에 b의 값을 저장하세요.\n11. b에 temp의 값을 저장하세요.\n12. [rep_end(1)]\n13. n에 도달하기 위해 반복한 횟수 count를 출력하세요.\n14. return 0;으로 프로그램을 종료하세요.\n15. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int i;\n    int j;\n    int sum;\n\n    scanf(\"%d\", &n);\n\n    for(i = n; i > 1; i--) {\n        sum = 0;\n        for(j = 1; j <= i; j++) {\n            sum = sum + j;\n        }\n        printf(\"%d\", sum);\n        if(i > 2) {\n            printf(\" \");\n        }\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 정수형 변수 i를 선언하세요.\n4. 정수형 변수 j를 선언하세요.\n5. 정수형 변수 sum을 선언하세요.\n6. n에 대한 입력을 받으세요.\n7. [rep_start(1)] i를 n부터 2까지 감소하는 반복문으로 설정하세요.\n8. sum을 0으로 초기화하세요.\n9. [rep_start(2)] j를 1부터 i까지 반복하는 for 루프를 작성하세요.\n10. sum에 j를 더하세요.\n11. [rep_end(2)]\n12. sum 값을 출력하세요.\n13. [cond_start(2)] i가 2보다 큰지를 확인하는 조건문을 작성하세요.\n14. i가 2보다 크면 공백을 출력하세요.\n15. [cond_end(2)]\n16. [rep_end(1)]\n17. return 0;으로 프로그램을 종료하세요.\n18. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint is_prime(int num) {\n    int i;\n\n    if(num < 2) {\n        return 0;\n    }\n\n    for(i = 2; i < num; i++) {\n        if((num % i) == 0) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nint main() {\n    int n;\n    int up;\n    int down;\n\n    scanf(\"%d\", &n);\n\n    up = n + 1;\n    down = n - 1;\n\n    while(1) {\n        if(down > 1) {\n            if(is_prime(down)) {\n                printf(\"%d\", down);\n                return 0;\n            }\n        }\n\n        if(is_prime(up)) {\n            printf(\"%d\", up);\n            return 0;\n        }\n\n        up = up + 1;\n        if(down > 1) {\n            down = down - 1;\n        }\n    }\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 함수 is_prime을 정의하세요. (매개변수: int num)\n2. 정수형 변수 i를 선언하세요.\n3. [cond_start(1)] num이 2보다 작은지 확인하는 조건문을 작성하세요.\n4. num이 2보다 작으면 0을 반환하세요.\n5. [cond_end(1)]\n6. [rep_start(1)] i를 2로 초기화하고 num-1까지 반복하는 for 루프를 작성하세요.\n7. [cond_start(2)] num이 i로 나누어 떨어지는지 확인하는 조건문을 작성하세요.\n8. num이 i로 나누어 떨어지면 0을 반환하세요.\n9. [cond_end(2)]\n10. [rep_end(1)]\n11. 위의 과정을 통과한 num은 소수이므로 1을 반환하세요.\n12. [func_def_end(1)]\n13. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n14. 정수형 변수 n을 선언하세요.\n15. 정수형 변수 up과 down을 선언하세요.\n16. n에 대한 입력을 받으세요.\n17. up을 n + 1로 초기화하세요.\n18. down을 n - 1로 초기화하세요.\n19. [rep_start(1)] 무한 루프를 작성하여 계속 반복합니다.\n20. [cond_start(2)] down이 1보다 큰지 확인하는 조건문을 작성하세요.\n21. down이 1보다 크다면, is_prime 함수를 호출하여 down이 소수인지 확인하세요.\n22. down이 소수라면 down을 출력하고 프로그램을 종료하세요.\n23. [cond_end(2)]\n24. [cond_start(2)] up이 소수인지 확인하는 조건문을 작성하세요.\n25. up이 소수라면 up을 출력하고 프로그램을 종료하세요.\n26. [cond_end(2)]\n27. up을 1만큼 증가시키세요.\n28. [cond_start(2)] down이 1보다 큰지 확인하는 조건문을 작성하세요.\n29. down이 1보다 크면 down을 1만큼 감소시키세요.\n30. [cond_end(2)]\n31. [rep_end(1)]\n32. return 0;으로 프로그램을 종료하세요.\n33. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int a;\n    int count;\n    int i;\n    int temp;\n\n    scanf(\"%d %d\", &n, &a);\n\n    count = 0;\n\n    for(i = 1; i <= n; i++) {\n        temp = i;\n        while(temp > 0) {\n            if((temp % 10) == a) {\n                count = count + 1;\n            }\n            temp = temp / 10;\n        }\n    }\n\n    printf(\"%d\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n과 a를 선언하세요.\n3. 정수형 변수 count를 선언하세요.\n4. 정수형 변수 i를 선언하세요.\n5. 정수형 변수 temp를 선언하세요.\n6. n과 a에 입력을 받으세요.\n7. count를 0으로 초기화하세요.\n8. [rep_start(1)] i를 선언해 1부터 n까지 반복하는 for 루프를 작성하세요.\n9. temp에 i의 값을 저장하세요.\n10. [rep_start(2)] temp가 0보다 큰 동안 반복하는 while 루프를 작성하세요.\n11. [cond_start(3)] temp의 일의 자리 숫자가 a와 같은지 확인하는 조건문을 작성하세요.\n12. temp의 일의 자리 숫자가 a와 같다면 count를 1 증가시키세요.\n13. [cond_end(3)]\n14. temp를 10으로 나누어 일의 자리를 제거하세요.\n15. [rep_end(2)]\n16. [rep_end(1)]\n17. count를 출력하세요.\n18. return 0;으로 프로그램을 종료하세요.\n19. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int i;\n    int j;\n    int count;\n    int is_prime;\n\n    scanf(\"%d\", &n);\n\n    count = 0;\n\n    for(i = 2; i <= n; i++) {\n        is_prime = 1;\n        for(j = 2; j < i; j++) {\n            if((i % j) == 0) {\n                is_prime = 0;\n            }\n        }\n        if(is_prime == 1) {\n            count = count + 1;\n        }\n    }\n\n    printf(\"%d\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 정수형 변수 i를 선언하세요.\n4. 정수형 변수 j를 선언하세요.\n5. 정수형 변수 count를 선언하세요.\n6. 정수형 변수 is_prime을 선언하세요.\n7. 사용자로부터 n 값을 입력받으세요.\n8. count 변수를 0으로 초기화하세요.\n9. [rep_start(1)] i를 2부터 n까지 반복하는 for 루프를 작성하세요.\n10. is_prime 변수를 1로 초기화하여 i가 소수임을 가정하세요.\n11. [rep_start(2)] j를 2부터 i-1까지 반복하는 for 루프를 작성하세요.\n12. [cond_start(3)] i가 j로 나누어지는지 확인하는 조건문을 작성하세요.\n13. i가 j로 나누어지면 is_prime을 0으로 설정하세요.\n14. [cond_end(3)]\n15. [rep_end(2)]\n16. [cond_start(2)] is_prime이 1인지 확인하는 조건문을 작성하세요.\n17. is_prime이 1이라면 count에 1을 더하세요.\n18. [cond_end(2)]\n19. [rep_end(1)]\n20. count의 값을 출력하세요.\n21. return 0;으로 프로그램을 종료하세요.\n22. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int a;\n    int b;\n    int c;\n    int max;\n\n    scanf(\"%d %d %d\", &a, &b, &c);\n\n    max = a;\n\n    if(b > max) {\n        max = b;\n    }\n\n    if(c > max) {\n        max = c;\n    }\n\n    printf(\"%d\", max);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)  \n2. 정수형 변수 a, b, c, max를 선언하세요.  \n3. a, b, c에 입력을 받으세요.  \n4. max를 a로 초기화하세요.  \n5. [cond_start(1)] b가 max보다 큰지 확인하는 조건문을 작성하세요.  \n6. b가 max보다 크면 max를 b로 변경하세요.  \n7. [cond_end(1)]  \n8. [cond_start(1)] c가 max보다 큰지 확인하는 조건문을 작성하세요.  \n9. c가 max보다 크면 max를 c로 변경하세요.  \n10. [cond_end(1)]  \n11. max 값을 출력하세요.  \n12. return 0;으로 프로그램을 종료하세요.  \n13. [func_def_end(1)]  "
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int i;\n    int a;\n    int b;\n    int fib;\n\n    scanf(\"%d\", &n);\n\n    if(n == 0) {\n        printf(\"0\");\n        return 0;\n    }\n\n    if(n == 1) {\n        printf(\"1\");\n        return 0;\n    }\n\n    a = 0;\n    b = 1;\n\n    for(i = 2; i <= n; i++) {\n        fib = a + b;\n        a = b;\n        b = fib;\n    }\n\n    printf(\"%d\", fib);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요.\n3. 정수형 변수 i를 선언하세요.\n4. 정수형 변수 a를 선언하세요.\n5. 정수형 변수 b를 선언하세요.\n6. 정수형 변수 fib을 선언하세요.\n7. n의 값을 입력받으세요.\n8. [cond_start(1)] n이 0인지 확인하는 조건문을 작성하세요.\n9. n이 0이면 \"0\"을 출력하세요.\n10. 프로그램을 종료하기 위해 return 0;을 실행하세요.\n11. [cond_end(1)]\n12. [cond_start(1)] n이 1인지 확인하는 조건문을 작성하세요.\n13. n이 1이면 \"1\"을 출력하세요.\n14. 프로그램을 종료하기 위해 return 0;을 실행하세요.\n15. [cond_end(1)]\n16. a에 0을 할당하여 초기화하세요.\n17. b에 1을 할당하여 초기화하세요.\n18. [rep_start(1)] i를 2부터 n까지 반복하는 for 루프를 작성하세요.\n19. fib에 a와 b를 더한 값을 할당하세요.\n20. a에 b의 값을 할당하세요.\n21. b에 fib의 값을 할당하세요.\n22. [rep_end(1)]\n23. fib의 값을 출력하세요.\n24. return 0;으로 프로그램을 종료하세요.\n25. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int n;\n    int i;\n    int a;\n    int b;\n    int fib;\n\n    scanf(\"%d\", &n);\n\n    if(n == 0) {\n        printf(\"0\");\n        return 0;\n    }\n\n    if(n == 1) {\n        printf(\"1\");\n        return 0;\n    }\n\n    a = 0;\n    b = 1;\n\n    for(i = 2; i <= n; i++) {\n        fib = a + b;\n        a = b;\n        b = fib;\n    }\n\n    printf(\"%d\", fib);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 n을 선언하세요. (피보나치 수열의 항 번호)\n3. 정수형 변수 i를 선언하세요. (반복문에서 사용할 카운터)\n4. 정수형 변수 a를 선언하세요. (피보나치 수열의 첫 번째 항)\n5. 정수형 변수 b를 선언하세요. (피보나치 수열의 두 번째 항)\n6. 정수형 변수 fib을 선언하세요. (현재 피보나치 수열의 항)\n7. n의 값을 입력받으세요.\n8. [cond_start(1)] n이 0인지 확인하는 조건문을 작성하세요.\n9. n이 0이라면 0을 출력하세요.\n10. return 0;으로 프로그램을 종료하세요.\n11. [cond_end(1)]\n12. [cond_start(1)] n이 1인지 확인하는 조건문을 작성하세요.\n13. n이 1이라면 1을 출력하세요.\n14. return 0;으로 프로그램을 종료하세요.\n15. [cond_end(1)]\n16. a를 0으로 초기화하세요. (첫 번째 피보나치 수)\n17. b를 1로 초기화하세요. (두 번째 피보나치 수)\n18. [rep_start(1)] i를 2부터 n까지 반복하는 for 루프를 작성하세요.\n19. fib를 a와 b의 합으로 계산하세요.\n20. a를 b로 업데이트하세요. (다음 항을 준비)\n21. b를 fib으로 업데이트하세요. (현재 항을 다음 항으로 설정)\n22. [rep_end(1)]\n23. 현재 피보나치 수인 fib을 출력하세요.\n24. return 0;으로 프로그램을 종료하세요.\n25. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  },
  {
    "conversations": [
      {
        "role": "user",
        "content": "\n#include <stdio.h>\n\nint main() {\n    int s;\n    int e;\n    int y;\n    int count;\n\n    scanf(\"%d %d\", &s, &e);\n\n    count = 0;\n\n    for(y = s + 1; y < e; y++) {\n        if((y % 4) == 0) {\n            if((y % 100) != 0) {\n                count = count + 1;\n            }\n            else if((y % 400) == 0) {\n                count = count + 1;\n            }\n        }\n    }\n\n    printf(\"%d\", count);\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "1. [func_def_start(1)] int 반환형 main 함수를 정의하세요. (매개변수 없음)\n2. 정수형 변수 s와 e를 선언하세요.\n3. 정수형 변수 y와 count를 선언하세요.\n4. s와 e에 입력을 받으세요.\n5. count 변수를 0으로 초기화하세요.\n6. [rep_start(1)] y를 선언해 s + 1부터 e-1까지 반복하는 for 루프를 작성하세요.\n7. [cond_start(2)] y가 4로 나누어지는지 확인하는 조건문을 작성하세요.\n8. y가 4로 나누어지면 [cond_start(3)] y가 100으로 나누어지지 않는지 확인하는 조건문을 작성하세요.\n9. y가 100으로 나누어지지 않으면 count를 1 증가시키세요.\n10. [cond_end(3)]\n11. [cond_start(3)] y가 400으로 나누어지는지 확인하는 조건문을 작성하세요.\n12. y가 400으로 나누어지면 count를 1 증가시키세요.\n13. [cond_end(3)]\n14. [cond_end(2)]\n15. [rep_end(1)]\n16. count의 값을 출력하세요.\n17. return 0;으로 프로그램을 종료하세요.\n18. [func_def_end(1)]"
      }
    ],
    "source": "custom-dataset",
    "score": 4.8
  }
]